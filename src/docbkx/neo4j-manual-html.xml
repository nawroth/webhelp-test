<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<book lang="en">
<bookinfo>
<mediaobject>
  <imageobject>
    <imagedata fileref="images/front-cover.svg"/>
  </imageobject>
</mediaobject>
    <title>The Neo4j Manual v2.0-SNAPSHOT</title>
<!--

    Copyright (c) 2002-2014 "Neo Technology,"
    Network Engine for Objects in Lund AB [http://neotechnology.com]

    This file is part of Neo4j.

    Neo4j is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.

-->
<authorgroup>
  <corpauthor>The Neo4j Team
    <ulink url="http://neo4j.org/"><citetitle>neo4j.org</citetitle></ulink>
    <ulink url="http://www.neotechnology.com/"><citetitle>www.neotechnology.com</citetitle></ulink>
  </corpauthor>
</authorgroup>

<copyright>
  <year>2014</year>
  <holder>Neo Technology</holder>
</copyright>

<abstract>
  <title>Starting points</title>
  <para>
    <itemizedlist>
      <listitem>
        <para>
          <link linkend="what-is-a-graphdb">What is a graph database?</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link linkend="cypher-query-lang">Cypher Query Language</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link linkend="languages">Languages / Remote Client Libraries</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link linkend="rest-api">REST API</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link linkend="deployment">Installation</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link linkend="deployment-upgrading">Upgrading</link>
        </para>
      </listitem>
      <listitem>
        <para>
          <link linkend="operations-security">Security</link>
        </para>
      </listitem>
    </itemizedlist>
  </para>
</abstract>

<legalnotice>
  <title>License: Creative Commons 3.0</title>
  <simpara>This book is presented in open source and licensed through
    Creative Commons 3.0.
    You are free to copy, distribute, transmit,
    and/or adapt the work.
    This license is based upon the following
    conditions:</simpara>
  <formalpara>
    <title>Attribution</title>
    <para>You must attribute the work in the manner specified by the
      author or licensor (but not in any way that suggests that they
      endorse you or your use of the work).</para>
  </formalpara>
  <formalpara>
    <title>Share Alike</title>
    <para>If you alter, transform, or build upon this work, you may
      distribute the resulting work only under the same, similar or a
      compatible license.</para>
  </formalpara>
  <simpara>Any of the above conditions can be waived if you get
    permission from the copyright holder.</simpara>
  <simpara>In no way are any of the following rights affected by the
    license:</simpara>
  <itemizedlist>
    <listitem>
      <simpara>
        Your fair dealing or fair use rights
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        The author&#8217;s moral rights
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        Rights other persons may have either in the work itself
        or in how the
        work is used, such as publicity or privacy rights
      </simpara>
    </listitem>
  </itemizedlist>
  <note>
    <simpara>
      For any reuse or distribution, you must make clear to the others
      the license terms of this work. The best way to do this is with a
      direct link to this page:
      <ulink url="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/
      </ulink>
    </simpara>
  </note>
</legalnotice>

<pubdate><?dbtimestamp format="Y-m-d H:M:S"?></pubdate>
</bookinfo>
<preface id="preface">
<title>Preface</title>
<simpara>This is the reference manual for Neo4j version 2.0-SNAPSHOT, authored by the Neo4j Team.</simpara>
<simpara>The main parts of the manual are:</simpara>
<itemizedlist>
<listitem>
<simpara>
<xref linkend="introduction"/>&#8201;&#8212;&#8201;introducing graph database concepts and Neo4j.
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="tutorials"/>&#8201;&#8212;&#8201;learn how to use Neo4j.
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="cypher-query-lang"/>&#8201;&#8212;&#8201;details on the Cypher query language.
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="reference-documentation"/>&#8201;&#8212;&#8201;detailed information on Neo4j.
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="operations"/>&#8201;&#8212;&#8201;how to install and maintain Neo4j.
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="tools"/>&#8201;&#8212;&#8201;guides on tools.
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="community"/>&#8201;&#8212;&#8201;getting help from, contributing to.
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="advanced-usage"/>&#8201;&#8212;&#8201;using Neo4j in more advanced ways.
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="manpages"/>&#8201;&#8212;&#8201;command line documentation.
</simpara>
</listitem>
</itemizedlist>
<simpara>The material is practical, technical, and focused on answering specific questions.
It addresses how things work, what to do and what to avoid to successfully run Neo4j in a production environment.</simpara>
<simpara>The goal is to be thumb-through and rule-of-thumb friendly.</simpara>
<simpara>Each section should stand on its own, so you can hop right to whatever interests you.
When possible, the sections distill &#8220;rules of thumb&#8221; which you can keep in mind whenever you wander out of the house without this manual in your back pocket.</simpara>
<simpara>The included code examples are executed when Neo4j is built and tested.
Also, the REST API request and response examples are captured from real interaction with a Neo4j server.
Thus, the examples are always in sync with how Neo4j actually works.</simpara>
<simpara>There&#8217;s other documentation resources besides the manual as well:</simpara>
<itemizedlist>
<listitem>
<simpara>
Neo4j Cypher Refcard, see <ulink url="http://docs.neo4j.org/">http://docs.neo4j.org/</ulink> for available versions.
</simpara>
</listitem>
<listitem>
<simpara>
Neo4j GraphGist, an online tool for creating interactive web pages with executable Cypher statements: <ulink url="http://gist.neo4j.org/">http://gist.neo4j.org/</ulink>.
</simpara>
</listitem>
<listitem>
<simpara>
The main Neo4j site at <ulink url="http://www.neo4j.org/">http://www.neo4j.org/</ulink> is a good starting point to learn about Neo4j.
</simpara>
</listitem>
</itemizedlist>
<simpara>For a PDF version of the manual, see <ulink url="http://docs.neo4j.org/">http://docs.neo4j.org/</ulink>.</simpara>
<simpara><emphasis>Who should read this?</emphasis></simpara>
<simpara>The topics should be relevant to architects, administrators, developers and operations personnel.</simpara>
</preface>
<part id="introduction">
<title>Introduction</title>
<partintro>
<simpara>This part gives a bird&#8217;s eye view of what a graph database is, and then outlines some specifics of Neo4j.</simpara>
</partintro>
<chapter id="introduction-highlights">
<title>Neo4j Highlights</title>
<simpara>As a robust, scalable and high-performance database, Neo4j is suitable for full enterprise deployment or a subset of the full server can be used in lightweight projects.</simpara>
<simpara>It features:</simpara>
<itemizedlist>
<listitem>
<simpara>
true ACID transactions,
</simpara>
</listitem>
<listitem>
<simpara>
high availability,
</simpara>
</listitem>
<listitem>
<simpara>
scales to billions of nodes and relationships,
</simpara>
</listitem>
<listitem>
<simpara>
high speed querying through traversals,
</simpara>
</listitem>
<listitem>
<simpara>
declarative graph query language.
</simpara>
</listitem>
</itemizedlist>
<simpara>Proper ACID behavior is the foundation of data reliability.
Neo4j enforces that all operations that modify data occur within a transaction, guaranteeing consistent data.
This robustness extends from single instance embedded graphs to multi-server high availability installations.
For details, see <xref linkend="transactions"/>.</simpara>
<simpara>Reliable graph storage can easily be added to any application.
A graph can scale in size and complexity as the application evolves, with little impact on performance.
Whether starting new development, or augmenting existing functionality, Neo4j is only limited by physical hardware.</simpara>
<simpara>A single server instance can handle a graph of billions of nodes and relationships.
When data throughput is insufficient, the graph database can be distributed among multiple servers in a high availability configuration.
See <xref linkend="ha"/> to learn more.</simpara>
<simpara>The graph database storage shines when storing richly-connected data.
Querying is performed through traversals, which can perform millions of traversal steps per second.
A traversal step resembles a <emphasis>join</emphasis> in a RDBMS.</simpara>
</chapter>
<chapter id="graphdb-concepts">
<title>Graph Database Concepts</title>
<simpara>This chapter contains an introduction to the graph data model and also compares it to other data models used when persisting data.</simpara>
<section id="what-is-a-graphdb">
<title>What is a Graph Database?</title>
<simpara>A graph database stores data in a graph, the most generic of data structures, capable of elegantly representing any kind of data in a highly accessible way.
Let’s follow along some graphs, using them to express graph concepts.
We’ll &#8220;read&#8221; a graph by following arrows around the diagram to form sentences.</simpara>
<section id="_a_graph_contains_nodes_and_relationships">
<title>A Graph contains Nodes and Relationships</title>
<blockquote>
<simpara>&#8220;A Graph —records data in&#8594; Nodes —which have&#8594; Properties&#8221;</simpara>
</blockquote>
<simpara>The simplest possible graph is a single Node, a record that has named values referred to as Properties.
A Node could start with a single Property and grow to a few million Properties, though that can get a little awkward.
At some point it makes sense to distribute the data into multiple nodes, organized with explicit Relationships.</simpara>
<informalfigure>
<ulink url="images/graphdb-GVE.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-GVE.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-GVE.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
</section>
<section id="_relationships_organize_the_graph">
<title>Relationships organize the Graph</title>
<blockquote>
<simpara>&#8220;Nodes —are organized by&#8594; Relationships —which also have&#8594; Properties&#8221;</simpara>
</blockquote>
<simpara>Relationships organize Nodes into arbitrary structures, allowing a Graph to resemble a List, a Tree, a Map, or a compound Entity – any of which can be combined into yet more complex, richly inter-connected structures.</simpara>
</section>
<section id="_labels_group_the_nodes">
<title>Labels group the Nodes</title>
<blockquote>
<simpara>&#8220;Nodes —are grouped by&#8594; Labels —into&#8594; Sets&#8221;</simpara>
</blockquote>
<simpara>Labels are a means of grouping the nodes in the graph.
They can be used to restrict queries to subsets of the graph, as well as enabling optional model constraints and indexing rules.</simpara>
</section>
<section id="_query_a_graph_with_a_traversal">
<title>Query a Graph with a Traversal</title>
<blockquote>
<simpara>&#8220;A Traversal —navigates&#8594; a Graph; it —identifies&#8594; Paths —which order&#8594; Nodes&#8221;</simpara>
</blockquote>
<simpara>A Traversal is how you query a Graph, navigating from starting Nodes to related Nodes according to an algorithm, finding answers to questions like &#8220;what music do my friends like that I don&#8217;t yet own,&#8221; or &#8220;if this power supply goes down, what web services are affected?&#8221;</simpara>
<informalfigure>
<ulink url="images/graphdb-traversal.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-traversal.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-traversal.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
</section>
<section id="_indexes_look_up_nodes_or_relationships">
<title>Indexes look-up Nodes or Relationships</title>
<blockquote>
<simpara>&#8220;An Index —maps from&#8594; Properties —to either&#8594; Nodes or Relationships&#8221;</simpara>
</blockquote>
<simpara>Often, you want to find a specific Node or Relationship according to a Property it has.
Rather than traversing the entire graph, use an Index to perform a look-up, for questions like &#8220;find the Account for username master-of-graphs.&#8221;</simpara>
<informalfigure>
<ulink url="images/graphdb-indexes.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-indexes.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-indexes.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
</section>
<section id="_neo4j_is_a_graph_database">
<title>Neo4j is a Graph Database</title>
<blockquote>
<simpara>&#8220;A Graph Database —manages a&#8594; Graph and —also manages related&#8594; Indexes&#8221;</simpara>
</blockquote>
<simpara>Neo4j is a commercially supported open-source graph database.
It was designed and built from the ground-up to be a reliable database, optimized for graph structures instead of tables.
Working with Neo4j, your application gets all the expressiveness of a graph, with all the dependability you expect out of a database.</simpara>
<informalfigure>
<ulink url="images/graphdb-overview.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-overview.svg" width="75%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>graphdb-overview.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
</section>
</section>
<section id="tutorial-comparing-models">
<title>Comparing Database Models</title>
<simpara>A Graph Database stores data structured in the Nodes and Relationships of a graph.
How does this compare to other persistence models?
Because a graph is a generic structure, let&#8217;s compare how a few models would look in a graph.</simpara>
<section id="_a_graph_database_transforms_a_rdbms">
<title>A Graph Database transforms a RDBMS</title>
<simpara>Topple the stacks of records in a relational database while keeping all the relationships, and you&#8217;ll see a graph.
Where an RDBMS is optimized for aggregated data, Neo4j is optimized for highly connected data.</simpara>
<figure><title>RDBMS</title>
<ulink url="images/graphdb-compare-rdbms.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-compare-rdbms.svg" width="40%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>graphdb-compare-rdbms.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<figure><title>Graph Database as RDBMS</title>
<ulink url="images/graphdb-compare-rdbms-g.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-compare-rdbms-g.svg" width="100%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>graphdb-compare-rdbms-g.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
<section id="_a_graph_database_elaborates_a_key_value_store">
<title>A Graph Database elaborates a Key-Value Store</title>
<simpara>A Key-Value model is great for lookups of simple values or lists.
When the values are themselves interconnected, you&#8217;ve got a graph.
Neo4j lets you elaborate the simple data structures into more complex, interconnected data.</simpara>
<figure><title>Key-Value Store</title>
<ulink url="images/graphdb-compare-kvstore.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-compare-kvstore.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-compare-kvstore.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><literal>K*</literal> represents a key, <literal>V*</literal> a value.
Note that some keys point to other keys as well as plain values.</simpara>
<figure><title>Graph Database as Key-Value Store</title>
<ulink url="images/graphdb-compare-kvstore-g.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-compare-kvstore-g.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-compare-kvstore-g.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
<section id="_a_graph_database_relates_column_family">
<title>A Graph Database relates Column-Family</title>
<simpara>Column Family (BigTable-style) databases are an evolution of key-value,  using "families" to allow grouping of rows.
Stored in a graph, the families could become hierarchical, and the relationships among data becomes explicit.</simpara>
</section>
<section id="_a_graph_database_navigates_a_document_store">
<title>A Graph Database navigates a Document Store</title>
<simpara>The container hierarchy of a document database accommodates nice, schema-free data that can easily be represented as a tree.
Which is of course a graph.
Refer to other documents (or document elements) within that tree and you have a more expressive representation of the same data.
When in Neo4j, those relationships are easily navigable.</simpara>
<figure><title>Document Store</title>
<ulink url="images/graphdb-compare-docdb.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-compare-docdb.svg" width="75%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>graphdb-compare-docdb.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><literal>D</literal>=Document, <literal>S</literal>=Subdocument, <literal>V</literal>=Value, <literal>D2/S2</literal> = reference to subdocument in (other) document.</simpara>
<figure><title>Graph Database as Document Store</title>
<ulink url="images/graphdb-compare-docdb-g.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-compare-docdb-g.svg" width="75%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>graphdb-compare-docdb-g.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
</section>
</chapter>
<chapter id="graphdb-neo4j">
<title>The Neo4j Graph Database</title>
<simpara>This chapter goes into more detail on the data model and behavior of Neo4j.</simpara>
<section id="graphdb-neo4j-nodes">
<title>Nodes</title>
<simpara>The fundamental units that form a graph are nodes and relationships.
In Neo4j, both nodes and relationships can contain <link linkend="graphdb-neo4j-properties">properties</link>.</simpara>
<simpara>Nodes are often used to represent <emphasis>entities,</emphasis> but depending on the domain relationships may be used for that purpose as well.</simpara>
<simpara>Apart from properties and relationships, nodes can also be <link linkend="graphdb-neo4j-labels">labeled</link> with zero or more labels.</simpara>
<informalfigure>
<ulink url="images/graphdb-nodes-overview.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-nodes-overview.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-nodes-overview.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>Let&#8217;s start out with a really simple graph, containing only a single node with one property:</simpara>
<informalfigure>
<ulink url="images/graphdb-nodes.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-nodes.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-nodes.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
</section>
<section id="graphdb-neo4j-relationships">
<title>Relationships</title>
<simpara>Relationships between nodes are a key part of a graph database.
They allow for finding related data.
Just like nodes, relationships can have <link linkend="graphdb-neo4j-properties">properties</link>.</simpara>
<informalfigure>
<ulink url="images/graphdb-rels-overview.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-rels-overview.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-rels-overview.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>A relationship connects two nodes, and is guaranteed to have valid start and end nodes.</simpara>
<informalfigure>
<ulink url="images/graphdb-rels.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-rels.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-rels.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>As relationships are always directed, they can be viewed as outgoing or incoming relative to a node, which is useful when traversing the graph:</simpara>
<informalfigure>
<ulink url="images/graphdb-rels-dir.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-rels-dir.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-rels-dir.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara><emphasis>Relationships are equally well traversed in either direction.</emphasis>
This means that there is no need to add duplicate relationships in the opposite direction (with regard to traversal or performance).</simpara>
<simpara>While relationships always have a direction, you can ignore the direction where it is not useful in your application.</simpara>
<simpara>Note that a node can have relationships to itself as well:</simpara>
<informalfigure>
<ulink url="images/graphdb-rels-loop.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-rels-loop.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-rels-loop.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>To further enhance graph traversal all relationships have a relationship type.
Note that the word <emphasis>type</emphasis> might be misleading here, you could rather think of it as a <emphasis>label</emphasis>.
The following example shows a simple social network with two relationship types.</simpara>
<informalfigure>
<ulink url="images/graphdb-rels-twitter.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-rels-twitter.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-rels-twitter.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>Using relationship direction and type</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"> What </entry>
<entry align="left" valign="top"> How</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>get who a person follows</simpara></entry>
<entry align="left" valign="top"><simpara>outgoing <literal>follows</literal> relationships, depth one</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>get the followers of a person</simpara></entry>
<entry align="left" valign="top"><simpara>incoming <literal>follows</literal> relationships, depth one</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>get who a person blocks</simpara></entry>
<entry align="left" valign="top"><simpara>outgoing <literal>blocks</literal> relationships, depth one</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>get who a person is blocked by</simpara></entry>
<entry align="left" valign="top"><simpara>incoming <literal>blocks</literal> relationships, depth one</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="graphdb-neo4j-properties">
<title>Properties</title>
<simpara>Both nodes and relationships can have properties.</simpara>
<simpara>Properties are key-value pairs where the key is a string.
Property values can be either a primitive or an array of one primitive type.
For example <literal>String</literal>, <literal>int</literal> and <literal>int[]</literal> values are valid for properties.</simpara>
<note><simpara><literal>NULL</literal> is not a valid property value.
<literal>NULL</literal>s can instead be modeled by the absence of a key.</simpara></note>
<informalfigure>
<ulink url="images/graphdb-properties.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-properties.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-properties.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<table id="property-value-types"
frame="none"
rowsep="1" colsep="1"
>
<title>Property value types</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="15*"/>
<colspec colname="col_2" colwidth="45*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Type </entry>
<entry align="left" valign="top"> Description </entry>
<entry align="left" valign="top"> Value range</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>boolean</literal></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>byte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>8-bit integer</simpara></entry>
<entry align="left" valign="top"><simpara><literal>-128</literal> to <literal>127</literal>, inclusive</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>short</literal></simpara></entry>
<entry align="left" valign="top"><simpara>16-bit integer</simpara></entry>
<entry align="left" valign="top"><simpara><literal>-32768</literal> to <literal>32767</literal>, inclusive</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>int</literal></simpara></entry>
<entry align="left" valign="top"><simpara>32-bit integer</simpara></entry>
<entry align="left" valign="top"><simpara><literal>-2147483648</literal> to <literal>2147483647</literal>, inclusive</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>64-bit integer</simpara></entry>
<entry align="left" valign="top"><simpara><literal>-9223372036854775808</literal> to <literal>9223372036854775807</literal>, inclusive</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>float</literal></simpara></entry>
<entry align="left" valign="top"><simpara>32-bit IEEE 754 floating-point number</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>double</literal></simpara></entry>
<entry align="left" valign="top"><simpara>64-bit IEEE 754 floating-point number</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>char</literal></simpara></entry>
<entry align="left" valign="top"><simpara>16-bit unsigned integers representing Unicode characters</simpara></entry>
<entry align="left" valign="top"><simpara><literal>u0000</literal> to <literal>uffff</literal> (<literal>0</literal> to <literal>65535</literal>)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>sequence of Unicode characters</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>For further details on float/double values, see <ulink url="http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.2.3">Java Language Specification</ulink>.</simpara>
</section>
<section id="graphdb-neo4j-labels">
<title>Labels</title>
<simpara>A label is a named graph construct that is used to group nodes into sets; all nodes labeled with the same label belongs to the same set.
Many database queries can work with these sets instead of the whole graph, making queries easier to write and more efficient.
A node may be labeled with any number of labels, including none, making labels an optional addition to the graph.</simpara>
<informalfigure>
<ulink url="images/graphdb-labels.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-labels.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-labels.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>Labels are used when defining contraints and adding indexes for properties.</simpara>
<simpara>An example would be a label named <literal>User</literal> that you label all your nodes representing users with.
With that in place, you can ask Neo4j to perform operations only on your user nodes, such as finding all users with a given name.</simpara>
<simpara>However, you can use labels for much more.
For instance, since labels can be added and removed during runtime, they can be used to mark temporary states for your nodes.
You might create an <literal>Offline</literal> label for phones that are offline, a <literal>Happy</literal> label for happy pets, and so on.</simpara>
<section id="_label_names">
<title>Label names</title>
<simpara>Any non-empty unicode string can be used as a label name.
In Cypher, you may need to use the backtick (<literal>`</literal>) syntax to avoid clashes with Cypher identifier rules.
By convention, labels are written with CamelCase notation, with the first letter in upper case.
For instance, <literal>User</literal> or <literal>CarOwner</literal>.</simpara>
<simpara>Labels have an id space of an int, meaning the maximum number of labels the database can contain is roughly 2 billion.</simpara>
</section>
</section>
<section id="graphdb-neo4j-paths">
<title>Paths</title>
<simpara>A path is one or more nodes with connecting relationships, typically retrieved as a query or traversal result.</simpara>
<informalfigure>
<ulink url="images/graphdb-path.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-path.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-path.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>The shortest possible path has length zero and looks like this:</simpara>
<informalfigure>
<ulink url="images/graphdb-path-example1.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-path-example1.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-path-example1.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>A path of length one:</simpara>
<informalfigure>
<ulink url="images/graphdb-path-example2.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-path-example2.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-path-example2.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>Another path of length one:</simpara>
<informalfigure>
<ulink url="images/graphdb-path-example-loop.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-path-example-loop.svg"/>
  </imageobject>
  <textobject><phrase>graphdb-path-example-loop.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
</section>
<section id="graphdb-neo4j-traversal">
<title>Traversal</title>
<simpara>Traversing a graph means visiting its nodes, following relationships according to some rules.
In most cases only a subgraph is visited, as you already know where in the graph the interesting nodes and relationships are found.</simpara>
<simpara>Cypher provides a declarative way to query the graph powered by traversals and other techniques.
See <xref linkend="cypher-query-lang"/> for more information.</simpara>
<simpara>Neo4j comes with a callback based traversal API which lets you specify the traversal rules.
At a basic level there&#8217;s a choice between traversing breadth- or depth-first.</simpara>
<simpara>For an in-depth introduction to the traversal framework, see <xref linkend="tutorial-traversal"/>.
For Java code examples see <xref linkend="tutorials-java-embedded-traversal"/>.</simpara>
</section>
<section id="graphdb-neo4j-schema">
<title>Schema</title>
<simpara>Neo4j is a schema-optional graph database. You can use Neo4j without any schema.  Optionally you can introduce it in
order to gain performance or modeling benefits. This allows a way of working where the schema does not get in your way
until you are at a stage where you want to reap the benefits of having one.</simpara>
<section id="graphdb-neo4j-schema-indexes">
<title>Indexes</title>
<note><simpara>This feature was introduced in Neo4j 2.0, and is not the same as the legacy indexes (see <xref linkend="indexing"/>).</simpara></note>
<simpara>Performance is gained by creating indexes, which improve the speed of looking up nodes in the database.
Once you’ve specified which properties to index, Neo4j will make sure your indexes are kept up to date as your graph evolves.
Any operation that looks up nodes by the newly indexed properties will see a significant performance boost.</simpara>
<simpara>Indexes in Neo4j are <emphasis>eventually available</emphasis>. That means that when you first create an index, the operation returns immediately.
The index is <emphasis role="strong">populating</emphasis> in the background and so is not immediately available for querying.
When the index has been fully populated it will eventually come <emphasis role="strong">online</emphasis>. That means that it is now ready to be used in
queries.</simpara>
<simpara>If something should go wrong with the index, it can end up in a <emphasis role="strong">failed</emphasis> state. When it is failed, it will not be used
to speed up queries. To rebuild it, you can drop and recreate the index. Look at logs for clues about the failure.</simpara>
<simpara>You can track the status of your index by asking for the index state through the API you are using.
Note, however, that this is not yet possible through Cypher.</simpara>
<simpara>How to use indexes in the different APIs:</simpara>
<itemizedlist>
<listitem>
<simpara>
Cypher: <xref linkend="query-schema-index"/>
</simpara>
</listitem>
<listitem>
<simpara>
REST API: <xref linkend="rest-api-schema-indexes"/>
</simpara>
</listitem>
<listitem>
<simpara>
Listing Indexes via Shell: <xref linkend="shell-listing-indexes-and-constraints"/>
</simpara>
</listitem>
<listitem>
<simpara>
Java Core API: <xref linkend="tutorials-java-embedded-new-index"/>
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="graphdb-neo4j-schema-constraints">
<title>Constraints</title>
<note><simpara>This feature was introduced in Neo4j 2.0.</simpara></note>
<simpara>Neo4j can help you keep your data clean. It does so using constraints, that allow you to specify the rules for what
your data should look like. Any changes that break these rules will be denied.</simpara>
<simpara>In this version, unique constraints is the only available constraint type.</simpara>
<simpara>How to use constraints in the different APIs:</simpara>
<itemizedlist>
<listitem>
<simpara>
Cypher: <xref linkend="query-constraints"/>
</simpara>
</listitem>
<listitem>
<simpara>
REST API: <xref linkend="rest-api-schema-constraints"/>
</simpara>
</listitem>
<listitem>
<simpara>
Listing Constraints via Shell: <xref linkend="shell-listing-indexes-and-constraints"/>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
</part>
<part id="tutorials">
<title>Tutorials</title>
<partintro>
<simpara>The tutorial part describes how use Neo4j.
It takes you from Hello World to advanced usage of graphs.</simpara>
</partintro>
<chapter id="tutorials-cypher">
<title>Getting started with Cypher</title>
<simpara>This chapter will guide you through your first steps with <link linkend="cypher-query-lang">Cypher</link>.</simpara>
<simpara>In the online edition of this manual, all queries in this section can be executed interactively without installing Neo4j on your computer.</simpara>
<simpara>Otherwise, first get the Neo4j server running to try things out locally.
Instructions are found in <xref linkend="server-installation"/>.
With the server running, you can choose to issue Cypher queries from either the web interface or the Neo4j shell.
See <xref linkend="tools-webadmin"/> or <xref linkend="shell"/>.</simpara>
<section id="cypherdoc-create-nodes-and-relationships">
<title>Create nodes and relationships</title>
<simpara role="cypherdoc-console"></simpara>
<simpara>Create a node for the actor Tom Hanks:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (n:Actor { name:"Tom Hanks" });</programlisting>
<simpara>Let&#8217;s find the node we created:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor { name: "Tom Hanks" })
RETURN actor;</programlisting>
<simpara>Now let&#8217;s create a movie and connect it to the Tom Hanks node with an <literal>ACTED_IN</literal> relationship:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor)
WHERE actor.name = "Tom Hanks"
CREATE (movie:Movie { title:'Sleepless IN Seattle' })
CREATE (actor)-[:ACTED_IN]-&gt;(movie);</programlisting>
<simpara>Using a <literal>WHERE</literal> clause in the query above to get the Tom Hanks node does the same thing as the pattern in the <literal>MATCH</literal> clause of the previous query.</simpara>
<simpara>This is how our graph looks now:</simpara>
<informalfigure>
<ulink url="images/cypherdoc-created-first-movie-e8e6e816.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypherdoc-created-first-movie-e8e6e816.svg"/>
  </imageobject>
  <textobject><phrase>cypherdoc-created-first-movie-e8e6e816.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>We can do more of the work in a single clause.
<literal>CREATE UNIQUE</literal> will make sure we don&#8217;t create duplicate patterns.
Using this: <literal>[r:ACTED_IN]</literal> lets us return the relationship.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor { name: "Tom Hanks" })
CREATE UNIQUE (actor)-[r:ACTED_IN]-&gt;(movie:Movie { title:"Forrest Gump" })
RETURN r;</programlisting>
<simpara>Set a property on a node:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor { name: "Tom Hanks" })
SET actor.DoB = 1944
RETURN actor.name, actor.DoB;</programlisting>
<simpara>The labels <emphasis>Actor</emphasis> and <emphasis>Movie</emphasis> help us organize the graph.
Let&#8217;s list all <emphasis>Movie</emphasis> nodes:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (movie:Movie)
RETURN movie AS `All Movies`;</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">All Movies</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{title:"Sleepless in Seattle"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[2]{title:"Forrest Gump"}</literal></simpara></entry></row></tbody></tgroup></informaltable>
</section>
<section id="cypherdoc-movie-database">
<title>Movie Database</title>
<simpara>Our example graph consists of movies with title and year and actors with a name.
Actors have <literal>ACTS_IN</literal> relationships to movies, which represents the role they played.
This relationship also has a role attribute.</simpara>
<simpara>We&#8217;ll go with three movies and three actors:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (matrix1:Movie { title : 'The Matrix', year : '1999-03-31' })
CREATE (matrix2:Movie { title : 'The Matrix Reloaded', year : '2003-05-07' })
CREATE (matrix3:Movie { title : 'The Matrix Revolutions', year : '2003-10-27' })
CREATE (keanu:Actor { name:'Keanu Reeves' })
CREATE (laurence:Actor { name:'Laurence Fishburne' })
CREATE (carrieanne:Actor { name:'Carrie-Anne Moss' })
CREATE (keanu)-[:ACTS_IN { role : 'Neo' }]-&gt;(matrix1)
CREATE (keanu)-[:ACTS_IN { role : 'Neo' }]-&gt;(matrix2)
CREATE (keanu)-[:ACTS_IN { role : 'Neo' }]-&gt;(matrix3)
CREATE (laurence)-[:ACTS_IN { role : 'Morpheus' }]-&gt;(matrix1)
CREATE (laurence)-[:ACTS_IN { role : 'Morpheus' }]-&gt;(matrix2)
CREATE (laurence)-[:ACTS_IN { role : 'Morpheus' }]-&gt;(matrix3)
CREATE (carrieanne)-[:ACTS_IN { role : 'Trinity' }]-&gt;(matrix1)
CREATE (carrieanne)-[:ACTS_IN { role : 'Trinity' }]-&gt;(matrix2)
CREATE (carrieanne)-[:ACTS_IN { role : 'Trinity' }]-&gt;(matrix3)</programlisting>
<simpara>This gives us the following graph to play with:</simpara>
<informalfigure>
<ulink url="images/cypherdoc--3b7c1848.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypherdoc--3b7c1848.svg"/>
  </imageobject>
  <textobject><phrase>cypherdoc--3b7c1848.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara role="cypherdoc-console"></simpara>
<simpara>Let&#8217;s check how many nodes we have now:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
RETURN "Hello Graph with " + count(*)+ " Nodes!" AS welcome;</programlisting>
<simpara>Return a single node, by name:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (movie:Movie { title: 'The Matrix' })
RETURN movie;</programlisting>
<simpara>Return the title and date of the matrix node:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (movie:Movie { title: 'The Matrix' })
RETURN movie.title, movie.year;</programlisting>
<simpara>Which results in:</simpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">movie.title</entry><entry align="left" valign="top">movie.year</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"The Matrix"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"1999-03-31"</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Show all actors:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor)
RETURN actor;</programlisting>
<simpara>Return just the name, and order them by name:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor)
RETURN actor.name
ORDER BY actor.name;</programlisting>
<simpara>Count the actors:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor)
RETURN count(*);</programlisting>
<simpara>Get only the actors whose names end with &#8220;s&#8221;:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor)
WHERE actor.name =~ ".*s$"
RETURN actor.name;</programlisting>
<simpara>Here&#8217;s some exploratory queries for unknown datasets.
<emphasis>Don&#8217;t do this on live production databases!</emphasis></simpara>
<simpara>Count nodes:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
RETURN count(*);</programlisting>
<simpara>Count relationship types:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)-[r]-&gt;()
RETURN type(r), count(*);</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">type(r)</entry><entry align="left" valign="top">count(*)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"ACTS_IN"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>9</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>List all nodes and their relationships:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)-[r]-&gt;(m)
RETURN n AS from, r AS `-&gt;`, m AS to;</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="3"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><thead><row><entry align="left" valign="top">from</entry><entry align="left" valign="top">-&gt;</entry><entry align="left" valign="top">to</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col3">9 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"Keanu Reeves"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>:ACTS_IN[0]{role:"Neo"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[0]{title:"The Matrix",year:"1999-03-31"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"Keanu Reeves"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>:ACTS_IN[1]{role:"Neo"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[1]{title:"The Matrix Reloaded",year:"2003-05-07"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"Keanu Reeves"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>:ACTS_IN[2]{role:"Neo"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[2]{title:"The Matrix Revolutions",year:"2003-10-27"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[4]{name:"Laurence Fishburne"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>:ACTS_IN[3]{role:"Morpheus"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[0]{title:"The Matrix",year:"1999-03-31"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[4]{name:"Laurence Fishburne"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>:ACTS_IN[4]{role:"Morpheus"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[1]{title:"The Matrix Reloaded",year:"2003-05-07"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[4]{name:"Laurence Fishburne"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>:ACTS_IN[5]{role:"Morpheus"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[2]{title:"The Matrix Revolutions",year:"2003-10-27"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[5]{name:"Carrie-Anne Moss"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>:ACTS_IN[6]{role:"Trinity"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[0]{title:"The Matrix",year:"1999-03-31"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[5]{name:"Carrie-Anne Moss"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>:ACTS_IN[7]{role:"Trinity"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[1]{title:"The Matrix Reloaded",year:"2003-05-07"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[5]{name:"Carrie-Anne Moss"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>:ACTS_IN[8]{role:"Trinity"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[2]{title:"The Matrix Revolutions",year:"2003-10-27"}</literal></simpara></entry></row></tbody></tgroup></informaltable>
</section>
<section id="cypherdoc-social-movie-database">
<title>Social Movie Database</title>
<simpara>Our example graph consists of movies with title and year and actors with a name.
Actors have <literal>ACTS_IN</literal> relationships to movies, which represents the role they played.
This relationship also has a role attribute.</simpara>
<simpara>So far, we queried the movie data; now let&#8217;s <emphasis>update the graph</emphasis> too.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (matrix1:Movie { title : 'The Matrix', year : '1999-03-31' })
CREATE (matrix2:Movie { title : 'The Matrix Reloaded', year : '2003-05-07' })
CREATE (matrix3:Movie { title : 'The Matrix Revolutions', year : '2003-10-27' })
CREATE (keanu:Actor { name:'Keanu Reeves' })
CREATE (laurence:Actor { name:'Laurence Fishburne' })
CREATE (carrieanne:Actor { name:'Carrie-Anne Moss' })
CREATE (keanu)-[:ACTS_IN { role : 'Neo' }]-&gt;(matrix1)
CREATE (keanu)-[:ACTS_IN { role : 'Neo' }]-&gt;(matrix2)
CREATE (keanu)-[:ACTS_IN { role : 'Neo' }]-&gt;(matrix3)
CREATE (laurence)-[:ACTS_IN { role : 'Morpheus' }]-&gt;(matrix1)
CREATE (laurence)-[:ACTS_IN { role : 'Morpheus' }]-&gt;(matrix2)
CREATE (laurence)-[:ACTS_IN { role : 'Morpheus' }]-&gt;(matrix3)
CREATE (carrieanne)-[:ACTS_IN { role : 'Trinity' }]-&gt;(matrix1)
CREATE (carrieanne)-[:ACTS_IN { role : 'Trinity' }]-&gt;(matrix2)
CREATE (carrieanne)-[:ACTS_IN { role : 'Trinity' }]-&gt;(matrix3)</programlisting>
<simpara role="cypherdoc-console"></simpara>
<simpara>We will add ourselves, friends and movie ratings.</simpara>
<simpara>Here&#8217;s how to add a node for yourself and return it, let&#8217;s say your name is &#8220;Me&#8221;:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (me:User { name: "Me" })
RETURN me;</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">me</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[6]{name:"Me"}</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Let&#8217;s check if the node is there:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me:User { name: "Me" })
RETURN me.name;</programlisting>
<simpara>Add a movie rating:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me:User { name: "Me" }),(movie:Movie { title: "The Matrix" })
CREATE (me)-[:RATED { stars : 5, comment : "I love that movie!" }]-&gt;(movie);</programlisting>
<simpara>Which movies did I rate?</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me:User { name: "Me" }),(me)-[rating:RATED]-&gt;(movie)
RETURN movie.title, rating.stars, rating.comment;</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="3"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><thead><row><entry align="left" valign="top">movie.title</entry><entry align="left" valign="top">rating.stars</entry><entry align="left" valign="top">rating.comment</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col3">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"The Matrix"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>5</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"I love that movie!"</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>We need a friend!</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (friend:User { name: "A Friend" })
RETURN friend;</programlisting>
<simpara>Add our friendship idempotently, so we can re-run the query without adding it several times.
We return the relationship to check that it has not been created several times.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me:User { name: "Me" }),(friend:User { name: "A Friend" })
CREATE UNIQUE (me)-[friendship:FRIEND]-&gt;(friend)
RETURN friendship;</programlisting>
<simpara>You can rerun the query, see that it doesn&#8217;t change anything the second time!</simpara>
<simpara>Let&#8217;s update our friendship with a <literal>since</literal> property:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me:User { name: "Me" })-[friendship:FRIEND]-&gt;(friend:User { name: "A Friend" })
SET friendship.since='forever'
RETURN friendship;</programlisting>
<simpara>Let&#8217;s pretend us being our friend and wanting to see which movies our friends have rated.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me:User { name: "A Friend" })-[:FRIEND]-(friend)-[rating:RATED]-&gt;(movie)
RETURN movie.title, avg(rating.stars) AS stars, collect(rating.comment) AS comments, count(*);</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="4"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><colspec colname="col4"/><thead><row><entry align="left" valign="top">movie.title</entry><entry align="left" valign="top">stars</entry><entry align="left" valign="top">comments</entry><entry align="left" valign="top">count(*)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col4">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"The Matrix"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>5.0</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>["I love that movie!"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>That&#8217;s too little data, let&#8217;s add some more friends and friendships.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me:User { name: "Me" })
FOREACH (i IN range(1,10)| CREATE (friend:User { name: "Friend " + i }),(me)-[:FRIEND]-&gt;(friend));</programlisting>
<simpara>Show all our friends:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me:User { name: "Me" })-[r:FRIEND]-&gt;(friend)
RETURN type(r) AS friendship, friend.name;</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">friendship</entry><entry align="left" valign="top">friend.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">11 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"FRIEND"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"A Friend"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"FRIEND"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Friend 1"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"FRIEND"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Friend 2"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"FRIEND"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Friend 3"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"FRIEND"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Friend 4"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"FRIEND"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Friend 5"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"FRIEND"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Friend 6"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"FRIEND"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Friend 7"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"FRIEND"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Friend 8"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"FRIEND"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Friend 9"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"FRIEND"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Friend 10"</literal></simpara></entry></row></tbody></tgroup></informaltable>
</section>
<section id="cypherdoc-finding-paths">
<title>Finding Paths</title>
<simpara>Our example graph consists of movies with title and year and actors with a name.
Actors have <literal>ACTS_IN</literal> relationships to movies, which represents the role they played.
This relationship also has a role attribute.</simpara>
<simpara>We queried and updated the data so far, now let&#8217;s <emphasis>find interesting constellations, a.k.a. paths</emphasis>.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (matrix1:Movie { title : 'The Matrix', year : '1999-03-31' })
CREATE (matrix2:Movie { title : 'The Matrix Reloaded', year : '2003-05-07' })
CREATE (matrix3:Movie { title : 'The Matrix Revolutions', year : '2003-10-27' })
CREATE (keanu:Actor { name:'Keanu Reeves' })
CREATE (laurence:Actor { name:'Laurence Fishburne' })
CREATE (carrieanne:Actor { name:'Carrie-Anne Moss' })
CREATE (keanu)-[:ACTS_IN { role : 'Neo' }]-&gt;(matrix1)
CREATE (keanu)-[:ACTS_IN { role : 'Neo' }]-&gt;(matrix2)
CREATE (keanu)-[:ACTS_IN { role : 'Neo' }]-&gt;(matrix3)
CREATE (laurence)-[:ACTS_IN { role : 'Morpheus' }]-&gt;(matrix1)
CREATE (laurence)-[:ACTS_IN { role : 'Morpheus' }]-&gt;(matrix2)
CREATE (laurence)-[:ACTS_IN { role : 'Morpheus' }]-&gt;(matrix3)
CREATE (carrieanne)-[:ACTS_IN { role : 'Trinity' }]-&gt;(matrix1)
CREATE (carrieanne)-[:ACTS_IN { role : 'Trinity' }]-&gt;(matrix2)
CREATE (carrieanne)-[:ACTS_IN { role : 'Trinity' }]-&gt;(matrix3)</programlisting>
<simpara role="cypherdoc-console"></simpara>
<simpara>All other movies that actors in &#8220;The Matrix&#8221; acted in ordered by occurrence:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (:Movie { title: "The Matrix" })&lt;-[:ACTS_IN]-(actor)-[:ACTS_IN]-&gt;(movie)
RETURN movie.title, count(*)
ORDER BY count(*) DESC ;</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">movie.title</entry><entry align="left" valign="top">count(*)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"The Matrix Revolutions"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"The Matrix Reloaded"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Let&#8217;s see who acted in each of these movies:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (:Movie { title: "The Matrix" })&lt;-[:ACTS_IN]-(actor)-[:ACTS_IN]-&gt;(movie)
RETURN movie.title, collect(actor.name), count(*) AS count
ORDER BY count DESC ;</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="3"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><thead><row><entry align="left" valign="top">movie.title</entry><entry align="left" valign="top">collect(actor.name)</entry><entry align="left" valign="top">count</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col3">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"The Matrix Revolutions"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","Laurence Fishburne","Carrie-Anne Moss"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"The Matrix Reloaded"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","Laurence Fishburne","Carrie-Anne Moss"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>What about co-acting, that is actors that acted together:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (:Movie { title: "The Matrix"
  })&lt;-[:ACTS_IN]-(actor)-[:ACTS_IN]-&gt;(movie)&lt;-[:ACTS_IN]-(colleague)
RETURN actor.name, collect(DISTINCT colleague.name);</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">actor.name</entry><entry align="left" valign="top">collect(distinct colleague.name)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Carrie-Anne Moss"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","Laurence Fishburne"]</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Laurence Fishburne"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","Carrie-Anne Moss"]</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Keanu Reeves"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>["Laurence Fishburne","Carrie-Anne Moss"]</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Who of those other actors acted most often with anyone from the matrix cast?</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (:Movie { title: "The Matrix"
  })&lt;-[:ACTS_IN]-(actor)-[:ACTS_IN]-&gt;(movie)&lt;-[:ACTS_IN]-(colleague)
RETURN colleague.name, count(*)
ORDER BY count(*) DESC LIMIT 10;</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">colleague.name</entry><entry align="left" valign="top">count(*)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Carrie-Anne Moss"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Keanu Reeves"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Laurence Fishburne"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Starting with paths, a path is a sequence of nodes and relationships from a start node to an end node.</simpara>
<simpara>We know that Trinity loves Neo, but how many paths exist between their actors?
We&#8217;ll limit the path length and the query as it exhaustively searches the graph otherwise</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p =(:Actor { name: "Keanu Reeves" })-[:ACTS_IN*0..5]-(:Actor { name: "Carrie-Anne Moss" })
RETURN p, length(p)
LIMIT 10;</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">p</entry><entry align="left" valign="top">length(p)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">9 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[Node[3]{name:"Keanu Reeves"},:ACTS_IN[0]{role:"Neo"},Node[0]{title:"The Matrix",year:"1999-03-31"},:ACTS_IN[3]{role:"Morpheus"},Node[4]{name:"Laurence Fishburne"},:ACTS_IN[4]{role:"Morpheus"},Node[1]{title:"The Matrix Reloaded",year:"2003-05-07"},:ACTS_IN[7]{role:"Trinity"},Node[5]{name:"Carrie-Anne Moss"}]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>[Node[3]{name:"Keanu Reeves"},:ACTS_IN[0]{role:"Neo"},Node[0]{title:"The Matrix",year:"1999-03-31"},:ACTS_IN[3]{role:"Morpheus"},Node[4]{name:"Laurence Fishburne"},:ACTS_IN[5]{role:"Morpheus"},Node[2]{title:"The Matrix Revolutions",year:"2003-10-27"},:ACTS_IN[8]{role:"Trinity"},Node[5]{name:"Carrie-Anne Moss"}]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>[Node[3]{name:"Keanu Reeves"},:ACTS_IN[0]{role:"Neo"},Node[0]{title:"The Matrix",year:"1999-03-31"},:ACTS_IN[6]{role:"Trinity"},Node[5]{name:"Carrie-Anne Moss"}]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>[Node[3]{name:"Keanu Reeves"},:ACTS_IN[1]{role:"Neo"},Node[1]{title:"The Matrix Reloaded",year:"2003-05-07"},:ACTS_IN[4]{role:"Morpheus"},Node[4]{name:"Laurence Fishburne"},:ACTS_IN[3]{role:"Morpheus"},Node[0]{title:"The Matrix",year:"1999-03-31"},:ACTS_IN[6]{role:"Trinity"},Node[5]{name:"Carrie-Anne Moss"}]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>[Node[3]{name:"Keanu Reeves"},:ACTS_IN[1]{role:"Neo"},Node[1]{title:"The Matrix Reloaded",year:"2003-05-07"},:ACTS_IN[4]{role:"Morpheus"},Node[4]{name:"Laurence Fishburne"},:ACTS_IN[5]{role:"Morpheus"},Node[2]{title:"The Matrix Revolutions",year:"2003-10-27"},:ACTS_IN[8]{role:"Trinity"},Node[5]{name:"Carrie-Anne Moss"}]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>[Node[3]{name:"Keanu Reeves"},:ACTS_IN[1]{role:"Neo"},Node[1]{title:"The Matrix Reloaded",year:"2003-05-07"},:ACTS_IN[7]{role:"Trinity"},Node[5]{name:"Carrie-Anne Moss"}]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>[Node[3]{name:"Keanu Reeves"},:ACTS_IN[2]{role:"Neo"},Node[2]{title:"The Matrix Revolutions",year:"2003-10-27"},:ACTS_IN[5]{role:"Morpheus"},Node[4]{name:"Laurence Fishburne"},:ACTS_IN[3]{role:"Morpheus"},Node[0]{title:"The Matrix",year:"1999-03-31"},:ACTS_IN[6]{role:"Trinity"},Node[5]{name:"Carrie-Anne Moss"}]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>[Node[3]{name:"Keanu Reeves"},:ACTS_IN[2]{role:"Neo"},Node[2]{title:"The Matrix Revolutions",year:"2003-10-27"},:ACTS_IN[5]{role:"Morpheus"},Node[4]{name:"Laurence Fishburne"},:ACTS_IN[4]{role:"Morpheus"},Node[1]{title:"The Matrix Reloaded",year:"2003-05-07"},:ACTS_IN[7]{role:"Trinity"},Node[5]{name:"Carrie-Anne Moss"}]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>[Node[3]{name:"Keanu Reeves"},:ACTS_IN[2]{role:"Neo"},Node[2]{title:"The Matrix Revolutions",year:"2003-10-27"},:ACTS_IN[8]{role:"Trinity"},Node[5]{name:"Carrie-Anne Moss"}]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Bur that&#8217;s a lot of data, we just want to look at the names and titles of the nodes of the path.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p =(:Actor { name: "Keanu Reeves" })-[:ACTS_IN*0..5]-(:Actor { name: "Carrie-Anne Moss" })
RETURN extract(n IN nodes(p)| coalesce(n.title,n.name)) AS `names AND titles`, length(p)
ORDER BY length(p)
LIMIT 10;</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">names and titles</entry><entry align="left" valign="top">length(p)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">9 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","The Matrix","Carrie-Anne Moss"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","The Matrix Reloaded","Carrie-Anne Moss"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","The Matrix Revolutions","Carrie-Anne Moss"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","The Matrix","Laurence Fishburne","The Matrix Reloaded","Carrie-Anne Moss"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","The Matrix","Laurence Fishburne","The Matrix Revolutions","Carrie-Anne Moss"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","The Matrix Reloaded","Laurence Fishburne","The Matrix","Carrie-Anne Moss"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","The Matrix Reloaded","Laurence Fishburne","The Matrix Revolutions","Carrie-Anne Moss"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","The Matrix Revolutions","Laurence Fishburne","The Matrix","Carrie-Anne Moss"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>["Keanu Reeves","The Matrix Revolutions","Laurence Fishburne","The Matrix Reloaded","Carrie-Anne Moss"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row></tbody></tgroup></informaltable>
</section>
<section id="cypherdoc-labels" xreflabel="-constraints-and-indexes">
<title>Labels, Constraints and Indexes</title>
<simpara>Labels are a convenient way to group nodes together.
They are used to restrict queries, define constraints and create indexes.</simpara>
<simpara>The following will give an example of how to use labels.
Let&#8217;s start out adding a constraint&#8201;&#8212;&#8201;in this case we decided that all <literal>Movie</literal> node <literal>title</literal>s should be unique.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE</programlisting>
<simpara role="cypherdoc-console"></simpara>
<simpara>Note that adding the unique constraint will add an index on that property, so we won&#8217;t do that separately.
If we drop the constraint, we will have to add an index instead, as needed.</simpara>
<simpara>In this case we want an index to speed up finding actors by name in the database:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE INDEX ON :Actor(name)</programlisting>
<simpara>Indexes can be added at any time.
Constraints can be added after a label is already in use, but that requires that the existing data complies with the constraints.
Note that it will take some time for an index to come online when there&#8217;s existing data.</simpara>
<simpara>Now, let&#8217;s add some data.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (actor:Actor { name:"Tom Hanks" }),(movie:Movie { title:'Sleepless IN Seattle' }),
  (actor)-[:ACTED_IN]-&gt;(movie);</programlisting>
<simpara>Normally you don&#8217;t specify indexes when querying for data.
They will be used automatically.
This means we can simply look up the Tom Hanks node, and the index will kick in behind the scenes to boost performance.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor { name: "Tom Hanks" })
RETURN actor;</programlisting>
<simpara>Now let&#8217;s say we want to add another label for a node.
Here&#8217;s how to do that:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor { name: "Tom Hanks" })
SET actor :American;</programlisting>
<simpara>To remove a label from nodes, this is what to do:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor { name: "Tom Hanks" })
REMOVE actor:American;</programlisting>
<simpara>For more information on labels and related topics, see:</simpara>
<itemizedlist>
<listitem>
<simpara>
<xref linkend="graphdb-neo4j-labels"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="cypher-schema"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="query-constraints"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="query-schema-index"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="query-using"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="query-set"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="query-remove"/>
</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter id="data-modeling-examples">
<title>Data Modeling Examples</title>
<simpara>The following chapters contain simplified examples of how different domains can be modeled using Neo4j.
The aim is not to give full examples, but to suggest possible ways to think using nodes, relationships, graph patterns and data locality in traversals.</simpara>
<simpara>The examples use Cypher queries a lot, read <xref linkend="cypher-query-lang"/> for more information.</simpara>
<section id="cypherdoc-linked-lists">
<title>Linked Lists</title>
<simpara>A powerful feature of using a graph database, is that you can create your own in-graph data structures&#8201;&#8212;&#8201;for example a linked list.</simpara>
<simpara>This data structure uses a single node as the list reference.
The reference has an outgoing relationship to the head of the list, and an incoming relationship from the last element of the list.
If the list is empty, the reference will point to itself.</simpara>
<simpara>To make it clear what happens, we will show how the graph looks after each query.</simpara>
<simpara>To initialize an empty linked list, we simply create a node, and make it link to itself.
Unlike the actual list elements, it doesn&#8217;t have a <literal>value</literal> property.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (root { name: 'ROOT' })-[:LINK]-&gt;(root)
RETURN root</programlisting>
<informalfigure>
<ulink url="images/cypherdoc--cf38d218.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypherdoc--cf38d218.svg"/>
  </imageobject>
  <textobject><phrase>cypherdoc--cf38d218.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>Adding values is done by finding the relationship where the new value should be placed in, and replacing it with
a new node, and two relationships to it.
We also have to handle the fact that the <literal>before</literal> and <literal>after</literal> nodes could be the same as the <literal>root</literal> node.
The case where <literal>before</literal>, <literal>after</literal> and the <literal>root</literal> node are all the same, makes it necessary to use <literal>CREATE UNIQUE</literal> to not create two new value nodes by mistake.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (root)-[:LINK*0..]-&gt;(before),(after)-[:LINK*0..]-&gt;(root),(before)-[old:LINK]-&gt;(after)
WHERE root.name = 'ROOT' AND (before.value &lt; 25 OR before = root) AND (25 &lt; after.value OR after =
  root)
CREATE UNIQUE (before)-[:LINK]-&gt;({ value:25 })-[:LINK]-&gt;(after)
DELETE old</programlisting>
<informalfigure>
<ulink url="images/cypherdoc--89a53f24.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypherdoc--89a53f24.svg"/>
  </imageobject>
  <textobject><phrase>cypherdoc--89a53f24.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>Let&#8217;s add one more value:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (root)-[:LINK*0..]-&gt;(before),(after)-[:LINK*0..]-&gt;(root),(before)-[old:LINK]-&gt;(after)
WHERE root.name = 'ROOT' AND (before.value &lt; 10 OR before = root) AND (10 &lt; after.value OR after =
  root)
CREATE UNIQUE (before)-[:LINK]-&gt;({ value:10 })-[:LINK]-&gt;(after)
DELETE old</programlisting>
<informalfigure>
<ulink url="images/cypherdoc--d546bacf.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypherdoc--d546bacf.svg"/>
  </imageobject>
  <textobject><phrase>cypherdoc--d546bacf.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>Deleting a value, conversely, is done by finding the node with the value, and the two relationships going in and out
from it, and replacing the relationships with a new one.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (root)-[:LINK*0..]-&gt;(before),(before)-[delBefore:LINK]-&gt;(del)-[delAfter:LINK]-&gt;(after),
  (after)-[:LINK*0..]-&gt;(root)
WHERE root.name = 'ROOT' AND del.value = 10
CREATE UNIQUE (before)-[:LINK]-&gt;(after)
DELETE del, delBefore, delAfter</programlisting>
<informalfigure>
<ulink url="images/cypherdoc--89a53f24.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypherdoc--89a53f24.svg"/>
  </imageobject>
  <textobject><phrase>cypherdoc--89a53f24.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>Deleting the last value node is what requires us to use <literal>CREATE UNIQUE</literal> when replacing the relationships.
Otherwise, we would end up with two relationships from the <literal>root</literal> node to itself, as both <literal>before</literal> and <literal>after</literal> nodes are equal to the <literal>root</literal> node, meaning the pattern would match twice.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (root)-[:LINK*0..]-&gt;(before),(before)-[delBefore:LINK]-&gt;(del)-[delAfter:LINK]-&gt;(after),
  (after)-[:LINK*0..]-&gt;(root)
WHERE root.name = 'ROOT' AND del.value = 25
CREATE UNIQUE (before)-[:LINK]-&gt;(after)
DELETE del, delBefore, delAfter</programlisting>
<informalfigure>
<ulink url="images/cypherdoc--cf38d218.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypherdoc--cf38d218.svg"/>
  </imageobject>
  <textobject><phrase>cypherdoc--cf38d218.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara role="cypherdoc-console"></simpara>
</section>
<section id="cypherdoc-tv-shows">
<title>TV Shows</title>
<simpara>This example show how TV Shows with Seasons, Episodes, Characters, Actors, Users and Reviews can be modeled in a graph database.</simpara>
<section id="_data_model">
<title>Data Model</title>
<simpara>Let&#8217;s start out with an entity-relationship model of the domain at hand:</simpara>
<informalfigure>
<ulink url="images/modeling-tvshow-er-diagram.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/modeling-tvshow-er-diagram.svg"/>
  </imageobject>
  <textobject><phrase>modeling-tvshow-er-diagram.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>To implement this in Neo4j we&#8217;ll use the following relationship types:</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<?dbhtml table-width="75%"?>
<?dbfo table-width="75%"?>
<?dblatex table-width="75%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="106*"/>
<colspec colname="col_2" colwidth="212*"/>
<thead>
<row>
<entry align="left" valign="top"> Relationship Type </entry>
<entry align="left" valign="top"> Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>HAS_SEASON</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Connects a show with its seasons.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HAS_EPISODE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Connects a season with its episodes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FEATURED_CHARACTER</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Connects an episode with its characters.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PLAYED_CHARACTER</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Connects actors with characters.
                     Note that an actor can play multiple characters in an episode,
                     and that the same character can be played by multiple actors as well.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HAS_REVIEW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Connects an episode with its reviews.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>WROTE_REVIEW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Connects users with reviews they contributed.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_sample_data">
<title>Sample Data</title>
<simpara>Let&#8217;s create some data and see how the domain plays out in practice:</simpara>
<simpara role="cypherdoc-console"></simpara>
<simpara role="setup-query"></simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (himym:TVShow { name: "How I Met Your Mother" })
CREATE (himym_s1:Season { name: "HIMYM Season 1" })
CREATE (himym_s1_e1:Episode { name: "Pilot" })
CREATE (ted:Character { name: "Ted Mosby" })
CREATE (joshRadnor:Actor { name: "Josh Radnor" })
CREATE UNIQUE (joshRadnor)-[:PLAYED_CHARACTER]-&gt;(ted)
CREATE UNIQUE (himym)-[:HAS_SEASON]-&gt;(himym_s1)
CREATE UNIQUE (himym_s1)-[:HAS_EPISODE]-&gt;(himym_s1_e1)
CREATE UNIQUE (himym_s1_e1)-[:FEATURED_CHARACTER]-&gt;(ted)
CREATE (himym_s1_e1_review1 { title: "Meet Me At The Bar In 15 Minutes &amp; Suit Up",
  content: "It was awesome" })
CREATE (wakenPayne:User { name: "WakenPayne" })
CREATE (wakenPayne)-[:WROTE_REVIEW]-&gt;(himym_s1_e1_review1)&lt;-[:HAS_REVIEW]-(himym_s1_e1)</programlisting>
<simpara>This is how the data looks in the database:</simpara>
<informalfigure>
<ulink url="images/cypherdoc--573a3ce5.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypherdoc--573a3ce5.svg"/>
  </imageobject>
  <textobject><phrase>cypherdoc--573a3ce5.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>Note that even though we could have modeled the reviews as relationships with title and content properties on them, we made them nodes instead.
We gain a lot of flexibility in this way, for example if we want to connect comments to each review.</simpara>
<simpara>Now let&#8217;s add more data:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (himym:TVShow { name: "How I Met Your Mother" }),(himym_s1:Season),
  (himym_s1_e1:Episode { name: "Pilot" }),
  (himym)-[:HAS_SEASON]-&gt;(himym_s1)-[:HAS_EPISODE]-&gt;(himym_s1_e1)
CREATE (marshall:Character { name: "Marshall Eriksen" })
CREATE (robin:Character { name: "Robin Scherbatsky" })
CREATE (barney:Character { name: "Barney Stinson" })
CREATE (lily:Character { name: "Lily Aldrin" })
CREATE (jasonSegel:Actor { name: "Jason Segel" })
CREATE (cobieSmulders:Actor { name: "Cobie Smulders" })
CREATE (neilPatrickHarris:Actor { name: "Neil Patrick Harris" })
CREATE (alysonHannigan:Actor { name: "Alyson Hannigan" })
CREATE UNIQUE (jasonSegel)-[:PLAYED_CHARACTER]-&gt;(marshall)
CREATE UNIQUE (cobieSmulders)-[:PLAYED_CHARACTER]-&gt;(robin)
CREATE UNIQUE (neilPatrickHarris)-[:PLAYED_CHARACTER]-&gt;(barney)
CREATE UNIQUE (alysonHannigan)-[:PLAYED_CHARACTER]-&gt;(lily)
CREATE UNIQUE (himym_s1_e1)-[:FEATURED_CHARACTER]-&gt;(marshall)
CREATE UNIQUE (himym_s1_e1)-[:FEATURED_CHARACTER]-&gt;(robin)
CREATE UNIQUE (himym_s1_e1)-[:FEATURED_CHARACTER]-&gt;(barney)
CREATE UNIQUE (himym_s1_e1)-[:FEATURED_CHARACTER]-&gt;(lily)
CREATE (himym_s1_e1_review2 { title: "What a great pilot for a show :)",
  content: "The humour is great." })
CREATE (atlasredux:User { name: "atlasredux" })
CREATE (atlasredux)-[:WROTE_REVIEW]-&gt;(himym_s1_e1_review2)&lt;-[:HAS_REVIEW]-(himym_s1_e1)</programlisting>
</section>
<section id="_information_for_a_show">
<title>Information for a show</title>
<simpara>For a particular TV show, show  all the seasons and all the episodes and all the reviews and all the cast members from that show, that is all of the information connected to that TV show.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (tvShow:TVShow)-[:HAS_SEASON]-&gt;(season)-[:HAS_EPISODE]-&gt;(episode)
WHERE tvShow.name = "How I Met Your Mother"
RETURN season.name, episode.name</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">season.name</entry><entry align="left" valign="top">episode.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"HIMYM Season 1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Pilot"</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>We could also grab the reviews if there are any by slightly tweaking the query:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (tvShow:TVShow)-[:HAS_SEASON]-&gt;(season)-[:HAS_EPISODE]-&gt;(episode)
WHERE tvShow.name = "How I Met Your Mother"
WITH season, episode
OPTIONAL MATCH (episode)-[:HAS_REVIEW]-&gt;(review)
RETURN season.name, episode.name, review</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="3"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><thead><row><entry align="left" valign="top">season.name</entry><entry align="left" valign="top">episode.name</entry><entry align="left" valign="top">review</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col3">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"HIMYM Season 1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Pilot"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[5]{title:"Meet Me At The Bar In 15 Minutes &amp; Suit Up",content:"It was awesome"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"HIMYM Season 1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Pilot"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[15]{title:"What a great pilot for a show :)",content:"The humour is great."}</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Now let&#8217;s list the characters featured in a show.
Note that in this query we only put identifiers on the nodes we actually use later on.
The other nodes of the path pattern are designated by <literal>()</literal>.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (tvShow:TVShow)-[:HAS_SEASON]-&gt;()-[:HAS_EPISODE]-&gt;()-[:FEATURED_CHARACTER]-&gt;(character)
WHERE tvShow.name = "How I Met Your Mother"
RETURN DISTINCT character.name</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">character.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">5 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Ted Mosby"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Marshall Eriksen"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Robin Scherbatsky"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Barney Stinson"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Lily Aldrin"</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Now let&#8217;s look at how to get all cast members of a show.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH
  (tvShow:TVShow)-[:HAS_SEASON]-&gt;()-[:HAS_EPISODE]-&gt;(episode)-[:FEATURED_CHARACTER]-&gt;()&lt;-[:PLAYED_CHARACTER]-(actor)
WHERE tvShow.name = "How I Met Your Mother"
RETURN DISTINCT actor.name</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">actor.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">5 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Josh Radnor"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Jason Segel"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Cobie Smulders"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Neil Patrick Harris"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Alyson Hannigan"</literal></simpara></entry></row></tbody></tgroup></informaltable>
</section>
<section id="_information_for_an_actor">
<title>Information for an actor</title>
<simpara>First let’s add another TV show that Josh Radnor appeared in:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (er:TVShow { name: "ER" })
CREATE (er_s9:Season { name: "ER S7" })
CREATE (er_s9_e17:Episode { name: "Peter's Progress" })
CREATE (tedMosby:Character { name: "The Advocate " })
CREATE UNIQUE (er)-[:HAS_SEASON]-&gt;(er_s9)
CREATE UNIQUE (er_s9)-[:HAS_EPISODE]-&gt;(er_s9_e17)
WITH er_s9_e17
MATCH (actor:Actor),(episode:Episode)
WHERE actor.name = "Josh Radnor" AND episode.name = "Peter's Progress"
WITH actor, episode
CREATE (keith:Character { name: "Keith" })
CREATE UNIQUE (actor)-[:PLAYED_CHARACTER]-&gt;(keith)
CREATE UNIQUE (episode)-[:FEATURED_CHARACTER]-&gt;(keith)</programlisting>
<simpara>And now we’ll create a query to find the episodes that he has appeared in:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor)-[:PLAYED_CHARACTER]-&gt;(character)&lt;-[:FEATURED_CHARACTER]-(episode)
WHERE actor.name = "Josh Radnor"
RETURN episode.name AS Episode, character.name AS Character</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">Episode</entry><entry align="left" valign="top">Character</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Pilot"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Ted Mosby"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Peter's Progress"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Keith"</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Now let&#8217;s go for a similar query, but add the season and show to it as well.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor:Actor)-[:PLAYED_CHARACTER]-&gt;(character)&lt;-[:FEATURED_CHARACTER]-(episode),
  (episode)&lt;-[:HAS_EPISODE]-(season)&lt;-[:HAS_SEASON]-(tvshow)
WHERE actor.name = "Josh Radnor"
RETURN tvshow.name AS Show, season.name AS Season, episode.name AS Episode,
  character.name AS Character</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="4"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><colspec colname="col4"/><thead><row><entry align="left" valign="top">Show</entry><entry align="left" valign="top">Season</entry><entry align="left" valign="top">Episode</entry><entry align="left" valign="top">Character</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col4">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"How I Met Your Mother"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"HIMYM Season 1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Pilot"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Ted Mosby"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"ER"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"ER S7"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Peter's Progress"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Keith"</literal></simpara></entry></row></tbody></tgroup></informaltable>
</section>
</section>
<section id="examples-acl-structures-in-graphs">
<title>ACL structures in graphs</title>
<simpara>This example gives a generic overview of an approach to handling Access Control Lists (ACLs) in graphs,
and a simplified example with concrete queries.</simpara>
<section id="_generic_approach">
<title>Generic approach</title>
<simpara>In many scenarios, an application needs to handle security on some form of managed
objects. This example describes one pattern to handle this through the use of a graph structure and traversers
that build a full permissions-structure for any managed object with exclude and include overriding
possibilities. This results in a dynamic construction of ACLs based on the
position and context of the managed object.</simpara>
<simpara>The result is a complex security scheme that can easily be implemented in a graph structure,
supporting permissions overriding, principal and content composition, without duplicating data anywhere.</simpara>
<informalfigure>
<ulink url="images/ACL.png">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/ACL.png" width="100%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>ACL.png</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<section id="_technique">
<title>Technique</title>
<simpara>As seen in the example graph layout, there are some key concepts in this domain model:</simpara>
<itemizedlist>
<listitem>
<simpara>
The managed content (folders and files) that are connected by <literal>HAS_CHILD_CONTENT</literal> relationships
</simpara>
</listitem>
<listitem>
<simpara>
The Principal subtree pointing out principals that can act as ACL members, pointed out by the <literal>PRINCIPAL</literal> relationships.
</simpara>
</listitem>
<listitem>
<simpara>
The aggregation of principals into groups, connected by the <literal>IS_MEMBER_OF</literal> relationship. One principal (user or group) can be part of many groups at the same time.
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>SECURITY</literal>&#8201;&#8212;&#8201;relationships, connecting the content composite structure to the principal composite structure, containing a addition/removal modifier property ("<literal>+RW</literal>").
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_constructing_the_acl">
<title>Constructing the ACL</title>
<simpara>The calculation of the effective permissions (e.g. Read, Write, Execute) for a
principal for any given ACL-managed node (content) follows a number of rules that will be encoded into the permissions-traversal:</simpara>
</section>
<section id="_top_down_traversal">
<title>Top-down-Traversal</title>
<simpara>This approach will let you define a generic permission pattern on the root content,
and then refine that for specific sub-content nodes and specific principals.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Start at the content node in question traverse upwards to the content root node to determine the path to it.
</simpara>
</listitem>
<listitem>
<simpara>
Start with a effective optimistic permissions list of "all permitted" (<literal>111</literal> in a bit encoded ReadWriteExecute case)
  or <literal>000</literal> if you like pessimistic security handling (everything is forbidden unless explicitly allowed).
</simpara>
</listitem>
<listitem>
<simpara>
Beginning from the topmost content node, look for any <literal>SECURITY</literal> relationships on it.
</simpara>
</listitem>
<listitem>
<simpara>
If found, look if the principal in question is part of the end-principal of the <literal>SECURITY</literal> relationship.
</simpara>
</listitem>
<listitem>
<simpara>
If yes, add the "<literal>+</literal>" permission modifiers to the existing permission pattern, revoke the "<literal>-</literal>" permission modifiers from the pattern.
</simpara>
</listitem>
<listitem>
<simpara>
If two principal nodes link to the same content node, first apply the more generic prinipals modifiers.
</simpara>
</listitem>
<listitem>
<simpara>
Repeat the security modifier search all the way down to the target content node, thus overriding more
  generic permissions with the set on nodes closer to the target node.
</simpara>
</listitem>
</orderedlist>
<simpara>The same algorithm is applicable for the bottom-up approach, basically just
traversing from the target content node upwards and applying the security modifiers dynamically
as the traverser goes up.</simpara>
</section>
<section id="_example">
<title>Example</title>
<simpara>Now, to get the resulting access rights for e.g. "<literal>user 1</literal>" on the "<literal>My File.pdf</literal>" in a Top-Down
approach on the model in the graph above would go like:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Traveling upward, we start with "<literal>Root folder</literal>", and set the permissions to <literal>11</literal> initially (only considering Read, Write).
</simpara>
</listitem>
<listitem>
<simpara>
There are two <literal>SECURITY</literal> relationships to that folder.
  User 1 is contained in both of them, but "<literal>root</literal>" is more generic, so apply it first then "<literal>All principals</literal>" <literal>+W</literal> <literal>+R</literal> &#8594; <literal>11</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
"<literal>Home</literal>" has no <literal>SECURITY</literal> instructions, continue.
</simpara>
</listitem>
<listitem>
<simpara>
"<literal>user1 Home</literal>" has <literal>SECURITY</literal>.
  First apply "<literal>Regular Users</literal>" (<literal>-R</literal> <literal>-W</literal>) &#8594; <literal>00</literal>, Then "<literal>user 1</literal>" (<literal>+R</literal> <literal>+W</literal>) &#8594; <literal>11</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
The target node "<literal>My File.pdf</literal>" has no <literal>SECURITY</literal> modifiers on it, so the effective permissions for "<literal>User 1</literal>" on "<literal>My File.pdf</literal>" are <literal>ReadWrite</literal> &#8594; <literal>11</literal>.
</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section id="_read_permission_example">
<title>Read-permission example</title>
<simpara>In this example, we are going to examine a tree structure of <literal>directories</literal> and
<literal>files</literal>. Also, there are users that own files and roles that can be assigned to
users. Roles can have permissions on directory or files structures (here we model
only <literal>canRead</literal>, as opposed to full <literal>rwx</literal> Unix permissions) and be nested. A more thorough
example of modeling ACL structures can be found at
<ulink url="http://www.xaprb.com/blog/2006/08/16/how-to-build-role-based-access-control-in-sql/">How to Build Role-Based Access Control in SQL</ulink>.</simpara>
<informalfigure>
<ulink url="images/The-Domain-Structure-ACL-structures-in-graphs.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/The-Domain-Structure-ACL-structures-in-graphs.svg"/>
  </imageobject>
  <textobject><phrase>The-Domain-Structure-ACL-structures-in-graphs.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<section id="_find_all_files_in_the_directory_structure">
<title>Find all files in the directory structure</title>
<simpara>In order to find all files contained in this structure, we need a variable length
query that follows all <literal>contains</literal> relationships and retrieves the nodes at the other
end of the <literal>leaf</literal> relationships.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH ({ name: 'FileRoot' })-[:contains*0..]-&gt;(parentDir)-[:leaf]-&gt;(file)
RETURN file</programlisting>
<simpara>resulting in:</simpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">file</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[10]{name:"File1"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[9]{name:"File2"}</literal></simpara></entry></row></tbody></tgroup></informaltable>
</section>
<section id="_what_files_are_owned_by_whom">
<title>What files are owned by whom?</title>
<simpara>If we introduce the concept of ownership on files, we then can ask for the owners of the files we find&#8201;&#8212;&#8201;connected via <literal>owns</literal> relationships to file nodes.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH ({ name: 'FileRoot' })-[:contains*0..]-&gt;()-[:leaf]-&gt;(file)&lt;-[:owns]-(user)
RETURN file, user</programlisting>
<simpara>Returning the owners of all files below the <literal>FileRoot</literal> node.</simpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">file</entry><entry align="left" valign="top">user</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[10]{name:"File1"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[7]{name:"User1"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[9]{name:"File2"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[6]{name:"User2"}</literal></simpara></entry></row></tbody></tgroup></informaltable>
</section>
<section id="_who_has_access_to_a_file">
<title>Who has access to a File?</title>
<simpara>If we now want to check what users have read access to all Files, and define our ACL as</simpara>
<itemizedlist>
<listitem>
<simpara>
The root directory has no access granted.
</simpara>
</listitem>
<listitem>
<simpara>
Any user having a role that has been granted <literal>canRead</literal> access to one of the parent folders of a File has read access.
</simpara>
</listitem>
</itemizedlist>
<simpara>In order to find users that can read any part of the parent folder hierarchy above the files,
Cypher provides optional variable length path.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (file)&lt;-[:leaf]-()&lt;-[:contains*0..]-(dir)
OPTIONAL MATCH (dir)&lt;-[:canRead]-(role)-[:member]-&gt;(readUser)
WHERE file.name =~ 'File.*'
RETURN file.name, dir.name, role.name, readUser.name</programlisting>
<simpara>This will return the <literal>file</literal>, and the directory where the user has the <literal>canRead</literal> permission along
with the <literal>user</literal> and their <literal>role</literal>.</simpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="4"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><colspec colname="col4"/><thead><row><entry align="left" valign="top">file.name</entry><entry align="left" valign="top">dir.name</entry><entry align="left" valign="top">role.name</entry><entry align="left" valign="top">readUser.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col4">9 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"File1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"HomeU1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"File1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Home"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"File1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"FileRoot"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"SUDOers"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Admin1"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"File1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"FileRoot"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"SUDOers"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Admin2"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"File2"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Desktop"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"File2"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"HomeU2"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"File2"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Home"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"File2"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"FileRoot"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"SUDOers"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Admin1"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"File2"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"FileRoot"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"SUDOers"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Admin2"</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>The results listed above contain <literal>null</literal> for optional path segments, which can be mitigated by either asking several
queries or returning just the really needed values.</simpara>
</section>
</section>
</section>
<section id="cypher-cookbook-hyperedges">
<title>Hyperedges</title>
<simpara>Imagine a user being part of different groups.
A group can have different roles, and a user can be part of different groups.
He also can have different roles in different groups apart from the membership.
The association of a User, a Group and a Role can be referred to as a <emphasis>HyperEdge</emphasis>.
However, it can be easily modeled in a property graph as a node that captures this n-ary relationship, as depicted below in the <literal>U1G2R1</literal> node.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-hyperedge-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-hyperedge-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-hyperedge-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="cookbook-find-groups">
<title>Find Groups</title>
<simpara>To find out in what roles a user is for a particular groups (here
        <emphasis>Group2</emphasis>), the following query can traverse this HyperEdge node and
        provide answers.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH ({ name: 'User1' })-[:hasRoleInGroup]-&gt;(hyperEdge)-[:hasGroup]-&gt;({ name: 'Group2' }),
  (hyperEdge)-[:hasRole]-&gt;(role)
RETURN role.name</programlisting>
</para></formalpara>
<simpara>The role of <literal>User1</literal> is returned:</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">role.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Role1"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"U1G2R1"})
create (_1 {`name`:"Role2"})
create (_2 {`name`:"Group1"})
create (_3 {`name`:"Group2"})
create (_4 {`name`:"Role1"})
create (_5 {`name`:"Role"})
create (_6 {`name`:"User1"})
create (_7 {`name`:"U1G1R2"})
create (_8 {`name`:"Group"})
create _0-[:`hasRole`]-&gt;_4
create _0-[:`hasGroup`]-&gt;_3
create _1-[:`isA`]-&gt;_5
create _2-[:`canHave`]-&gt;_4
create _2-[:`canHave`]-&gt;_1
create _2-[:`isA`]-&gt;_8
create _3-[:`canHave`]-&gt;_1
create _3-[:`canHave`]-&gt;_4
create _3-[:`isA`]-&gt;_8
create _4-[:`isA`]-&gt;_5
create _6-[:`in`]-&gt;_2
create _6-[:`in`]-&gt;_3
create _6-[:`hasRoleInGroup`]-&gt;_0
create _6-[:`hasRoleInGroup`]-&gt;_7
create _7-[:`hasRole`]-&gt;_1
create _7-[:`hasGroup`]-&gt;_2
</database><command>
 match ({name: 'User1'})-[:hasRoleInGroup]-&gt;(hyperEdge)-[:hasGroup]-&gt;({name: 'Group2'}), (hyperEdge)-[:hasRole]-&gt;(role) return role.name</command></para></formalpara>
</section>
<section id="cookbook-find-all-groups-and-roles-for-a-user">
<title>Find all groups and roles for a user</title>
<simpara>Here, find all groups and the roles a user has, sorted by the name of the role.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH ({ name: 'User1' })-[:hasRoleInGroup]-&gt;(hyperEdge)-[:hasGroup]-&gt;(group),
  (hyperEdge)-[:hasRole]-&gt;(role)
RETURN role.name, group.name
ORDER BY role.name ASC</programlisting>
</para></formalpara>
<simpara>The groups and roles of <literal>User1</literal> are returned:</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">role.name</entry><entry align="left" valign="top">group.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Role1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Group2"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Role2"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Group1"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"U1G2R1"})
create (_1 {`name`:"Role2"})
create (_2 {`name`:"Group1"})
create (_3 {`name`:"Group2"})
create (_4 {`name`:"Role1"})
create (_5 {`name`:"Role"})
create (_6 {`name`:"User1"})
create (_7 {`name`:"U1G1R2"})
create (_8 {`name`:"Group"})
create _0-[:`hasRole`]-&gt;_4
create _0-[:`hasGroup`]-&gt;_3
create _1-[:`isA`]-&gt;_5
create _2-[:`canHave`]-&gt;_4
create _2-[:`canHave`]-&gt;_1
create _2-[:`isA`]-&gt;_8
create _3-[:`canHave`]-&gt;_1
create _3-[:`canHave`]-&gt;_4
create _3-[:`isA`]-&gt;_8
create _4-[:`isA`]-&gt;_5
create _6-[:`in`]-&gt;_2
create _6-[:`in`]-&gt;_3
create _6-[:`hasRoleInGroup`]-&gt;_0
create _6-[:`hasRoleInGroup`]-&gt;_7
create _7-[:`hasRole`]-&gt;_1
create _7-[:`hasGroup`]-&gt;_2
</database><command>
 match ({name: 'User1'})-[:hasRoleInGroup]-&gt;(hyperEdge)-[:hasGroup]-&gt;(group), (hyperEdge)-[:hasRole]-&gt;(role) return role.name, group.name order by role.name asc</command></para></formalpara>
</section>
<section id="cookbook-find-common-groups-based-on-shared-roles">
<title>Find common groups based on shared roles</title>
<simpara>Assume a more complicated graph:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Two user nodes <literal>User1</literal>, <literal>User2</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>User1</literal> is in <literal>Group1</literal>, <literal>Group2</literal>, <literal>Group3</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>User1</literal> has <literal>Role1</literal>, <literal>Role2</literal> in <literal>Group1</literal>; <literal>Role2</literal>, <literal>Role3</literal> in <literal>Group2</literal>; <literal>Role3</literal>, <literal>Role4</literal> in <literal>Group3</literal> (hyper edges).
</simpara>
</listitem>
<listitem>
<simpara>
<literal>User2</literal> is in <literal>Group1</literal>, <literal>Group2</literal>, <literal>Group3</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>User2</literal> has <literal>Role2</literal>, <literal>Role5</literal> in <literal>Group1</literal>; <literal>Role3</literal>, <literal>Role4</literal> in <literal>Group2</literal>; <literal>Role5</literal>, <literal>Role6</literal> in <literal>Group3</literal> (hyper edges).
</simpara>
</listitem>
</orderedlist>
<simpara>The graph for this looks like the following (nodes like <literal>U1G2R23</literal> representing the HyperEdges):</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-hyperedgecommongroups-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-hyperedgecommongroups-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-hyperedgecommongroups-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara>To return <literal>Group1</literal> and <literal>Group2</literal> as <literal>User1</literal> and <literal>User2</literal> share at least one common role in these two groups, the query looks like this:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (u1)-[:hasRoleInGroup]-&gt;(hyperEdge1)-[:hasGroup]-&gt;(group),(hyperEdge1)-[:hasRole]-&gt;(role),
  (u2)-[:hasRoleInGroup]-&gt;(hyperEdge2)-[:hasGroup]-&gt;(group),(hyperEdge2)-[:hasRole]-&gt;(role)
WHERE u1.name = 'User1' AND u2.name = 'User2'
RETURN group.name, count(role)
ORDER BY group.name ASC</programlisting>
</para></formalpara>
<simpara>The groups where <literal>User1</literal> and <literal>User2</literal> share at least one common role:</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">group.name</entry><entry align="left" valign="top">count(role)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Group1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Group2"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"U2G2R34"})
create (_1 {`name`:"U1G3R34"})
create (_2 {`name`:"User2"})
create (_3 {`name`:"User1"})
create (_4 {`name`:"Role6"})
create (_5 {`name`:"U1G2R23"})
create (_6 {`name`:"Role4"})
create (_7 {`name`:"Role5"})
create (_8 {`name`:"U2G1R25"})
create (_9 {`name`:"Group1"})
create (_10 {`name`:"Role2"})
create (_11 {`name`:"Group2"})
create (_12 {`name`:"Role3"})
create (_13 {`name`:"Group3"})
create (_14 {`name`:"U1G1R12"})
create (_15 {`name`:"Role1"})
create (_16 {`name`:"U2G3R56"})
create _0-[:`hasGroup`]-&gt;_11
create _0-[:`hasRole`]-&gt;_12
create _0-[:`hasRole`]-&gt;_6
create _1-[:`hasGroup`]-&gt;_13
create _1-[:`hasRole`]-&gt;_12
create _1-[:`hasRole`]-&gt;_6
create _2-[:`hasRoleInGroup`]-&gt;_8
create _2-[:`hasRoleInGroup`]-&gt;_0
create _2-[:`hasRoleInGroup`]-&gt;_16
create _3-[:`hasRoleInGroup`]-&gt;_14
create _3-[:`hasRoleInGroup`]-&gt;_5
create _3-[:`hasRoleInGroup`]-&gt;_1
create _5-[:`hasGroup`]-&gt;_11
create _5-[:`hasRole`]-&gt;_10
create _5-[:`hasRole`]-&gt;_12
create _8-[:`hasGroup`]-&gt;_9
create _8-[:`hasRole`]-&gt;_10
create _8-[:`hasRole`]-&gt;_7
create _14-[:`hasGroup`]-&gt;_9
create _14-[:`hasRole`]-&gt;_15
create _14-[:`hasRole`]-&gt;_10
create _16-[:`hasGroup`]-&gt;_13
create _16-[:`hasRole`]-&gt;_7
create _16-[:`hasRole`]-&gt;_4
</database><command>
 match (u1)-[:hasRoleInGroup]-&gt;(hyperEdge1)-[:hasGroup]-&gt;(group), (hyperEdge1)-[:hasRole]-&gt;(role), (u2)-[:hasRoleInGroup]-&gt;(hyperEdge2)-[:hasGroup]-&gt;(group), (hyperEdge2)-[:hasRole]-&gt;(role) where u1.name = 'User1' and u2.name = 'User2' return group.name, count(role) order by group.name ASC</command></para></formalpara>
</section>
</section>
<section id="cypher-cookbook-friend-finding">
<title>Basic friend finding based on social neighborhood</title>
<simpara>Imagine an example graph like the following one:</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-collabfiltering-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-collabfiltering-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-collabfiltering-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara id="cookbook-simple-friend-finder">To find out the friends of Joe&#8217;s friends that are not already his friends, the query looks like this:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (joe { name: 'Joe' })-[:knows*2..2]-(friend_of_friend)
WHERE NOT (joe)-[:knows]-(friend_of_friend)
RETURN friend_of_friend.name, COUNT(*)
ORDER BY COUNT(*) DESC , friend_of_friend.name</programlisting>
</para></formalpara>
<simpara>This returns a list of friends-of-friends ordered by the number of connections to them, and secondly by their name.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">friend_of_friend.name</entry><entry align="left" valign="top">COUNT(*)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Ian"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Derrick"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Jill"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Bill"})
create (_1 {`name`:"Sara"})
create (_2 {`name`:"Derrick"})
create (_3 {`name`:"Ian"})
create (_4 {`name`:"Jill"})
create (_5 {`name`:"Joe"})
create _0-[:`knows`]-&gt;_2
create _0-[:`knows`]-&gt;_3
create _1-[:`knows`]-&gt;_0
create _1-[:`knows`]-&gt;_3
create _1-[:`knows`]-&gt;_4
create _5-[:`knows`]-&gt;_0
create _5-[:`knows`]-&gt;_1
</database><command>
 match (joe {name: 'Joe'})-[:knows*2..2]-(friend_of_friend) where not (joe)-[:knows]-(friend_of_friend) return friend_of_friend.name, COUNT(*) order by COUNT(*) DESC, friend_of_friend.name</command></para></formalpara>
</section>
<section id="cypher-cookbook-co-favorited-places">
<title>Co-favorited places</title>
<figure><title>Graph</title>
<ulink url="images/cypher-cofavoritedplaces-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-cofavoritedplaces-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-cofavoritedplaces-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="cookbook-co-favorited-places----users-who-like-x-also-like-y">
<title>Co-favorited places&#8201;&#8212;&#8201;users who like x also like y</title>
<simpara>Find places that people also like who favorite this place:</simpara>
<itemizedlist>
<listitem>
<simpara>
Determine who has favorited place x.
</simpara>
</listitem>
<listitem>
<simpara>
What else have they favorited that is not place x.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (place)&lt;-[:favorite]-(person)-[:favorite]-&gt;(stuff)
WHERE place.name = 'CoffeeShop1'
RETURN stuff.name, count(*)
ORDER BY count(*) DESC , stuff.name</programlisting>
</para></formalpara>
<simpara>The list of places that are favorited by people that favorited the start place.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">stuff.name</entry><entry align="left" valign="top">count(*)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"MelsPlace"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"CoffeShop2"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"SaunaX"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"SaunaX"})
create (_1 {`name`:"CoffeeShop1"})
create (_2 {`name`:"MelsPlace"})
create (_3 {`name`:"CoffeeShop3"})
create (_4 {`name`:"Cool"})
create (_5 {`name`:"CoffeeShop2"})
create (_6 {`name`:"CoffeShop2"})
create (_7 {`name`:"Cosy"})
create (_8 {`name`:"Jill"})
create (_9 {`name`:"Joe"})
create _1-[:`tagged`]-&gt;_4
create _1-[:`tagged`]-&gt;_7
create _2-[:`tagged`]-&gt;_7
create _2-[:`tagged`]-&gt;_4
create _3-[:`tagged`]-&gt;_7
create _5-[:`tagged`]-&gt;_4
create _8-[:`favorite`]-&gt;_1
create _8-[:`favorite`]-&gt;_2
create _8-[:`favorite`]-&gt;_6
create _9-[:`favorite`]-&gt;_1
create _9-[:`favorite`]-&gt;_0
create _9-[:`favorite`]-&gt;_2
</database><command>
 MATCH (place)&lt;-[:favorite]-(person)-[:favorite]-&gt;(stuff)
           WHERE place.name = 'CoffeeShop1'
             RETURN stuff.name, count(*)
             ORDER BY count(*) DESC, stuff.name</command></para></formalpara>
</section>
<section id="cookbook-co-tagged-places----places-related-through-tags">
<title>Co-Tagged places&#8201;&#8212;&#8201;places related through tags</title>
<simpara>Find places that are tagged with the same tags:</simpara>
<itemizedlist>
<listitem>
<simpara>
Determine the tags for place x.
</simpara>
</listitem>
<listitem>
<simpara>
What else is tagged the same as x that is not x.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (place)-[:tagged]-&gt;(tag)&lt;-[:tagged]-(otherPlace)
WHERE place.name = 'CoffeeShop1'
RETURN otherPlace.name, collect(tag.name)
ORDER BY length(collect(tag.name)) DESC , otherPlace.name</programlisting>
</para></formalpara>
<simpara>This query returns other places than CoffeeShop1 which share the same tags; they are ranked by the number of tags.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">otherPlace.name</entry><entry align="left" valign="top">collect(tag.name)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"MelsPlace"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>["Cool","Cosy"]</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"CoffeeShop2"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>["Cool"]</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"CoffeeShop3"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>["Cosy"]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"SaunaX"})
create (_1 {`name`:"CoffeeShop1"})
create (_2 {`name`:"MelsPlace"})
create (_3 {`name`:"CoffeeShop3"})
create (_4 {`name`:"Cool"})
create (_5 {`name`:"CoffeeShop2"})
create (_6 {`name`:"CoffeShop2"})
create (_7 {`name`:"Cosy"})
create (_8 {`name`:"Jill"})
create (_9 {`name`:"Joe"})
create _1-[:`tagged`]-&gt;_4
create _1-[:`tagged`]-&gt;_7
create _2-[:`tagged`]-&gt;_7
create _2-[:`tagged`]-&gt;_4
create _3-[:`tagged`]-&gt;_7
create _5-[:`tagged`]-&gt;_4
create _8-[:`favorite`]-&gt;_1
create _8-[:`favorite`]-&gt;_2
create _8-[:`favorite`]-&gt;_6
create _9-[:`favorite`]-&gt;_1
create _9-[:`favorite`]-&gt;_0
create _9-[:`favorite`]-&gt;_2
</database><command>
 MATCH (place)-[:tagged]-&gt;(tag)&lt;-[:tagged]-(otherPlace)
 WHERE place.name = 'CoffeeShop1'
 RETURN otherPlace.name, collect(tag.name)
 ORDER BY length(collect(tag.name)) DESC, otherPlace.name</command></para></formalpara>
</section>
</section>
<section id="cypher-cookbook-similar-favorites">
<title>Find people based on similar favorites</title>
<figure><title>Graph</title>
<ulink url="images/cypher-peoplesimilarityfavorites-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-peoplesimilarityfavorites-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-peoplesimilarityfavorites-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara id="cookbook-find-people-based-on-similar-favorites">To find out the possible new friends based on them liking similar things as the asking person, use a query like this:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me { name: 'Joe' })-[:favorite]-&gt;(stuff)&lt;-[:favorite]-(person)
WHERE NOT (me)-[:friend]-(person)
RETURN person.name, count(stuff)
ORDER BY count(stuff) DESC</programlisting>
</para></formalpara>
<simpara>The list of possible friends ranked by them liking similar stuff that are not yet friends is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">person.name</entry><entry align="left" valign="top">count(stuff)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Derrick"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Jill"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Sara"})
create (_1 {`name`:"Cats"})
create (_2 {`name`:"Derrick"})
create (_3 {`name`:"Bikes"})
create (_4 {`name`:"Jill"})
create (_5 {`name`:"Joe"})
create _0-[:`favorite`]-&gt;_1
create _0-[:`favorite`]-&gt;_3
create _2-[:`favorite`]-&gt;_1
create _2-[:`favorite`]-&gt;_3
create _4-[:`favorite`]-&gt;_3
create _5-[:`favorite`]-&gt;_1
create _5-[:`favorite`]-&gt;_3
create _5-[:`friend`]-&gt;_0
</database><command>
 MATCH (me {name: 'Joe'})-[:favorite]-&gt;(stuff)&lt;-[:favorite]-(person) WHERE NOT (me)-[:friend]-(person) RETURN person.name, count(stuff) ORDER BY count(stuff) DESC</command></para></formalpara>
</section>
<section id="cypher-cookbook-mutual-friends-and-groups">
<title>Find people based on mutual friends and groups</title>
<figure><title>Graph</title>
<ulink url="images/cypher-mutualfriendsandgroups-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-mutualfriendsandgroups-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-mutualfriendsandgroups-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara id="cookbook-find-mutual-friends-and-groups">In this scenario, the problem is to determine mutual friends and groups, if any,
between persons. If no mutual groups or friends are found, there should be a <literal>0</literal> returned.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me { name: 'Joe' }),(other)
WHERE other.name IN ['Jill', 'Bob']
OPTIONAL MATCH pGroups=(me)-[:member_of_group]-&gt;(mg)&lt;-[:member_of_group]-(other)
OPTIONAL MATCH pMutualFriends=(me)-[:knows]-&gt;(mf)&lt;-[:knows]-(other)
RETURN other.name AS name, count(DISTINCT pGroups) AS mutualGroups,
  count(DISTINCT pMutualFriends) AS mutualFriends
ORDER BY mutualFriends DESC</programlisting>
</para></formalpara>
<simpara>The question we are asking is&#8201;&#8212;&#8201;how many unique paths are there between me and Jill, the paths being common group memberships, and common friends.
If the paths are mandatory, no results will be returned if me and Bob lack any common friends, and we don&#8217;t want that. To make a path optional,
you have to make at least one of it&#8217;s relationships optional. That makes the whole path optional.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="3"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><thead><row><entry align="left" valign="top">name</entry><entry align="left" valign="top">mutualGroups</entry><entry align="left" valign="top">mutualFriends</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col3">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Jill"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Bob"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>0</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Bill"})
create (_1 {`name`:"Group1"})
create (_2 {`name`:"Bob"})
create (_3 {`name`:"Jill"})
create (_4 {`name`:"Joe"})
create _0-[:`member_of_group`]-&gt;_1
create _2-[:`member_of_group`]-&gt;_1
create _3-[:`member_of_group`]-&gt;_1
create _3-[:`knows`]-&gt;_0
create _4-[:`member_of_group`]-&gt;_1
create _4-[:`knows`]-&gt;_0
</database><command>
 MATCH (me {name: 'Joe'}), (other) WHERE other.name IN ['Jill', 'Bob'] OPTIONAL MATCH pGroups=(me)-[:member_of_group]-&gt;(mg)&lt;-[:member_of_group]-(other)
 OPTIONAL MATCH pMutualFriends=(me)-[:knows]-&gt;(mf)&lt;-[:knows]-(other) RETURN other.name as name,
  count(distinct pGroups) AS mutualGroups,
  count(distinct pMutualFriends) AS mutualFriends ORDER BY mutualFriends DESC</command></para></formalpara>
</section>
<section id="cypher-cookbook-similar-tags">
<title>Find friends based on similar tagging</title>
<figure><title>Graph</title>
<ulink url="images/cypher-peoplesimilaritytags-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-peoplesimilaritytags-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-peoplesimilaritytags-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara id="cookbook-find-people-based-on-similar-tagged-favorties">To find people similar to me based on the taggings of their favorited items, one approach could be:</simpara>
<itemizedlist>
<listitem>
<simpara>
Determine the tags associated with what I favorite.
</simpara>
</listitem>
<listitem>
<simpara>
What else is tagged with those tags?
</simpara>
</listitem>
<listitem>
<simpara>
Who favorites items tagged with the same tags?
</simpara>
</listitem>
<listitem>
<simpara>
Sort the result by how many of the same things these people like.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH
  (me)-[:favorite]-&gt;(myFavorites)-[:tagged]-&gt;(tag)&lt;-[:tagged]-(theirFavorites)&lt;-[:favorite]-(people)
WHERE me.name = 'Joe' AND NOT me=people
RETURN people.name AS name, count(*) AS similar_favs
ORDER BY similar_favs DESC</programlisting>
</para></formalpara>
<simpara>The query returns the list of possible friends ranked by them liking similar stuff that are not yet friends.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">name</entry><entry align="left" valign="top">similar_favs</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Sara"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Derrick"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Animals"})
create (_1 {`name`:"Hobby"})
create (_2 {`name`:"Surfing"})
create (_3 {`name`:"Sara"})
create (_4 {`name`:"Cats"})
create (_5 {`name`:"Derrick"})
create (_6 {`name`:"Horses"})
create (_7 {`name`:"Bikes"})
create (_8 {`name`:"Joe"})
create _2-[:`tagged`]-&gt;_1
create _3-[:`favorite`]-&gt;_7
create _3-[:`favorite`]-&gt;_6
create _4-[:`tagged`]-&gt;_0
create _5-[:`favorite`]-&gt;_7
create _6-[:`tagged`]-&gt;_0
create _7-[:`tagged`]-&gt;_1
create _8-[:`favorite`]-&gt;_4
create _8-[:`favorite`]-&gt;_6
create _8-[:`favorite`]-&gt;_7
create _8-[:`favorite`]-&gt;_2
</database><command>
 MATCH (me)-[:favorite]-&gt;(myFavorites)-[:tagged]-&gt;(tag)&lt;-[:tagged]-(theirFavorites)&lt;-[:favorite]-(people) WHERE me.name = 'Joe' AND NOT me=people RETURN people.name as name, count(*) as similar_favs ORDER BY similar_favs DESC</command></para></formalpara>
</section>
<section id="cypher-cookbook-multirelational-social-network">
<title>Multirelational (social) graphs</title>
<figure><title>Graph</title>
<ulink url="images/cypher-multirelationalsocialnetwork-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-multirelationalsocialnetwork-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-multirelationalsocialnetwork-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara id="cookbook-who-follows-or-loves-me-back">This example shows a multi-relational network between persons and things they like.
        A multi-relational graph is a graph with more than one kind of relationship between nodes.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me { name: 'Joe' })-[r1:FOLLOWS|:LOVES]-&gt;(other)-[r2]-&gt;(me)
WHERE type(r1)=type(r2)
RETURN other.name, type(r1)</programlisting>
</para></formalpara>
<simpara>The query returns people that <literal>FOLLOWS</literal> or <literal>LOVES</literal> <literal>Joe</literal> back.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">other.name</entry><entry align="left" valign="top">type(r1)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Sara"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"FOLLOWS"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Maria"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"FOLLOWS"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Maria"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"LOVES"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"cats"})
create (_1 {`name`:"nature"})
create (_2 {`name`:"Ben"})
create (_3 {`name`:"Sara"})
create (_4 {`name`:"bikes"})
create (_5 {`name`:"Maria"})
create (_6 {`name`:"cars"})
create (_7 {`name`:"Joe"})
create _3-[:`FOLLOWS`]-&gt;_7
create _3-[:`FOLLOWS`]-&gt;_2
create _3-[:`LIKES`]-&gt;_4
create _3-[:`LIKES`]-&gt;_6
create _3-[:`LIKES`]-&gt;_0
create _5-[:`FOLLOWS`]-&gt;_7
create _5-[:`LOVES`]-&gt;_7
create _5-[:`LIKES`]-&gt;_6
create _7-[:`FOLLOWS`]-&gt;_3
create _7-[:`FOLLOWS`]-&gt;_5
create _7-[:`LOVES`]-&gt;_5
create _7-[:`LIKES`]-&gt;_4
create _7-[:`LIKES`]-&gt;_1
</database><command>
 MATCH (me {name: 'Joe'})-[r1:FOLLOWS|:LOVES]-&gt;(other)-[r2]-&gt;(me) WHERE type(r1)=type(r2) RETURN other.name, type(r1)</command></para></formalpara>
</section>
<section id="cypher-cookbook-newsfeed">
<title>Implementing newsfeeds in a graph</title>
<informalfigure>
<ulink url="images/cypher-newsfeed-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-newsfeed-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-newsfeed-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara id="cookbook-retrieve-the-ordered-timeline-of-status-updates-of-all-my-friends">Implementation of newsfeed or timeline feature is a frequent requirement for social applications. The following exmaples are inspired by <ulink url="http://techfin.in/2012/10/newsfeed-feature-powered-by-neo4j-graph-database/">Newsfeed feature powered by Neo4j Graph Database</ulink>.
The query asked here is:</simpara>
<simpara>Starting at <literal>me</literal>, retrieve the time-ordered status feed of the status updates of me and and all friends that are connected via a <literal>CONFIRMED</literal> <literal>FRIEND</literal> relationship to me.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me { name: 'Joe' })-[rels:FRIEND*0..1]-(myfriend)
WHERE ALL (r IN rels WHERE r.status = 'CONFIRMED')
WITH myfriend
MATCH (myfriend)-[:STATUS]-(latestupdate)-[:NEXT*0..1]-(statusupdates)
RETURN myfriend.name AS name, statusupdates.date AS date, statusupdates.text AS text
ORDER BY statusupdates.date DESC LIMIT 3</programlisting>
</para></formalpara>
<simpara>To understand the strategy, let&#8217;s divide the query into five steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
First Get the list of all my friends (along with me) through <literal>FRIEND</literal> relationship (<literal>MATCH (me {name: 'Joe'})-[rels:FRIEND*0..1]-(myfriend)</literal>). Also,  the <literal>WHERE</literal> predicate can be added to check whether the friend request is pending or confirmed.
</simpara>
</listitem>
<listitem>
<simpara>
Get the latest status update of my friends through Status relationship (<literal>MATCH myfriend-[:STATUS]-latestupdate</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
Get subsequent status updates (along with the latest one) of my friends through <literal>NEXT</literal> relationships (<literal>MATCH (myfriend)-[:STATUS]-(latestupdate)-[:NEXT*0..1]-(statusupdates)</literal>) which will give you the latest and one additional statusupdate; adjust <literal>0..1</literal> to whatever suits your case.
</simpara>
</listitem>
<listitem>
<simpara>
Sort the status updates by posted date (<literal>ORDER BY statusupdates.date DESC</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
<literal>LIMIT</literal> the number of updates you need in every query (<literal>LIMIT 3</literal>).
</simpara>
</listitem>
</orderedlist>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="3"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><thead><row><entry align="left" valign="top">name</entry><entry align="left" valign="top">date</entry><entry align="left" valign="top">text</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col3">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Joe"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>6</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Joe status2"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Bob"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"bobs status2"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Joe"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Joe status1"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Bob"})
create (_1 {`date`:1, `name`:"bob_s1", `text`:"bobs status1"})
create (_2 {`date`:4, `name`:"bob_s2", `text`:"bobs status2"})
create (_3 {`name`:"Alice"})
create (_4 {`date`:2, `name`:"alice_s1", `text`:"Alices status1"})
create (_5 {`date`:5, `name`:"alice_s2", `text`:"Alices status2"})
create (_6 {`name`:"Joe"})
create (_7 {`date`:3, `name`:"joe_s1", `text`:"Joe status1"})
create (_8 {`date`:6, `name`:"joe_s2", `text`:"Joe status2"})
create _0-[:`STATUS`]-&gt;_1
create _0-[:`FRIEND` {`status`:"CONFIRMED"}]-&gt;_3
create _1-[:`NEXT`]-&gt;_2
create _3-[:`STATUS`]-&gt;_4
create _3-[:`FRIEND` {`status`:"PENDING"}]-&gt;_6
create _4-[:`NEXT`]-&gt;_5
create _6-[:`STATUS`]-&gt;_7
create _6-[:`FRIEND` {`status`:"CONFIRMED"}]-&gt;_0
create _7-[:`NEXT`]-&gt;_8
</database><command>
 MATCH (me {name: 'Joe'})-[rels:FRIEND*0..1]-(myfriend)
 WHERE ALL(r in rels WHERE r.status = 'CONFIRMED')
 WITH myfriend
 MATCH (myfriend)-[:STATUS]-(latestupdate)-[:NEXT*0..1]-(statusupdates)
 RETURN myfriend.name as name, statusupdates.date as date, statusupdates.text as text
 ORDER BY statusupdates.date DESC LIMIT 3</command></para></formalpara>
<simpara id="cookbook-insert-a-new-status-update-for-a-user">Here, the example shows how to add a new status update into the existing data for a user.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me)
WHERE me.name='Bob'
OPTIONAL MATCH (me)-[r:STATUS]-(secondlatestupdate)
DELETE r
CREATE (me)-[:STATUS]-&gt;(latest_update { text:'Status',date:123 })
WITH latest_update, collect(secondlatestupdate) AS seconds
FOREACH (x IN seconds | CREATE latest_update-[:NEXT]-&gt;x)
RETURN latest_update.text AS new_status</programlisting>
</para></formalpara>
<simpara>Dividing the query into steps, this query resembles adding new item in middle of a doubly linked list:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Get the latest update (if it exists) of the user through the <literal>STATUS</literal> relationship (<literal>OPTIONAL MATCH (me)-[r:STATUS]-(secondlatestupdate)</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
Delete the <literal>STATUS</literal> relationship between <literal>user</literal> and <literal>secondlatestupdate</literal> (if it exists), as this would become the second latest update now
  and only the latest update would be added through a <literal>STATUS</literal> relationship;
  all earlier updates would be connected to their subsequent updates through a <literal>NEXT</literal> relationship. (<literal>DELETE r</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
Now, create the new <literal>statusupdate</literal> node (with text and date as properties) and connect this with the user through a <literal>STATUS</literal> relationship
  (<literal>CREATE me-[:STATUS]-&gt;(latest_update { text:'Status',date:123 })</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
Pipe over <literal>statusupdate</literal> or an empty collection to the next query part
  (<literal>WITH latest_update, collect(secondlatestupdate) AS seconds</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
Now, create a <literal>NEXT</literal> relationship between the latest status update and the second latest status update (if it exists) (<literal>FOREACH(x in seconds | CREATE latest_update-[:NEXT]-&gt;x)</literal>).
</simpara>
</listitem>
</orderedlist>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">new_status</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 2
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 2
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships deleted: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Status"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Bob"})
create (_1 {`date`:1, `name`:"bob_s1", `text`:"bobs status1"})
create (_2 {`date`:4, `name`:"bob_s2", `text`:"bobs status2"})
create _0-[:`STATUS`]-&gt;_1
create _1-[:`NEXT`]-&gt;_2
</database><command>

 MATCH (me)
 WHERE me.name='Bob'
 OPTIONAL MATCH (me)-[r:STATUS]-(secondlatestupdate)
 DELETE r
 CREATE (me)-[:STATUS]-&gt;(latest_update {text:'Status',date:123})
 WITH latest_update, collect(secondlatestupdate) as seconds
 FOREACH(x in seconds | CREATE latest_update-[:NEXT]-&gt;x)
 RETURN latest_update.text as new_status</command></para></formalpara>
<informalfigure>
<ulink url="images/cypher-insertstatusupdate-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-insertstatusupdate-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-insertstatusupdate-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
</section>
<section id="cypher-cookbook-boostingrecommendations">
<title>Boosting recommendation results</title>
<figure><title>Graph</title>
<ulink url="images/cypher-boostingrecommendationresults-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-boostingrecommendationresults-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-boostingrecommendationresults-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara id="cookbook-boosting-with-properties-on-relationships">This query finds the recommended friends for the origin that are working at the same place as the origin,
or know a person that the origin knows, also, the origin should not already know the target. This recommendation is
weighted for the weight of the relationship <literal>r2</literal>, and boosted with a factor of 2, if there is an <literal>activity</literal>-property on that relationship</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (origin)-[r1:KNOWS|WORKS_AT]-(c)-[r2:KNOWS|WORKS_AT]-(candidate)
WHERE origin.name = "Clark Kent" AND type(r1)=type(r2) AND NOT (origin)-[:KNOWS]-(candidate)
RETURN origin.name AS origin, candidate.name AS candidate, SUM(ROUND(r2.weight
  +(COALESCE(r2.activity,
  0)* 2))) AS boost
ORDER BY boost DESC LIMIT 10</programlisting>
</para></formalpara>
<simpara>This returns the recommended friends for the origin nodes and their recommendation score.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="3"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><thead><row><entry align="left" valign="top">origin</entry><entry align="left" valign="top">candidate</entry><entry align="left" valign="top">boost</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col3">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Clark Kent"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Perry White"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>22</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Clark Kent"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Anderson Cooper"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>(0)
</database><command>MATCH (origin)-[r1:KNOWS|WORKS_AT]-(c)-[r2:KNOWS|WORKS_AT]-(candidate)
 WHERE origin.name = "Clark Kent"
 AND type(r1)=type(r2) AND NOT (origin)-[:KNOWS]-(candidate)
 RETURN origin.name as origin, candidate.name as candidate,
     SUM(ROUND(r2.weight + (COALESCE(r2.activity, 0) * 2))) as boost
 ORDER BY boost desc limit 10</command></para></formalpara>
</section>
<section id="cypher-cookbook-clustering-coefficient">
<title>Calculating the clustering coefficient of a network</title>
<figure><title>Graph</title>
<ulink url="images/cypher-clusteringcoefficient-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-clusteringcoefficient-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-clusteringcoefficient-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara id="cookbook-calculating-the-clustering-coefficient-of-a-friend-network">In this example, adapted from
<ulink url="http://mypetprojects.blogspot.se/2012/06/social-network-analysis-with-neo4j.html">Niko Gamulins blog post on Neo4j for Social Network Analysis</ulink>,
the graph in question is showing the 2-hop relationships of a sample person as nodes with <literal>KNOWS</literal> relationships.</simpara>
<simpara>The <ulink url="http://en.wikipedia.org/wiki/Clustering_coefficient">clustering coefficient</ulink> of a selected node is defined as the probability that two randomly selected neighbors are connected to each other.
With the number of neighbors as <literal>n</literal> and the number of mutual connections between the neighbors <literal>r</literal> the calculation is:</simpara>
<simpara>The number of possible connections between two neighbors is <literal>n!/(2!(n-2)!) = 4!/(2!(4-2)!) = 24/4 = 6</literal>,
where <literal>n</literal> is the number of neighbors <literal>n = 4</literal> and the actual number <literal>r</literal> of connections is <literal>1</literal>.
Therefore the clustering coefficient of node 1 is <literal>1/6</literal>.</simpara>
<simpara><literal>n</literal> and <literal>r</literal> are quite simple to retrieve via the following query:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a { name: "startnode" })--(b)
WITH a, count(DISTINCT b) AS n
MATCH (a)--()-[r]-()--(a)
RETURN n, count(DISTINCT r) AS r</programlisting>
</para></formalpara>
<simpara>This returns <literal>n</literal> and <literal>r</literal> for the above calculations.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">n</entry><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"startnode"})
create (_1)
create (_2)
create (_3)
create (_4)
create (_5)
create (_6)
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`KNOWS`]-&gt;_2
create _0-[:`KNOWS`]-&gt;_3
create _0-[:`KNOWS`]-&gt;_4
create _1-[:`KNOWS`]-&gt;_5
create _1-[:`KNOWS`]-&gt;_6
create _2-[:`KNOWS`]-&gt;_3
</database><command>

 MATCH (a {name: "startnode"})--(b)
 WITH a, count(distinct b) as n
 MATCH (a)--()-[r]-()--(a)
 RETURN n, count(distinct r) as r</command></para></formalpara>
</section>
<section id="cypher-cookbook-pretty-graphs">
<title>Pretty graphs</title>
<simpara>This section is showing how to create some of the <ulink url="http://en.wikipedia.org/wiki/Gallery_of_named_graphs">named pretty graphs on Wikipedia</ulink>.</simpara>
<section id="cookbook-star-graph">
<title>Star graph</title>
<simpara>The graph is created by first creating a center node, and then once per element in the range, creates a leaf node and connects it to the center.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (center)
FOREACH (x IN range(1,6)| CREATE (leaf),(center)-[:X]-&gt;(leaf))
RETURN id(center) AS id;</programlisting>
</para></formalpara>
<simpara>The query returns the id of the center node.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">id</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 7
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 6</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>7</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>(0)
</database><command>create (center)
 foreach( x in range(1,6) |
    create (leaf), (center)-[:X]-&gt;(leaf)
 )
 return id(center) as id;</command></para></formalpara>
<figure><title>Graph</title>
<ulink url="images/cypher-prettygraphsstar-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-prettygraphsstar-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-prettygraphsstar-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
<section id="cookbook-wheel-graph">
<title>Wheel graph</title>
<simpara>This graph is created in a number of steps:</simpara>
<itemizedlist>
<listitem>
<simpara>
Create a center node.
</simpara>
</listitem>
<listitem>
<simpara>
Once per element in the range, create a leaf and connect it to the center.
</simpara>
</listitem>
<listitem>
<simpara>
Connect neighboring leafs.
</simpara>
</listitem>
<listitem>
<simpara>
Find the minimum and maximum leaf and connect these.
</simpara>
</listitem>
<listitem>
<simpara>
Return the id of the center node.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (center)
FOREACH (x IN range(1,6)| CREATE (leaf { count:x }),(center)-[:X]-&gt;(leaf))
WITH center
MATCH (large_leaf)&lt;--(center)--&gt;(small_leaf)
WHERE large_leaf.count = small_leaf.count + 1
CREATE (small_leaf)-[:X]-&gt;(large_leaf)
WITH center, min(small_leaf.count) AS min, max(large_leaf.count) AS max
MATCH (first_leaf)&lt;--(center)--&gt;(last_leaf)
WHERE first_leaf.count = min AND last_leaf.count = max
CREATE (last_leaf)-[:X]-&gt;(first_leaf)
RETURN id(center) AS id</programlisting>
</para></formalpara>
<simpara>The query returns the id of the center node.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">id</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 7
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 12
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 6</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>7</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>(0)
</database><command>CREATE (center)
 foreach( x in range(1,6) |
    CREATE (leaf {count:x}), (center)-[:X]-&gt;(leaf)
 )
 WITH center
 MATCH (large_leaf)&lt;--(center)--&gt;(small_leaf)
 WHERE large_leaf.count = small_leaf.count + 1
 CREATE (small_leaf)-[:X]-&gt;(large_leaf)

 WITH center, min(small_leaf.count) as min, max(large_leaf.count) as max
 MATCH (first_leaf)&lt;--(center)--&gt;(last_leaf)
 WHERE first_leaf.count = min AND last_leaf.count = max
 CREATE (last_leaf)-[:X]-&gt;(first_leaf)

 RETURN id(center) as id</command></para></formalpara>
<figure><title>Graph</title>
<ulink url="images/cypher-prettygraphswheel-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-prettygraphswheel-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-prettygraphswheel-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
<section id="cookbook-complete-graph">
<title>Complete graph</title>
<simpara>For this graph, a root node is created, and used to hang a number
of nodes from. Then, two nodes are selected, hanging from the center, with the requirement that the
id of the first is less than the id of the next. This is to prevent double relationships and
self relationships. Using said match, relationships between all these nodes are created. Lastly,
the center node and all relationships connected to it are removed.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (center)
FOREACH (x IN range(1,6)| CREATE (leaf { count : x }),(center)-[:X]-&gt;(leaf))
WITH center
MATCH (leaf1)&lt;--(center)--&gt;(leaf2)
WHERE id(leaf1)&lt;id(leaf2)
CREATE (leaf1)-[:X]-&gt;(leaf2)
WITH center
MATCH (center)-[r]-&gt;()
DELETE center,r;</programlisting>
</para></formalpara>
<simpara>Nothing is returned by this query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 7
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 21
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 6
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes deleted: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships deleted: 6</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>(0)
</database><command>create (center)
 foreach( x in range(1,6) |
    create (leaf {count : x}), (center)-[:X]-&gt;(leaf)
 )
 WITH center
 MATCH (leaf1)&lt;--(center)--&gt;(leaf2)
 WHERE id(leaf1)&lt;id(leaf2)
 CREATE (leaf1)-[:X]-&gt;(leaf2)
 WITH center
 MATCH (center)-[r]-&gt;()
 DELETE center,r;</command></para></formalpara>
<figure><title>Graph</title>
<ulink url="images/cypher-prettygraphscompletegraph-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-prettygraphscompletegraph-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-prettygraphscompletegraph-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
<section id="cookbook-friendship-graph">
<title>Friendship graph</title>
<simpara>This query first creates a center node, and then once per element in the range, creates a cycle graph and connects it to the center</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (center)
FOREACH (x IN range(1,3)| CREATE (leaf1),(leaf2),(center)-[:X]-&gt;(leaf1),(center)-[:X]-&gt;(leaf2),
  (leaf1)-[:X]-&gt;(leaf2))
RETURN ID(center) AS id</programlisting>
</para></formalpara>
<simpara>The id of the center node is returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">id</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 7
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 9</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>7</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>(0)
</database><command>CREATE (center)
 foreach( x in range(1,3) |
    CREATE (leaf1), (leaf2), (center)-[:X]-&gt;(leaf1), (center)-[:X]-&gt;(leaf2), (leaf1)-[:X]-&gt;(leaf2)
 )
 RETURN ID(center) as id</command></para></formalpara>
<figure><title>Graph</title>
<ulink url="images/cypher-prettygraphsfriendshipgraph-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-prettygraphsfriendshipgraph-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-prettygraphsfriendshipgraph-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
</section>
<section id="cypher-cookbook-path-tree">
<title>A multilevel indexing structure (path tree)</title>
<simpara>In this example, a multi-level tree structure
is used to index event nodes (here <literal>Event1</literal>, <literal>Event2</literal> and <literal>Event3</literal>,
in this case with a YEAR-MONTH-DAY granularity, making this a timeline indexing structure.
However, this approach should work for a wide range of multi-level ranges.</simpara>
<simpara>The structure follows a couple of rules:</simpara>
<itemizedlist>
<listitem>
<simpara>
Events can be indexed multiple times by connecting the indexing structure leafs with the events via a <literal>VALUE</literal> relationship.
</simpara>
</listitem>
<listitem>
<simpara>
The querying is done in a path-range fashion. That is, the start- and end path from the indexing root to the start and end leafs in the tree are calculated
</simpara>
</listitem>
<listitem>
<simpara>
Using Cypher, the queries following different strategies can be expressed as path sections and put together using one single query.
</simpara>
</listitem>
</itemizedlist>
<simpara>The graph below depicts a structure with 3 Events being attached to an index structure at different leafs.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-pathtree-layout-path.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-pathtree-layout-path.svg"/>
  </imageobject>
  <textobject><phrase>cypher-pathtree-layout-path.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="cookbook-return-zero-range">
<title>Return zero range</title>
<simpara>Here, only the events indexed under one leaf (2010-12-31) are returned.
The query only needs one path segment <literal>rootPath</literal>  (color <literal>Green</literal>) through the index.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-pathtree-layout-zero-range.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-pathtree-layout-zero-range.svg"/>
  </imageobject>
  <textobject><phrase>cypher-pathtree-layout-zero-range.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH rootPath=(root)-[:`2010`]-&gt;()-[:`12`]-&gt;()-[:`31`]-&gt;(leaf),(leaf)-[:VALUE]-&gt;(event)
WHERE root.name = 'Root'
RETURN event.name
ORDER BY event.name ASC</programlisting>
</para></formalpara>
<simpara>Returning all events on the date 2010-12-31, in this case <literal>Event1</literal> and <literal>Event2</literal></simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">event.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Event1"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Event2"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Y11M01"})
create (_1 {`name`:"Y10M12D31"})
create (_2 {`name`:"Y10M12"})
create (_3 {`name`:"Event2"})
create (_4 {`name`:"Y11M11D02"})
create (_5 {`name`:"Y11"})
create (_6 {`name`:"Event3"})
create (_7 {`name`:"Y10"})
create (_8 {`name`:"Root"})
create (_9 {`name`:"Event1"})
create (_10 {`name`:"Y11M01D01"})
create (_11 {`name`:"Y11M12D03"})
create _0-[:`01`]-&gt;_10
create _0-[:`02`]-&gt;_4
create _0-[:`03`]-&gt;_11
create _1-[:`NEXT`]-&gt;_10
create _1-[:`VALUE`]-&gt;_9
create _1-[:`VALUE`]-&gt;_3
create _2-[:`31`]-&gt;_1
create _4-[:`NEXT`]-&gt;_11
create _5-[:`01`]-&gt;_0
create _7-[:`12`]-&gt;_2
create _8-[:`2010`]-&gt;_7
create _8-[:`2011`]-&gt;_5
create _10-[:`NEXT`]-&gt;_4
create _10-[:`VALUE`]-&gt;_3
create _11-[:`VALUE`]-&gt;_6
</database><command>
 MATCH rootPath=(root)-[:`2010`]-&gt;()-[:`12`]-&gt;()-[:`31`]-&gt;(leaf), (leaf)-[:VALUE]-&gt;(event) WHERE root.name = 'Root'RETURN event.name ORDER BY event.name ASC</command></para></formalpara>
</section>
<section id="cookbook-return-the-full-range">
<title>Return the full range</title>
<simpara>In this case, the range goes from the first to the last leaf of the index tree. Here,
<literal>startPath</literal> (color <literal>Greenyellow</literal>) and <literal>endPath</literal>  (color <literal>Green</literal>) span up the range, <literal>valuePath</literal>  (color <literal>Blue</literal>) is then connecting the leafs, and the values can
be read from the <literal>middle</literal> node, hanging off the <literal>values</literal> (color <literal>Red</literal>) path.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-pathtree-layout-full-range-path.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-pathtree-layout-full-range-path.svg"/>
  </imageobject>
  <textobject><phrase>cypher-pathtree-layout-full-range-path.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH startPath=(root)-[:`2010`]-&gt;()-[:`12`]-&gt;()-[:`31`]-&gt;(startLeaf),
  endPath=(root)-[:`2011`]-&gt;()-[:`01`]-&gt;()-[:`03`]-&gt;(endLeaf),
  valuePath=(startLeaf)-[:NEXT*0..]-&gt;(middle)-[:NEXT*0..]-&gt;(endLeaf),
  vals=(middle)-[:VALUE]-&gt;(event)
WHERE root.name = 'Root'
RETURN event.name
ORDER BY event.name ASC</programlisting>
</para></formalpara>
<simpara>Returning all events between 2010-12-31 and 2011-01-03, in this case all events.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">event.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">4 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Event1"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Event2"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Event2"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Event3"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Y11M01"})
create (_1 {`name`:"Y10M12D31"})
create (_2 {`name`:"Y10M12"})
create (_3 {`name`:"Event2"})
create (_4 {`name`:"Y11M11D02"})
create (_5 {`name`:"Y11"})
create (_6 {`name`:"Event3"})
create (_7 {`name`:"Y10"})
create (_8 {`name`:"Root"})
create (_9 {`name`:"Event1"})
create (_10 {`name`:"Y11M01D01"})
create (_11 {`name`:"Y11M12D03"})
create _0-[:`01`]-&gt;_10
create _0-[:`02`]-&gt;_4
create _0-[:`03`]-&gt;_11
create _1-[:`NEXT`]-&gt;_10
create _1-[:`VALUE`]-&gt;_9
create _1-[:`VALUE`]-&gt;_3
create _2-[:`31`]-&gt;_1
create _4-[:`NEXT`]-&gt;_11
create _5-[:`01`]-&gt;_0
create _7-[:`12`]-&gt;_2
create _8-[:`2010`]-&gt;_7
create _8-[:`2011`]-&gt;_5
create _10-[:`NEXT`]-&gt;_4
create _10-[:`VALUE`]-&gt;_3
create _11-[:`VALUE`]-&gt;_6
</database><command>
 MATCH startPath=(root)-[:`2010`]-&gt;()-[:`12`]-&gt;()-[:`31`]-&gt;(startLeaf), endPath=(root)-[:`2011`]-&gt;()-[:`01`]-&gt;()-[:`03`]-&gt;(endLeaf), valuePath=(startLeaf)-[:NEXT*0..]-&gt;(middle)-[:NEXT*0..]-&gt;(endLeaf), vals=(middle)-[:VALUE]-&gt;(event) WHERE root.name = 'Root'RETURN event.name ORDER BY event.name ASC</command></para></formalpara>
</section>
<section id="cookbook-return-partly-shared-path-ranges">
<title>Return partly shared path ranges</title>
<simpara>Here, the query range results in partly shared paths when querying the index,
making the introduction of and common path segment <literal>commonPath</literal> (color <literal>Black</literal>) necessary, before spanning up <literal>startPath</literal> (color <literal>Greenyellow</literal>) and
<literal>endPath</literal> (color <literal>Darkgreen</literal>) . After that, <literal>valuePath</literal> (color <literal>Blue</literal>) connects the leafs and the indexed values are returned off <literal>values</literal> (color <literal>Red</literal>)  path.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-pathtree-layout-shared-root-path.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-pathtree-layout-shared-root-path.svg"/>
  </imageobject>
  <textobject><phrase>cypher-pathtree-layout-shared-root-path.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH commonPath=(root)-[:`2011`]-&gt;()-[:`01`]-&gt;(commonRootEnd),
  startPath=(commonRootEnd)-[:`01`]-&gt;(startLeaf), endPath=(commonRootEnd)-[:`03`]-&gt;(endLeaf),
  valuePath=(startLeaf)-[:NEXT*0..]-&gt;(middle)-[:NEXT*0..]-&gt;(endLeaf),
  vals=(middle)-[:VALUE]-&gt;(event)
WHERE root.name = 'Root'
RETURN event.name
ORDER BY event.name ASC</programlisting>
</para></formalpara>
<simpara>Returning all events between 2011-01-01 and 2011-01-03, in this case <literal>Event2</literal> and <literal>Event3</literal>.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">event.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Event2"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Event3"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Y11M01"})
create (_1 {`name`:"Y10M12D31"})
create (_2 {`name`:"Y10M12"})
create (_3 {`name`:"Event2"})
create (_4 {`name`:"Y11M11D02"})
create (_5 {`name`:"Y11"})
create (_6 {`name`:"Event3"})
create (_7 {`name`:"Y10"})
create (_8 {`name`:"Root"})
create (_9 {`name`:"Event1"})
create (_10 {`name`:"Y11M01D01"})
create (_11 {`name`:"Y11M12D03"})
create _0-[:`01`]-&gt;_10
create _0-[:`02`]-&gt;_4
create _0-[:`03`]-&gt;_11
create _1-[:`NEXT`]-&gt;_10
create _1-[:`VALUE`]-&gt;_9
create _1-[:`VALUE`]-&gt;_3
create _2-[:`31`]-&gt;_1
create _4-[:`NEXT`]-&gt;_11
create _5-[:`01`]-&gt;_0
create _7-[:`12`]-&gt;_2
create _8-[:`2010`]-&gt;_7
create _8-[:`2011`]-&gt;_5
create _10-[:`NEXT`]-&gt;_4
create _10-[:`VALUE`]-&gt;_3
create _11-[:`VALUE`]-&gt;_6
</database><command>
 MATCH commonPath=(root)-[:`2011`]-&gt;()-[:`01`]-&gt;(commonRootEnd), startPath=(commonRootEnd)-[:`01`]-&gt;(startLeaf), endPath=(commonRootEnd)-[:`03`]-&gt;(endLeaf), valuePath=(startLeaf)-[:NEXT*0..]-&gt;(middle)-[:NEXT*0..]-&gt;(endLeaf), vals=(middle)-[:VALUE]-&gt;(event) WHERE root.name = 'Root'RETURN event.name ORDER BY event.name ASC</command></para></formalpara>
</section>
</section>
<section id="cypher-cookbook-similarity-calc">
<title>Complex similarity computations</title>
<section id="cookbook-calculate-similarities-by-complex-calculations">
<title>Calculate similarities by complex calculations</title>
<simpara>Here, a similarity between two players in a game is calculated by the number of times they have eaten the same food.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me { name: 'me' })-[r1:ATE]-&gt;(food)&lt;-[r2:ATE]-(you)
WITH me,count(DISTINCT r1) AS H1,count(DISTINCT r2) AS H2,you
MATCH (me)-[r1:ATE]-&gt;(food)&lt;-[r2:ATE]-(you)
RETURN sum((1-ABS(r1.times/H1-r2.times/H2))*(r1.times+r2.times)/(H1+H2)) AS similarity</programlisting>
</para></formalpara>
<simpara>The two players and their similarity measure.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">similarity</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>-30.0</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"me"})
create (_1 {`name`:"meat"})
create (_2 {`name`:"you"})
create _0-[:`ATE` {`times`:10}]-&gt;_1
create _2-[:`ATE` {`times`:5}]-&gt;_1
</database><command>
 MATCH (me {name: 'me'})-[r1:ATE]-&gt;(food)&lt;-[r2:ATE]-(you)
 WITH me,count(distinct r1) as H1,count(distinct r2) as H2,you
 MATCH (me)-[r1:ATE]-&gt;(food)&lt;-[r2:ATE]-(you)
 RETURN sum((1-ABS(r1.times/H1-r2.times/H2))*(r1.times+r2.times)/(H1+H2)) as similarity</command></para></formalpara>
<figure><title>Graph</title>
<ulink url="images/cypher-complexsimilarity-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-complexsimilarity-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-complexsimilarity-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
</section>
<section id="cypher-cookbook-graphity">
<title>The Graphity activity stream model</title>
<section id="cookbook-find-activity-streams-in-a-network-without-scaling-penalty">
<title>Find Activity Streams in a network without scaling penalty</title>
<simpara>This is an approach for scaling the retrieval of activity streams in a friend graph put forward by Rene Pickard as <ulink url="http://www.rene-pickhardt.de/graphity-an-efficient-graph-model-for-retrieving-the-top-k-news-feeds-for-users-in-social-networks/">Graphity</ulink>.
In short, a linked list is created for every persons friends in the order that the last activities of these friends have occured.
When new activities occur for a friend, all the ordered friend lists that this friend is part of are reordered, transferring computing load to the time of new event updates instead of activity stream reads.</simpara>
<tip><simpara>This approach of course makes excessive use of relationship types.
This needs to be taken into consideration when designing a production system with this approach.
See <xref linkend="capabilities-capacity"/> for the maximum number of relationship types.</simpara></tip>
<simpara>To find the activity stream for a person, just follow the linked list of the friend list, and retrieve the needed amount of activities form the respective activity list of the friends.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p=(me { name: 'Jane' })-[:jane_knows*]-&gt;(friend),(friend)-[:has]-&gt;(status)
RETURN me.name, friend.name, status.name, length(p)
ORDER BY length(p)</programlisting>
</para></formalpara>
<simpara>The returns the activity stream for Jane.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="4"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><colspec colname="col4"/><thead><row><entry align="left" valign="top">me.name</entry><entry align="left" valign="top">friend.name</entry><entry align="left" valign="top">status.name</entry><entry align="left" valign="top">length(p)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col4">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Jane"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Bill"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Bill_s1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Jane"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Joe"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Joe_s1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Jane"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Bob"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Bob_s1"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Bill"})
create (_1 {`name`:"Ted_s1"})
create (_2 {`name`:"Bill_s1"})
create (_3 {`name`:"Ted_s2"})
create (_4 {`name`:"Bill_s2"})
create (_5 {`name`:"Jane"})
create (_6 {`name`:"Joe_s1"})
create (_7 {`name`:"Bob"})
create (_8 {`name`:"Ted"})
create (_9 {`name`:"Joe_s2"})
create (_10 {`name`:"Bob_s1"})
create (_11 {`name`:"Joe"})
create _0-[:`has`]-&gt;_2
create _0-[:`jane_knows`]-&gt;_11
create _1-[:`next`]-&gt;_3
create _2-[:`next`]-&gt;_4
create _5-[:`jane_knows`]-&gt;_0
create _6-[:`next`]-&gt;_9
create _7-[:`has`]-&gt;_10
create _7-[:`bob_knows`]-&gt;_8
create _8-[:`has`]-&gt;_1
create _8-[:`bob_knows`]-&gt;_0
create _11-[:`has`]-&gt;_6
create _11-[:`jane_knows`]-&gt;_7
</database><command>
 MATCH p=(me {name: 'Jane'})-[:jane_knows*]-&gt;(friend), (friend)-[:has]-&gt;(status) RETURN me.name, friend.name, status.name, length(p) ORDER BY length(p)</command></para></formalpara>
<figure><title>Graph</title>
<ulink url="images/cypher-graphity-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-graphity-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-graphity-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
</section>
<section id="examples-user-roles-in-graphs">
<title>User roles in graphs</title>
<simpara>This is an example showing a hierarchy of
roles.
What&#8217;s interesting is that a tree is not sufficient for storing this kind of structure,
as elaborated below.</simpara>
<informalfigure>
<ulink url="images/roles.png">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/roles.png" width="100%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>roles.png</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>This is an implementation of an example found in the article
<ulink url="http://www.codeproject.com/Articles/22824/A-Model-to-Represent-Directed-Acyclic-Graphs-DAG-o">A Model to Represent Directed Acyclic Graphs (DAG) on SQL Databases</ulink>
by <ulink url="http://www.codeproject.com/script/Articles/MemberArticles.aspx?amid=274518">Kemal Erdogan</ulink>.
The article discusses how to store <ulink url="http://en.wikipedia.org/wiki/Directed_acyclic_graph">
directed acyclic graphs</ulink> (DAGs)
in SQL based DBs. DAGs are almost trees, but with a twist: it may be possible to reach
the same node through different paths. Trees are restricted from this possibility, which
makes them much easier to handle. In our case it is &#8220;Ali&#8221; and &#8220;Engin&#8221;,
as they are both admins and users and thus reachable through these group nodes.
Reality often looks this way and can&#8217;t be captured by tree structures.</simpara>
<simpara>In the article an SQL Stored Procedure solution is provided. The main idea,
that also have some support from scientists, is to pre-calculate all possible (transitive) paths.
Pros and cons of this approach:</simpara>
<itemizedlist>
<listitem>
<simpara>
decent performance on read
</simpara>
</listitem>
<listitem>
<simpara>
low performance on insert
</simpara>
</listitem>
<listitem>
<simpara>
wastes <emphasis>lots</emphasis> of space
</simpara>
</listitem>
<listitem>
<simpara>
relies on stored procedures
</simpara>
</listitem>
</itemizedlist>
<simpara>In Neo4j storing the roles is trivial. In this case we use <literal>PART_OF</literal> (green edges) relationships
to model the group hierarchy and <literal>MEMBER_OF</literal> (blue edges) to model membership in groups.
We also connect the top level groups to the reference node by <literal>ROOT</literal> relationships.
This gives us a useful partitioning of the graph. Neo4j has no predefined relationship
types, you are free to create any relationship types and give them the semantics you want.</simpara>
<simpara>Lets now have a look at how to retrieve information from the graph. The the queries are done using <link linkend="cypher-query-lang">Cypher</link>,
the Java code is using the Neo4j Traversal API (see <xref linkend="tutorial-traversal-java-api"/>, which is part of <xref linkend="advanced-usage"/>).</simpara>
<section id="_get_the_admins">
<title>Get the admins</title>
<simpara>In Cypher, we could get the admins like this:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH ({ name: 'Admins' })&lt;-[:PART_OF*0..]-(group)&lt;-[:MEMBER_OF]-(user)
RETURN user.name, group.name</programlisting>
<simpara>resulting in:</simpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">user.name</entry><entry align="left" valign="top">group.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Demet"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"HelpDesk"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Ali"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Admins"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Engin"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"HelpDesk"</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>And here&#8217;s the code when using the Java Traversal API:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Node admins = getNodeByName( "Admins" );
TraversalDescription traversalDescription = db.traversalDescription()
        .breadthFirst()
        .evaluator( Evaluators.excludeStartPosition() )
        .relationships( RoleRels.PART_OF, Direction.INCOMING )
        .relationships( RoleRels.MEMBER_OF, Direction.INCOMING );
Traverser traverser = traversalDescription.traverse( admins );
]]></programlisting>
<simpara>resulting in the output</simpara>
<programlisting language="plain" linenumbering="unnumbered">Found: HelpDesk at depth: 0
Found: Ali at depth: 0
Found: Engin at depth: 1
Found: Demet at depth: 1</programlisting>
<simpara>The result is collected from the traverser using this code:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[String output = "";
for ( Path path : traverser )
{
    Node node = path.endNode();
    output += "Found: " + node.getProperty( NAME ) + " at depth: "
              + ( path.length() - 1 ) + "\n";
}
]]></programlisting>
</section>
<section id="_get_the_group_memberships_of_a_user">
<title>Get the group memberships of a user</title>
<simpara>In Cypher:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH ({ name: 'Jale' })-[:MEMBER_OF]-&gt;()-[:PART_OF*0..]-&gt;(group)
RETURN group.name</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">group.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"ABCTechnicians"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Technicians"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Users"</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Using the Neo4j Java Traversal API, this query looks like:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Node jale = getNodeByName( "Jale" );
traversalDescription = db.traversalDescription()
        .depthFirst()
        .evaluator( Evaluators.excludeStartPosition() )
        .relationships( RoleRels.MEMBER_OF, Direction.OUTGOING )
        .relationships( RoleRels.PART_OF, Direction.OUTGOING );
traverser = traversalDescription.traverse( jale );
]]></programlisting>
<simpara>resulting in:</simpara>
<programlisting language="plain" linenumbering="unnumbered">Found: ABCTechnicians at depth: 0
Found: Technicians at depth: 1
Found: Users at depth: 2</programlisting>
</section>
<section id="_get_all_groups">
<title>Get all groups</title>
<simpara>In Cypher:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH ({ name: 'Reference_Node' })&lt;-[:ROOT]-&gt;()&lt;-[:PART_OF*0..]-(group)
RETURN group.name</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">group.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">6 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Users"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"ABCTechnicians"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Managers"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"HelpDesk"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Technicians"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Admins"</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>In Java:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Node referenceNode = getNodeByName( "Reference_Node") ;
traversalDescription = db.traversalDescription()
        .breadthFirst()
        .evaluator( Evaluators.excludeStartPosition() )
        .relationships( RoleRels.ROOT, Direction.INCOMING )
        .relationships( RoleRels.PART_OF, Direction.INCOMING );
traverser = traversalDescription.traverse( referenceNode );
]]></programlisting>
<simpara>resulting in:</simpara>
<programlisting language="plain" linenumbering="unnumbered">Found: Admins at depth: 0
Found: Users at depth: 0
Found: HelpDesk at depth: 1
Found: Managers at depth: 1
Found: Technicians at depth: 1
Found: ABCTechnicians at depth: 2</programlisting>
</section>
<section id="_get_all_members_of_all_groups">
<title>Get all members of all groups</title>
<simpara>Now, let&#8217;s try to find all users in the system being part of any group.</simpara>
<simpara>In Cypher, this looks like:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH ({ name: 'Reference_Node' })&lt;-[:ROOT]-&gt;(root), p=(root)&lt;-[PART_OF*0..]-()&lt;-[:MEMBER_OF]-(user)
RETURN user.name, min(length(p))
ORDER BY min(length(p)), user.name</programlisting>
<simpara>and results in the following output:</simpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">user.name</entry><entry align="left" valign="top">min(length(p))</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">10 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Ali"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Burcu"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Can"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Engin"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Demet"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Fuat"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Gul"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Hakan"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Irmak"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Jale"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>in Java:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[traversalDescription = db.traversalDescription()
        .breadthFirst()
        .evaluator(
                Evaluators.includeWhereLastRelationshipTypeIs( RoleRels.MEMBER_OF ) );
traverser = traversalDescription.traverse( referenceNode );
]]></programlisting>
<programlisting language="plain" linenumbering="unnumbered">Found: Ali at depth: 1
Found: Engin at depth: 1
Found: Burcu at depth: 1
Found: Can at depth: 1
Found: Demet at depth: 2
Found: Gul at depth: 2
Found: Fuat at depth: 2
Found: Hakan at depth: 2
Found: Irmak at depth: 2
Found: Jale at depth: 3</programlisting>
<simpara>As seen above, querying even more complex scenarios can be done using comparatively short
constructs in Cypher or Java.</simpara>
</section>
</section>
</chapter>
<chapter id="languages">
<title>Languages</title>
<simpara>Please see <ulink url="http://www.neo4j.org/drivers">http://www.neo4j.org/drivers</ulink> for the current set of drivers!</simpara>
<simpara>There&#8217;s an included Java example which shows a &#8220;low-level&#8221; approach to using the Neo4j REST API from Java.</simpara>
<section id="server-java-rest-client-example">
<title>How to use the REST API from Java</title>
<section id="_creating_a_graph_through_the_rest_api_from_java">
<title>Creating a graph through the REST API from Java</title>
<simpara>The REST API uses HTTP and JSON, so that it can be used from many languages and platforms.
Still, when geting started it&#8217;s useful to see some patterns that can be re-used.
In this brief overview, we&#8217;ll show you how to create and manipulate a simple graph through the REST API and also how to query it.</simpara>
<simpara>For these examples, we&#8217;ve chosen the <ulink url="http://jersey.java.net/">Jersey</ulink> client components,
which are easily <ulink url="http://jersey.java.net/nonav/documentation/latest/user-guide.html#chapter_deps">downloaded</ulink> via Maven.</simpara>
</section>
<section id="_start_the_server">
<title>Start the server</title>
<simpara>Before we can perform any actions on the server, we need to start it as per <xref linkend="server-installation"/>.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[WebResource resource = Client.create()
        .resource( SERVER_ROOT_URI );
ClientResponse response = resource.get( ClientResponse.class );

System.out.println( String.format( "GET on [%s], status code [%d]",
        SERVER_ROOT_URI, response.getStatus() ) );
response.close();
]]></programlisting>
<simpara>If the status of the response is <literal>200 OK</literal>, then we know the server is running fine and we can continue.
If the code fails to conenct to the server, then please have a look at <xref linkend="operations"/>.</simpara>
<note><simpara>If you get any other response than <literal>200 OK</literal> (particularly <literal>4xx</literal> or <literal>5xx</literal> responses) then please check your configuration and look in the log files in the <emphasis>data/log</emphasis> directory.</simpara></note>
</section>
<section id="_creating_a_node">
<title>Creating a node</title>
<simpara>The REST API uses <literal>POST</literal> to create nodes.
Encapsulating that in Java is straightforward using the Jersey client:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[final String nodeEntryPointUri = SERVER_ROOT_URI + "node";
// http://localhost:7474/db/data/node

WebResource resource = Client.create()
        .resource( nodeEntryPointUri );
// POST {} to the node entry point URI
ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
        .type( MediaType.APPLICATION_JSON )
        .entity( "{}" )
        .post( ClientResponse.class );

final URI location = response.getLocation();
System.out.println( String.format(
        "POST to [%s], status code [%d], location header [%s]",
        nodeEntryPointUri, response.getStatus(), location.toString() ) );
response.close();

return location;
]]></programlisting>
<simpara>If the call completes successfully, under the covers it will have sent a HTTP request containing a JSON payload to the server.
The server will then have created a new node in the database and responded with a <literal>201 Created</literal> response and a <literal>Location</literal> header with the URI of the newly created node.</simpara>
<simpara>In our example, we call this functionality twice to create two nodes in our database.</simpara>
</section>
<section id="_adding_properties">
<title>Adding properties</title>
<simpara>Once we have nodes in our datatabase, we can use them to store useful data.
In this case, we&#8217;re going to store information about music in our database.
Let&#8217;s start by looking at the code that we use to create nodes and add properties.
Here we&#8217;ve added nodes to represent "Joe Strummer" and a band called "The Clash".</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[URI firstNode = createNode();
addProperty( firstNode, "name", "Joe Strummer" );
URI secondNode = createNode();
addProperty( secondNode, "band", "The Clash" );
]]></programlisting>
<simpara>Inside the <literal>addProperty</literal> method we determine the resource that represents properties for the node and decide on a name for that property.
We then proceed to <literal>PUT</literal> the value of that property to the server.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[String propertyUri = nodeUri.toString() + "/properties/" + propertyName;
// http://localhost:7474/db/data/node/{node_id}/properties/{property_name}

WebResource resource = Client.create()
        .resource( propertyUri );
ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
        .type( MediaType.APPLICATION_JSON )
        .entity( "\"" + propertyValue + "\"" )
        .put( ClientResponse.class );

System.out.println( String.format( "PUT to [%s], status code [%d]",
        propertyUri, response.getStatus() ) );
response.close();
]]></programlisting>
<simpara>If everything goes well, we&#8217;ll get a <literal>204 No Content</literal> back indicating that the server processed the request but didn&#8217;t echo back the property value.</simpara>
</section>
<section id="_adding_relationships">
<title>Adding relationships</title>
<simpara>Now that we have nodes to represent Joe Strummer and The Clash, we can relate them.
The REST API supports this through a <literal>POST</literal> of a relationship representation to the start node of the relationship.
Correspondingly in Java we <literal>POST</literal> some JSON to the URI of our node that represents Joe Strummer,
to establish a relationship between that node and the node representing The Clash.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[URI relationshipUri = addRelationship( firstNode, secondNode, "singer",
        "{ \"from\" : \"1976\", \"until\" : \"1986\" }" );
]]></programlisting>
<simpara>Inside the <literal>addRelationship</literal> method, we determine the URI of the Joe Strummer node&#8217;s relationships, and then <literal>POST</literal> a JSON description of our intended relationship.
This description contains the destination node, a label for the relationship type, and any attributes for the relation as a
JSON collection.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[private static URI addRelationship( URI startNode, URI endNode,
        String relationshipType, String jsonAttributes )
        throws URISyntaxException
{
    URI fromUri = new URI( startNode.toString() + "/relationships" );
    String relationshipJson = generateJsonRelationship( endNode,
            relationshipType, jsonAttributes );

    WebResource resource = Client.create()
            .resource( fromUri );
    // POST JSON to the relationships URI
    ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
            .type( MediaType.APPLICATION_JSON )
            .entity( relationshipJson )
            .post( ClientResponse.class );

    final URI location = response.getLocation();
    System.out.println( String.format(
            "POST to [%s], status code [%d], location header [%s]",
            fromUri, response.getStatus(), location.toString() ) );

    response.close();
    return location;
}
]]></programlisting>
<simpara>If all goes well, we receive a <literal>201 Created</literal> status code and a <literal>Location</literal> header which contains a URI of the newly created relation.</simpara>
</section>
<section id="_add_properties_to_a_relationship">
<title>Add properties to a relationship</title>
<simpara>Like nodes, relationships can have properties.
Since we&#8217;re big fans of both Joe Strummer and the Clash, we&#8217;ll add a rating to the relationship so that others can see he&#8217;s a 5-star singer with the band.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[addMetadataToProperty( relationshipUri, "stars", "5" );
]]></programlisting>
<simpara>Inside the <literal>addMetadataToProperty</literal> method, we determine the URI of the properties of the relationship and <literal>PUT</literal> our new values (since it&#8217;s <literal>PUT</literal> it will always overwrite existing values, so be careful).</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[private static void addMetadataToProperty( URI relationshipUri,
        String name, String value ) throws URISyntaxException
{
    URI propertyUri = new URI( relationshipUri.toString() + "/properties" );
    String entity = toJsonNameValuePairCollection( name, value );
    WebResource resource = Client.create()
            .resource( propertyUri );
    ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
            .type( MediaType.APPLICATION_JSON )
            .entity( entity )
            .put( ClientResponse.class );

    System.out.println( String.format(
            "PUT [%s] to [%s], status code [%d]", entity, propertyUri,
            response.getStatus() ) );
    response.close();
}

]]></programlisting>
<simpara>Assuming all goes well, we&#8217;ll get a <literal>204 OK</literal> response back from the server (which we can check by calling
<literal>ClientResponse.getStatus()</literal>) and we&#8217;ve now established a very small graph that we can query.</simpara>
</section>
<section id="_querying_graphs">
<title>Querying graphs</title>
<simpara>As with the embedded version of the database, the Neo4j server uses graph traversals to look for data in graphs.
Currently the Neo4j server expects a JSON payload describing the traversal to be <literal>POST</literal>-ed at the starting node for the traversal (though this is <emphasis>likely to change</emphasis> in time to a <literal>GET</literal>-based approach).</simpara>
<simpara>To start this process, we use a simple class that can turn itself into the equivalent JSON, ready for <literal>POST</literal>-ing to the server, and in this case we&#8217;ve hardcoded the traverser to look for all nodes with outgoing relationships with the type <literal>"singer"</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[// TraversalDefinition turns into JSON to send to the Server
TraversalDefinition t = new TraversalDefinition();
t.setOrder( TraversalDefinition.DEPTH_FIRST );
t.setUniqueness( TraversalDefinition.NODE );
t.setMaxDepth( 10 );
t.setReturnFilter( TraversalDefinition.ALL );
t.setRelationships( new Relation( "singer", Relation.OUT ) );
]]></programlisting>
<simpara>Once we have defined the parameters of our traversal, we just need to transfer it.
We do this by determining the URI of the traversers for the start node, and then <literal>POST</literal>-ing the JSON representation
of the traverser to it.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[URI traverserUri = new URI( startNode.toString() + "/traverse/node" );
WebResource resource = Client.create()
        .resource( traverserUri );
String jsonTraverserPayload = t.toJson();
ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
        .type( MediaType.APPLICATION_JSON )
        .entity( jsonTraverserPayload )
        .post( ClientResponse.class );

System.out.println( String.format(
        "POST [%s] to [%s], status code [%d], returned data: "
                + System.getProperty( "line.separator" ) + "%s",
        jsonTraverserPayload, traverserUri, response.getStatus(),
        response.getEntity( String.class ) ) );
response.close();
]]></programlisting>
<simpara>Once that request has completed, we get back our dataset of singers and the bands they belong to:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "outgoing_relationships" : "http://localhost:7474/db/data/node/82/relationships/out",
  "data" : {
    "band" : "The Clash",
    "name" : "Joe Strummer"
  },
  "traverse" : "http://localhost:7474/db/data/node/82/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/82/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/82/properties/{key}",
  "all_relationships" : "http://localhost:7474/db/data/node/82/relationships/all",
  "self" : "http://localhost:7474/db/data/node/82",
  "properties" : "http://localhost:7474/db/data/node/82/properties",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/82/relationships/out/{-list|&amp;|types}",
  "incoming_relationships" : "http://localhost:7474/db/data/node/82/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/82/relationships/in/{-list|&amp;|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/82/relationships"
}, {
  "outgoing_relationships" : "http://localhost:7474/db/data/node/83/relationships/out",
  "data" : {
  },
  "traverse" : "http://localhost:7474/db/data/node/83/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/83/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/83/properties/{key}",
  "all_relationships" : "http://localhost:7474/db/data/node/83/relationships/all",
  "self" : "http://localhost:7474/db/data/node/83",
  "properties" : "http://localhost:7474/db/data/node/83/properties",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/83/relationships/out/{-list|&amp;|types}",
  "incoming_relationships" : "http://localhost:7474/db/data/node/83/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/83/relationships/in/{-list|&amp;|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/83/relationships"
} ]</programlisting>
</section>
<section id="_phew_is_that_it">
<title>Phew, is that it?</title>
<simpara>That&#8217;s a flavor of what we can do with the REST API.
Naturally any of the HTTP idioms we provide on the server can be easily wrapped, including removing nodes and relationships through <literal>DELETE</literal>.
Still if you&#8217;ve gotten this far, then switching <literal>.post()</literal> for <literal>.delete()</literal> in the Jersey client code should be straightforward.</simpara>
</section>
<section id="_what_8217_s_next">
<title>What&#8217;s next?</title>
<simpara>The HTTP API provides a good basis for implementers of client libraries, it&#8217;s also great for HTTP and REST folks.
In the future though we expect that idiomatic language bindings will appear to take advantage of the REST API while providing comfortable language-level constructs for developers to use, much as there are similar bindings for the embedded database.</simpara>
</section>
<section id="_appendix_the_code">
<title>Appendix: the code</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/server-examples/src/main/java/org/neo4j/examples/server/CreateSimpleGraph.java">CreateSimpleGraph.java</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/server-examples/src/main/java/org/neo4j/examples/server/Relation.java">Relation.java</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/server-examples/src/main/java/org/neo4j/examples/server/TraversalDefinition.java">TraversalDefinition.java</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
</part>
<part id="cypher-query-lang">
<title>Cypher Query Language</title>
<partintro>
<simpara>The Cypher part is the authoritative source for details on the Cypher Query Language.
For an introduction, see <xref linkend="cypher-introduction"/>.</simpara>
</partintro>
<chapter id="cypher-intro">
<title>Introduction</title>
<simpara>To get an overview of Cypher, continue reading <xref linkend="cypher-introduction"/>.
The rest of this chapter deals with the context of Cypher statements, like for example transaction management and how to use parameters.
For the Cypher language reference itself see other chapters at <xref linkend="cypher-query-lang"/>.</simpara>
<section id="cypher-introduction">
<title>What is Cypher?</title>
<section id="_introduction">
<title>Introduction</title>
<simpara><emphasis>Cypher</emphasis> is a declarative graph query language that allows for expressive and efficient querying and updating of the graph store.
Cypher is a relatively simple  but still very powerful language.
Very complicated database queries can easily be expressed through Cypher.
This allows you to focus on your domain instead of getting lost in database access.</simpara>
<simpara>Cypher is designed to be a humane query language, suitable for both developers and (importantly, we think) operations professionals.
Our guiding goal is to make the simple things easy, and the complex things possible.
Its constructs are based on English prose and neat iconography which helps to make queries more self-explanatory.
We have tried to optimize the language for reading and not for writing.</simpara>
<simpara>Being a declarative language, Cypher focuses on the clarity of expressing <emphasis>what</emphasis> to retrieve from a graph, not on <emphasis>how</emphasis> to retrieve it.
This is in contrast to imperative languages like Java, scripting languages like <ulink url="http://gremlin.tinkerpop.com">Gremlin</ulink>, and <ulink url="http://neo4j.rubyforge.org/">the JRuby Neo4j bindings</ulink>.
This approach makes query optimization an implementation detail instead of burdening the user with it and requiring her to update all traversals just because the physical database structure has changed (new indexes etc.).</simpara>
<simpara>Cypher is inspired by a number of different approaches and builds upon established practices for expressive querying.
Most of the keywords like <literal>WHERE</literal> and <literal>ORDER BY</literal> are inspired by <ulink url="http://en.wikipedia.org/wiki/SQL">SQL</ulink>.
Pattern matching borrows expression approaches from <ulink url="http://en.wikipedia.org/wiki/SPARQL">SPARQL</ulink>.
Some of the collection semantics have been borrowed from languages such as Haskell and Python.</simpara>
</section>
<section id="cypher-structure">
<title>Structure</title>
<simpara>Cypher borrows it structure from SQL&#8201;&#8212;&#8201;queries are built up using various clauses.</simpara>
<simpara>Clauses are chained together, and the they feed intermediate result sets between each other.
For example, the matching identifiers from one <literal>MATCH</literal> clause will be the context that the next clause exists in.</simpara>
<simpara>The query language is comprised of several distinct clauses.
You can read more details about them later in the manual.</simpara>
<simpara>Here are a few clauses used to read from the graph:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>MATCH</literal>: The graph pattern to match.
  This is the most common way to get data from the graph.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>WHERE</literal>: Not a clause in it’s own right, but rather part of <literal>MATCH</literal>, <literal>OPTIONAL MATCH</literal> and <literal>WITH</literal>.
  Adds constraints to a pattern, or filters the intermediate result passing through <literal>WITH</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>RETURN</literal>: What to return.
</simpara>
</listitem>
</itemizedlist>
<simpara>Let&#8217;s see <literal>MATCH</literal> and <literal>RETURN</literal> in action.</simpara>
<simpara>Imagine an example graph like the following one:</simpara>
<figure><title>Example Graph</title>
<ulink url="images/Example-Graph-cypher-intro.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Example-Graph-cypher-intro.svg"/>
  </imageobject>
  <textobject><phrase>Example-Graph-cypher-intro.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara>For example, here is a query which finds a user called John and John&#8217;s friends (though not his direct friends) before returning both John and any friends-of-friends that are found.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (john {name: 'John'})-[:friend]-&gt;()-[:friend]-&gt;(fof)
RETURN john, fof</programlisting>
<simpara>Resulting in:</simpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">john</entry><entry align="left" valign="top">fof</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"John"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Maria"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"John"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Steve"}</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Next up we will add filtering to set more parts in motion:</simpara>
<simpara>We take a list of user names and find all nodes with names from this list, match their friends and return only those followed users who have a <literal>name</literal> property starting with <literal>S</literal>.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (user)-[:friend]-&gt;(follower)
WHERE user.name IN ['Joe', 'John', 'Sara', 'Maria', 'Steve'] AND follower.name =~ 'S.*'
RETURN user, follower.name</programlisting>
<simpara>Resulting in:</simpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">user</entry><entry align="left" valign="top">follower.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"John"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Sara"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[4]{name:"Joe"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Steve"</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>And here are examples of clauses that are used to update the graph:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>CREATE</literal> (and <literal>DELETE</literal>): Create (and delete) nodes and relationships.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>SET</literal> (and <literal>REMOVE</literal>): Set values to properties and add labels on nodes using <literal>SET</literal> and use <literal>REMOVE</literal> to remove them.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>MERGE</literal>: Match existing or create new nodes and patterns. This is especially useful together with uniqueness constraints.
</simpara>
</listitem>
</itemizedlist>
<simpara>For more Cypher examples, see <xref linkend="data-modeling-examples"/> as well as the rest of the Cypher part with details on the language.
To use Cypher from Java, see <xref linkend="tutorials-cypher-java"/>.</simpara>
</section>
</section>
<section id="query-updating">
<title>Updating the graph</title>
<simpara>Cypher can be used for both querying and updating your graph.</simpara>
<section id="query-updating-structure">
<title>The Structure of Updating Queries</title>
<sidebar>
<title>Quick info</title>
<itemizedlist>
<listitem>
<simpara>
A Cypher query part can&#8217;t both match and update the graph at the same time.
</simpara>
</listitem>
<listitem>
<simpara>
Every part can either read and match on the graph, or make updates on it.
</simpara>
</listitem>
</itemizedlist>
</sidebar>
<simpara>If you read from the graph, and then update the graph, your query implicitly has two parts&#8201;&#8212;&#8201;the reading is the first
part, and the writing is the second. If your query is read-only, Cypher will be lazy, and not actually match the pattern
until you ask for the results. In an updating query, the semantics are that <emphasis>all</emphasis> the reading will be done before any
writing actually happens.
First reading, and then writing, is the only pattern where the query parts are implicit&#8201;&#8212;&#8201;any other order and you
have to be explicit about your query parts. The parts are separated using the <literal>WITH</literal> statement. <literal>WITH</literal> is like the event
horizon&#8201;&#8212;&#8201;it&#8217;s a barrier between a plan and the finished execution of that plan.</simpara>
<simpara>When you want to filter using aggregated data, you have to chain together two reading query parts&#8201;&#8212;&#8201;the first one does the
aggregating, and the second query filters on the results coming from the first one.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n {name: 'John'})-[:FRIEND]-friend
WITH n, count(friend) as friendsCount
WHERE friendsCount &gt; 3
RETURN n, friendsCount</programlisting>
<simpara>Using <literal>WITH</literal>, you specify how you want the aggregation to happen, and that the aggregation has to be finished before
Cypher can start filtering.</simpara>
<simpara>You can chain together as many query parts as you have JVM heap for.</simpara>
</section>
<section id="query-updating-return">
<title>Returning data</title>
<simpara>Any query can return data. If your query only reads, it has to return data&#8201;&#8212;&#8201;it serves no purpose if it doesn&#8217;t, and
 it is not a valid Cypher query. Queries that update the graph don&#8217;t have to return anything, but they can.</simpara>
<simpara>After all the parts of the query comes one final <literal>RETURN</literal> clause. <literal>RETURN</literal> is not part of any query part&#8201;&#8212;&#8201;it
is a period symbol at the end of a query. The <literal>RETURN</literal> clause has three sub-clauses that come with it <literal>SKIP</literal>/<literal>LIMIT</literal> and <literal>ORDER BY</literal>.</simpara>
<simpara>If you return graph elements from a query that has just deleted them&#8201;&#8212;&#8201;beware, you are holding a pointer that is no
 longer valid. Operations on that node might fail mysteriously and unpredictably.</simpara>
</section>
</section>
<section id="query-transactions">
<title>Transactions</title>
<simpara>Any query that updates the graph will run in a transaction.
An updating query will always either fully succeed, or not succeed at all.</simpara>
<simpara>Cypher will either create a new transaction or run inside an existing one:</simpara>
<itemizedlist>
<listitem>
<simpara>
If no transaction exists in the running context Cypher will create one and commit it once the query finishes.
</simpara>
</listitem>
<listitem>
<simpara>
In case there already exists a transaction in the running context, the query will run inside it, and nothing will be persisted to disk until that transaction is successfully committed.
</simpara>
</listitem>
</itemizedlist>
<simpara>This can be used to have multiple queries be committed as a single transaction:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Open a transaction,
</simpara>
</listitem>
<listitem>
<simpara>
run multiple updating Cypher queries,
</simpara>
</listitem>
<listitem>
<simpara>
and commit all of them in one go.
</simpara>
</listitem>
</orderedlist>
<simpara>Note that a query will hold the changes in memory until the whole query has finished executing.
A large query will consequently need a JVM with lots of heap space.</simpara>
<simpara>For using transactions over the REST API, see <xref linkend="rest-api-transactional"/>.</simpara>
<simpara>When using Neo4j embedded, remember all iterators returned from an execution result should be exhausted fully to ensure that resources bound to them will be properly closed.
Resources include transactions started by the query, so failing to do so may, for example, lead to deadlocks or other weird behavior.</simpara>
</section>
<section id="cypherdoc-uniqueness">
<title>Uniqueness</title>
<simpara>While pattern matching, Cypher makes sure to not include matches where the same graph relationship is found multiple times in a single pattern.
In most use cases, this is a sensible thing to do.</simpara>
<simpara>Example: looking for a user&#8217;s friends of friends should not return said user.</simpara>
<simpara>Let&#8217;s create a few nodes and relationships:</simpara>
<simpara role="setup-query"></simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (adam:User { name: 'Adam' }),(pernilla:User { name: 'Pernilla' }),(david:User { name: 'David'
  }),
  (adam)-[:FRIEND]-&gt;(pernilla),(pernilla)-[:FRIEND]-&gt;(david)</programlisting>
<simpara>Which gives us the following graph:</simpara>
<informalfigure>
<ulink url="images/cypherdoc--13303421.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypherdoc--13303421.svg"/>
  </imageobject>
  <textobject><phrase>cypherdoc--13303421.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara role="cypherdoc-console"></simpara>
<simpara>Now let&#8217;s look for friends of friends of Adam:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (user:User { name: 'Adam' })-[r1:FRIEND]-()-[r2:FRIEND]-(friend_of_a_friend)
RETURN friend_of_a_friend</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">friend_of_a_friend</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"David"}</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>In this query, Cypher makes sure to not return matches where the pattern relationships <literal>r1</literal> and <literal>r2</literal> point to the same graph relationship.</simpara>
<simpara>This is however not always desired.
If the query should return the user, it is possible to spread the matching over multiple <literal>MATCH</literal> clauses, like so:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (user:User { name: 'Adam' })-[r1:FRIEND]-(friend)
WITH friend
MATCH (friend)-[r2:FRIEND]-(friend_of_a_friend)
RETURN friend_of_a_friend</programlisting>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">friend_of_a_friend</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"David"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Adam"}</literal></simpara></entry></row></tbody></tgroup></informaltable>
</section>
<section id="cypher-parameters">
<title>Parameters</title>
<simpara>Cypher supports querying with parameters.
This means developers don&#8217;t have to resort to string building to create a query.
In addition to that, it also makes caching of execution plans much easier for Cypher.</simpara>
<simpara>Parameters can be used for literals and expressions in the <literal>WHERE</literal> clause, for the index value in the <literal>START</literal> clause, index queries, and finally for node/relationship ids.
Parameters can not be used as for property names, relationship types and labels, since these patterns are part of the query structure that is compiled into a query plan.</simpara>
<simpara>Accepted names for parameters are letters and numbers, and any combination of these.</simpara>
<simpara>For details on parameters when using the Neo4j embedded Java API, see <xref linkend="tutorials-cypher-parameters-java"/>.
For details on using parameters via the Neo4j REST API, see <xref linkend="rest-api-cypher"/>.</simpara>
<simpara>Below follows a comprehensive set of examples of parameter usage.
The parameters are given as JSON here.
Exactly how to submit them depends on the driver in use.</simpara>
<section id="_string_literal">
<title>String literal</title>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "name" : "Johan"
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.name = { name }
RETURN n</programlisting>
</para></formalpara>
</section>
<section id="_regular_expression">
<title>Regular expression</title>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "regex" : ".*h.*"
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.name =~ { regex }
RETURN n.name</programlisting>
</para></formalpara>
</section>
<section id="_create_node_with_properties">
<title>Create node with properties</title>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "props" : {
    "position" : "Developer",
    "name" : "Andres"
  }
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE ({ props })</programlisting>
</para></formalpara>
</section>
<section id="_create_multiple_nodes_with_properties">
<title>Create multiple nodes with properties</title>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "props" : [ {
    "position" : "Developer",
    "awesome" : true,
    "name" : "Andres"
  }, {
    "position" : "Developer",
    "name" : "Michael",
    "children" : 3
  } ]
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (n:Person { props })
RETURN n</programlisting>
</para></formalpara>
</section>
<section id="_setting_all_properties_on_node">
<title>Setting all properties on node</title>
<simpara>Note that this will replace all the current properties.</simpara>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "props" : {
    "position" : "Developer",
    "name" : "Andres"
  }
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.name='Michaela'
SET n = { props }</programlisting>
</para></formalpara>
</section>
<section id="_skip_and_limit">
<title>SKIP and LIMIT</title>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "s" : 1,
  "l" : 1
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
RETURN n.name
SKIP { s }
LIMIT { l }</programlisting>
</para></formalpara>
</section>
<section id="_node_id">
<title>Node id</title>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "id" : 0
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START n=node({ id })
RETURN n.name</programlisting>
</para></formalpara>
</section>
<section id="_multiple_node_ids">
<title>Multiple node ids</title>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "id" : [ 0, 1, 2 ]
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START n=node({ id })
RETURN n.name</programlisting>
</para></formalpara>
</section>
<section id="_index_value_legacy_indexes">
<title>Index value (legacy indexes)</title>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "value" : "Michaela"
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START n=node:people(name = { value })
RETURN n</programlisting>
</para></formalpara>
</section>
<section id="_index_query_legacy_indexes">
<title>Index query (legacy indexes)</title>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "query" : "name:Andreas"
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START n=node:people({ query })
RETURN n</programlisting>
</para></formalpara>
</section>
</section>
<section id="cypher-compatibility">
<title>Compatibility</title>
<simpara>Cypher is still changing rather rapidly.
Parts of the changes are internal&#8201;&#8212;&#8201;we add new pattern matchers, aggregators and other optimizations, which hopefully makes your queries run faster.</simpara>
<simpara>Other changes are directly visible to our users&#8201;&#8212;&#8201;the syntax is still changing.
New concepts are being added and old ones changed to fit into new possibilities.
To guard you from having to keep up with our syntax changes, Cypher allows you to use an older parser, but still gain the speed from new optimizations.</simpara>
<simpara>There are two ways you can select which parser to use.
You can configure your database with the configuration parameter <literal>cypher_parser_version</literal>, and enter which parser you&#8217;d like to use (<literal>1.9</literal>, <literal>2.0</literal> are supported now).
Any Cypher query that doesn&#8217;t explicitly say anything else, will get the parser you have configured.</simpara>
<simpara>The other way is on a query by query basis.
By simply putting <literal>"CYPHER 1.9"</literal> at the beginning, that particular query will be parsed with the 1.9 version of the parser.
Example:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CYPHER 1.9 START n=node(0)
WHERE n.foo = "bar"
RETURN n</programlisting>
</section>
<section id="query-plans">
<title>Query Performance</title>
<simpara>Cypher works very hard to execute queries as fast as possible.</simpara>
<simpara>However, when optimizing for maximum query execution performance, it may be helpful to rephrase queries using knowledge about the domain and the application.</simpara>
<simpara>The overall goal of manual query performance optimization is to ensure that only necessary data is retrieved from the
graph.
At least data should get filtered out as early as possible in order to reduce the amount of work that has to be done at later stages of query execution.
This also goes for what gets returned: avoid returning whole nodes and relationships&#8201;&#8212;&#8201;instead, pick the data you need and return only that.
You should also make sure to set an upper limit on variable length patterns, so they don&#8217;t cover larger portions of the dataset than needed.</simpara>
<simpara>Each Cypher query gets optimized and transformed into an execution plan by the Cypher execution engine.
To minimize the resources used for this, make sure to use parameters instead of literals when possible.
This allows Cypher to re-use your queries instead of having to parse and build new execution plans.</simpara>
<note><simpara>When Cypher is building execution plans, it looks at the schema to see if it can find useful indexes.
These index decisions are only valid until the schema changes, so adding or removing indexes leads to the execution plan cache being flushed.</simpara></note>
</section>
</chapter>
<chapter id="query-syntax">
<title>Syntax</title>
<simpara>The nitty-gritty details of Cypher syntax.</simpara>
<section id="cypher-values">
<title>Values</title>
<simpara>Cypher queries the graph by looking at nodes, relationships, properties and query parameters.
All values that are handled by Cypher have a distinct type.
The supported types of values are:</simpara>
<itemizedlist>
<listitem>
<simpara>
Numeric values,
</simpara>
</listitem>
<listitem>
<simpara>
String values,
</simpara>
</listitem>
<listitem>
<simpara>
Boolean values,
</simpara>
</listitem>
<listitem>
<simpara>
Nodes,
</simpara>
</listitem>
<listitem>
<simpara>
Relationships,
</simpara>
</listitem>
<listitem>
<simpara>
Paths,
</simpara>
</listitem>
<listitem>
<simpara>
Maps from Strings to other values,
</simpara>
</listitem>
<listitem>
<simpara>
Collections of any other type of value.
</simpara>
</listitem>
</itemizedlist>
<simpara>Most types of values can be constructed in a query using literal expressions (see <xref linkend="cypher-expressions"/>).
Special care must be taken when using <literal>NULL</literal>, as <literal>NULL</literal> is a value of every type (see <xref linkend="cypher-working-with-null"/>).
Nodes, relationships, and paths are returned as a result of pattern matching.</simpara>
<simpara>Note that labels are not values but are a form of pattern syntax.</simpara>
</section>
<section id="cypher-expressions">
<title>Expressions</title>
<section id="_expressions_in_general">
<title>Expressions in general</title>
<simpara>An expression in Cypher can be:</simpara>
<itemizedlist>
<listitem>
<simpara>
A numeric literal (integer or double): <literal>13</literal>, <literal>40000</literal>, <literal>3.14</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
A string literal: <literal>"Hello"</literal>, <literal>'World'</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
A boolean literal:  <literal>true</literal>, <literal>false</literal>, <literal>TRUE</literal>, <literal>FALSE</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
An identifier: <literal>n</literal>, <literal>x</literal>, <literal>rel</literal>, <literal>myFancyIdentifier</literal>, <literal>`A name with weird stuff in it[]!`</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
A property: <literal>n.prop</literal>, <literal>x.prop</literal>, <literal>rel.thisProperty</literal>, <literal>myFancyIdentifier.`(weird property name)`</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
A parameter: <literal>{param}</literal>, <literal>{0}</literal>
</simpara>
</listitem>
<listitem>
<simpara>
A collection of expressions: <literal>["a", "b"]</literal>, <literal>[1,2,3]</literal>, <literal>["a", 2, n.property, {param}]</literal>, <literal>[ ]</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
A function call: <literal>length(p)</literal>, <literal>nodes(p)</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
An aggregate function: <literal>avg(x.prop)</literal>, <literal>count(*)</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
A path-pattern: <literal>(a)--&gt;()&lt;--(b)</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
An operator application: <literal>1 + 2</literal> and <literal>3 &lt; 4</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
A predicate expression is an expression that returns true or false: <literal>a.prop = "Hello"</literal>, <literal>length(p) &gt; 10</literal>,
<literal>has(a.name)</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
A <literal>CASE</literal> expression.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_note_on_string_literals">
<title>Note on string literals</title>
<simpara>String literals can contain these escape sequences.</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<?dbhtml table-width="50%"?>
<?dbfo table-width="50%"?>
<?dblatex table-width="50%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="71*"/>
<colspec colname="col_2" colwidth="142*"/>
<thead>
<row>
<entry align="right" valign="top">Escape sequence</entry>
<entry align="left" valign="top">Character</entry>
</row>
</thead>
<tbody>
<row>
<entry align="right" valign="top"><simpara><literal>\t</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Tab</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><literal>\b</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Backspace</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><literal>\n</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Newline</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><literal>\r</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Carriage return</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><literal>\f</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Form feed</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><literal>\'</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Single quote</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><literal>\"</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Double quote</simpara></entry>
</row>
<row>
<entry align="right" valign="top"><simpara><literal>\\</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Backslash</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="query-syntax-case">
<title>Case Expressions</title>
<simpara>Cypher supports <literal>CASE</literal> expressions, which is a generic conditional expression, similar to if/else statements in other languages.
Two variants of <literal>CASE</literal> exist&#8201;&#8212;&#8201;the simple form and the generic form.</simpara>
</section>
<section id="syntax-simple-case">
<title>Simple CASE</title>
<simpara>The expression is calculated, and compared in order with the <literal>WHEN</literal> clauses until a match is found. If no match is found the expression in the <literal>ELSE</literal> clause is used, or null, if no <literal>ELSE</literal> case exists.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<programlisting language="cypher" linenumbering="unnumbered">CASE test
WHEN value THEN result
[WHEN ...]
[ELSE default]
END</programlisting>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expr:</emphasis> A valid expression.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>value:</emphasis> An expression whose result will be compared to the <literal>test</literal> expression.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>result:</emphasis> This is the result expression used if the value expression matches the <literal>test</literal> expression.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>default:</emphasis> The expression to use if no match is found.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH n
RETURN CASE n.eyes
WHEN 'blue'
THEN 1
WHEN 'brown'
THEN 2
ELSE 3 END AS result</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">result</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">5 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match n return CASE n.eyes
     WHEN 'blue'  THEN 1
     WHEN 'brown' THEN 2
                  ELSE 3
 END as result</command></para></formalpara>
</section>
<section id="syntax-generic-case">
<title>Generic CASE</title>
<simpara>The predicates are evaluated in order until a true value is found, and the result value is used. If no match is found the expression in the <literal>ELSE</literal> clause is used, or <literal>null</literal>, if no <literal>ELSE</literal> case exists.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<programlisting language="cypher" linenumbering="unnumbered">CASE
WHEN predicate THEN result
[WHEN ...]
[ELSE default]
END</programlisting>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>predicate:</emphasis> A predicate that is tested to find a valid alternative.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>result:</emphasis> This is the result expression used if the predicate matches.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>default:</emphasis> The expression to use if no match is found.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH n
RETURN CASE
    WHEN n.eyes = 'blue'
THEN 1
WHEN n.age &lt; 40
THEN 2
ELSE 3 END AS result</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">result</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">5 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match n return CASE
     WHEN n.eyes = 'blue'  THEN 1
     WHEN n.age &lt; 40       THEN 2
                           ELSE 3
 END as result</command></para></formalpara>
</section>
</section>
<section id="cypher-identifiers">
<title>Identifiers</title>
<simpara>When you reference parts of a pattern or a query, you do so by naming them.
The names you give the different parts are called identifiers.</simpara>
<simpara>In this example:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)--&gt;(b) RETURN b</programlisting>
<simpara>The identifiers are <literal>n</literal> and <literal>b</literal>.</simpara>
<simpara>Identifier names are case sensitive, and can contain underscores and alphanumeric characters (a-z, 0-9), but must
always start with a letter.
If other characters are needed, you can quote the identifier using backquote (<literal>`</literal>) signs.</simpara>
<simpara>The same rules apply to property names.</simpara>
</section>
<section id="query-operators">
<title>Operators</title>
<section id="query-operators-mathematical">
<title>Mathematical operators</title>
<simpara>The mathematical operators are <literal>+</literal>, <literal>-</literal>, <literal>*</literal>, <literal>/</literal> and <literal>%</literal>, <literal>^</literal>.</simpara>
</section>
<section id="query-operators-comparison">
<title>Comparison operators</title>
<simpara>The comparison operators are <literal>=</literal>, <literal>&lt;&gt;</literal>, <literal>&lt;</literal>, <literal>&gt;</literal>, <literal>&lt;=</literal>, <literal>&gt;=</literal>, <literal>IS NULL</literal>, and <literal>IS NOT NULL</literal>.
See <xref linkend="cypher-comparison"/> on how they behave.</simpara>
</section>
<section id="query-operators-boolean">
<title>Boolean operators</title>
<simpara>The boolean operators are <literal>AND</literal>, <literal>OR</literal>, <literal>XOR</literal>, <literal>NOT</literal>.</simpara>
</section>
<section id="query-operators-string">
<title>String operators</title>
<simpara>Strings can be concatenated using the <literal>+</literal> operator.</simpara>
</section>
<section id="query-operators-collection">
<title>Collection operators</title>
<simpara>Collections can be concatenated using the <literal>+</literal> operator.
To check if an element exists in a collection, you can use the <literal>IN</literal> operator.</simpara>
</section>
<section id="query-operators-property">
<title>Property operators</title>
<note><simpara>Since version 2.0, the previously existing property operators <literal>?</literal> and <literal>!</literal> have been removed.
This syntax is no longer supported.
Missing properties are now returned as <literal>NULL</literal>.
Please use <literal>(NOT(has(&lt;ident&gt;.prop)) OR &lt;ident&gt;.prop=&lt;value&gt;)</literal> if you really need the old behavior of the <literal>?</literal> operator.&#8201;&#8212;&#8201;Also, the use of <literal>?</literal> for optional relationships has been removed in favor of the newly introduced <literal>OPTIONAL MATCH</literal> clause.</simpara></note>
</section>
<section id="cypher-comparison">
<title>Equality and Comparison of Values</title>
<section id="_equality">
<title>Equality</title>
<simpara>Cypher supports comparing values (see <xref linkend="cypher-values"/>) by equality using the <literal>=</literal> and <literal>&lt;&gt;</literal> operators.</simpara>
<simpara>Values of the same type are only equal if they are the same identical value (e.g. <literal>3 = 3</literal> and <literal>"x" &lt;&gt; "xy"</literal>).</simpara>
<simpara>Maps are only equal if they map exactly the same keys to equal values and collections are only equal if they contain the same sequence of equal values (e.g. <literal>[3, 4] = [1+2, 8/2]</literal>).</simpara>
<simpara>Values of different types are considered as equal according to the following rules:</simpara>
<itemizedlist>
<listitem>
<simpara>
Paths are treated as collections of alternating nodes and relationships and are equal to all collections that contain that very same sequence of nodes and relationships.
</simpara>
</listitem>
<listitem>
<simpara>
Testing any value against <literal>NULL</literal> with both the <literal>=</literal> and the <literal>&lt;&gt;</literal> operators always is <literal>NULL</literal>.
This includes <literal>NULL = NULL</literal> and <literal>NULL &lt;&gt; NULL</literal>.
The only way to reliably test if a value <literal>v</literal> is  <literal>NULL</literal> is by using the special <literal>v IS NULL</literal>, or <literal>v IS NOT NULL</literal> equality operators.
</simpara>
</listitem>
</itemizedlist>
<simpara>All other combinations of types of values cannot be compared with each other.
Especially, nodes, relationships, and literal maps are incomparable with each other.</simpara>
<simpara>It is an error to compare values that cannot be compared.</simpara>
</section>
</section>
<section id="cypher-ordering">
<title>Ordering and Comparison of Values</title>
<simpara>The comparison operators <literal>&lt;=</literal> (for ascending) and <literal>&gt;=</literal> (for descending) are used to compare values for ordering.
The following points give some details on how the comparison is performed.</simpara>
<itemizedlist>
<listitem>
<simpara>
Numerical values are compared for ordering using numerical order (e.g. <literal>3 &lt; 4</literal> is true).
</simpara>
</listitem>
<listitem>
<simpara>
String values are compared for ordering using lexicographic order (e.g. <literal>"x" &lt; "xy"</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
Boolean values are compared for ordering such that <literal>false &lt; true</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Comparing for ordering when one argument is <literal>NULL</literal> is <literal>NULL</literal> (e.g. <literal>NULL &lt; 3</literal> is <literal>NULL</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
It is an error to compare other types of values with each other for ordering.
</simpara>
</listitem>
</itemizedlist>
<simpara>For other comparison operators, see <xref linkend="query-operators-comparison"/>.</simpara>
</section>
</section>
<section id="cypher-comments">
<title>Comments</title>
<simpara>To add comments to your queries, use double slash. Examples:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n) RETURN n //This is an end of line comment</programlisting>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
//This is a whole line comment
RETURN n</programlisting>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n) WHERE n.property = "//This is NOT a comment" RETURN n</programlisting>
</section>
<section id="introduction-pattern">
<title>Patterns</title>
<simpara>Patterns and pattern-matching are at the very heart of Cypher, so being effective with Cypher requires a good understanding of patterns.</simpara>
<simpara>Using patterns, you describe the shape of the data you&#8217;re looking for. For example, in the <literal>MATCH</literal> clause you describe the shape with a pattern, and Cypher will figure out how to get that data for you.</simpara>
<simpara>The pattern describes the data using a form that is very similar to how one typically draws the shape of property graph data on a whiteboard: usually as circles (representing nodes) and arrows between them to represent relationships.</simpara>
<simpara>Patterns appear in multiple places in Cypher: in <literal>MATCH</literal>, <literal>CREATE</literal> and <literal>MERGE</literal> clauses, and in pattern expressions. Each of these
is described in more details in:</simpara>
<itemizedlist>
<listitem>
<simpara>
<xref linkend="query-match"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="query-optional-match"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="query-create"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="query-merge"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="query-where-patterns"/>
</simpara>
</listitem>
</itemizedlist>
<section id="_patterns_for_nodes">
<title>Patterns for nodes</title>
<simpara>The very simplest &#8220;shape&#8221; that can be described in a pattern is a node. A node is described using a pair of parentheses, and is typically given a name.
For example:</simpara>
<simpara><literal><literal>(a)</literal></literal></simpara>
<simpara>This simple pattern describes a single node, and names that node using the identifier <literal>a</literal>.</simpara>
<simpara>Note that the parentheses may be omitted, but only when there are no labels or properties specified for the node pattern.</simpara>
</section>
<section id="_patterns_for_related_nodes">
<title>Patterns for related nodes</title>
<simpara>More interesting is patterns that describe multiple nodes and relationships between them.
Cypher patterns describe relationships by employing an arrow between two nodes.
For example:</simpara>
<simpara><literal><literal>(a)--&gt;(b)</literal></literal></simpara>
<simpara>This pattern describes a very simple data shape: two nodes, and a single relationship from one to the other.
In this example, the two nodes are both named as <literal>a</literal> and <literal>b</literal> respectively, and the relationship is &#8220;directed&#8221;: it goes from <literal>a</literal> to <literal>b</literal>.</simpara>
<simpara>This way of describing nodes and relationships can be extended to cover an arbitrary number of nodes and the relationships between them, for example:</simpara>
<simpara><literal><literal>(a)--&gt;(b)&lt;--(c)</literal></literal></simpara>
<simpara>Such a series of connected nodes and relationships is called a "path".</simpara>
<simpara>Note that the naming of the nodes in these patterns is only necessary should one need to refer to the same node again, either later in the pattern or elsewhere in the Cypher query.
If this is not necessary then the name may be omitted, like so:</simpara>
<simpara><literal><literal>(a)--&gt;()&lt;--(c)</literal></literal></simpara>
</section>
<section id="_labels">
<title>Labels</title>
<simpara>In addition to simply describing the shape of a node in the pattern, one can also describe attributes.
The most simple attribute that can be described in the pattern is a label that the node must have.
For example:</simpara>
<simpara><literal><literal>(a:User)--&gt;(b)</literal></literal></simpara>
<simpara>One can also describe a node that has multiple labels:</simpara>
<simpara><literal><literal>(a:User:Admin)--&gt;(b)</literal></literal></simpara>
</section>
<section id="_specifying_properties">
<title>Specifying properties</title>
<simpara>Nodes and relationships are the fundamental structures in a graph. Neo4j uses properties on both of these to allow for far richer models.</simpara>
<simpara>Properties can be expressed in patterns using a map-construct: curly brackets surrounding a number of key-expression pairs, separated by commas.
E.g. a node with two properties on it would look like:
<literal><literal>(a { name: "Andres", sport: "Brazilian Ju-Jitsu" })</literal>.</literal></simpara>
<simpara>A relationship with expectations on it would could look like:
<literal><literal>(a)-[{blocked: false}]-&gt;(b)</literal>.</literal></simpara>
<simpara>When properties appear in patterns, they add an additional constraint to the shape of the data.
In the case of a <literal>CREATE</literal> clause, the properties will be set in the newly created nodes and relationships.
In the case of a <literal>MERGE</literal> clause, the properties will be used as additional constraints on the shape any existing data must have (the specified properties must exactly match any existing data in the graph).
If no matching data is found, then <literal>MERGE</literal> behaves like <literal>CREATE</literal> and the properties will be set in the newly created nodes and relationships.</simpara>
<simpara>Note that patterns supplied to <literal>CREATE</literal> may use a single parameter to specify properties, e.g: <literal>CREATE (node {paramName})</literal>.
This is not possible with patterns used in other clauses, as Cypher needs to know the property names at the time the query is compiled, so that matching can be done effectively.</simpara>
</section>
<section id="_describing_relationships">
<title>Describing relationships</title>
<simpara>The simplest way to describe a relationship is by using the arrow between two nodes, as in the previous examples.
Using this technique, you can describe that the relationship should exist and the directionality of it.
If you don&#8217;t care about the direction of the relationship, the arrow head can be omitted, like so:</simpara>
<simpara><literal><literal>(a)--(b)</literal></literal></simpara>
<simpara>As with nodes, relationships may also be given names.
In this case, a pair of square brackets is used to break up the arrow and the identifier is placed between.
For example:</simpara>
<simpara><literal><literal>(a)-[r]-&gt;(b)</literal></literal></simpara>
<simpara>Much like labels on nodes, relationships can have types.
To describe a relationship with a specific type, you can specify this like so:</simpara>
<simpara><literal><literal>(a)-[r:REL_TYPE]-&gt;(b)</literal></literal></simpara>
<simpara>Unlike labels, relationships can only have one type.
But if we&#8217;d like to describe some data such that the relationship could have any one of a set of types, then they can all be listed in the pattern, separating them with the pipe symbol <literal>|</literal> like this:</simpara>
<simpara><literal><literal>(a)-[r:TYPE1|TYPE2]-&gt;(b)</literal></literal></simpara>
<simpara>Note that this form of pattern can only be used to describe existing data (ie. when using a pattern with <literal>MATCH</literal> or as an expression).
It will not work with <literal>CREATE</literal> or <literal>MERGE</literal>, since it&#8217;s not possible to create a relationship with multiple types.</simpara>
<simpara>As with nodes, the name of the relationship can always be omitted, in this case like so:</simpara>
<simpara><literal><literal>(a)-[:REL_TYPE]-&gt;(b)</literal></literal></simpara>
<section id="_variable_length">
<title>Variable length</title>
<simpara>Rather than describing a long path using a sequence of many node and relationship descriptions in a pattern, many relationships (and the intermediate nodes) can be described by specifying a length in the relationship description of a pattern.
For example:</simpara>
<simpara><literal><literal>(a)-[*2]-&gt;(b)</literal></literal></simpara>
<simpara>This describes a graph of three nodes and two relationship, all in one path (a path of length 2).
This is equivalent to:</simpara>
<simpara><literal><literal>(a)--&gt;()--&gt;(b)</literal></literal></simpara>
<simpara>A range of lengths can also be specified: such relationship patterns are called &#8220;variable length relationships&#8221;.
For example:</simpara>
<simpara><literal><literal>(a)-[*3..5]-&gt;(b)</literal></literal></simpara>
<simpara>This is a minimum length of 3, and a maximum of 5.
It describes a graph of either 4 nodes and 3 relationships, 5 nodes and 4 relationships or 6 nodes and 5 relationships, all connected together in a single path.</simpara>
<simpara>Either bound can be omitted. For example, to describe paths of length 3 or more, use:</simpara>
<simpara><literal><literal>(a)-[*3..]-&gt;(b)</literal></literal></simpara>
<simpara>And to describe paths of length 5 or less, use:</simpara>
<simpara><literal><literal>(a)-[*..5]-&gt;(b)</literal></literal></simpara>
<simpara>Both bounds can be omitted, allowing paths of any length to be described:</simpara>
<simpara><literal><literal>(a)-[*]-&gt;(b)</literal></literal></simpara>
<simpara>As a simple example, let&#8217;s take the query below:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me)-[:KNOWS*1..2]-(remote_friend)
WHERE me.name = "Filipa"
RETURN remote_friend.name</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">remote_friend.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Dilshad"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Anders"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Dilshad"})
create (_1 {`name`:"Emil"})
create (_2 {`name`:"Filipa"})
create (_3 {`name`:"Anders"})
create (_4 {`name`:"Becky"})
create (_5 {`name`:"Cesar"})
create _0-[:`KNOWS`]-&gt;_2
create _3-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_5
create _3-[:`KNOWS`]-&gt;_0
create _4-[:`KNOWS`]-&gt;_1
create _5-[:`KNOWS`]-&gt;_1
</database><command>
 MATCH (me)-[:KNOWS*1..2]-(remote_friend)
 WHERE me.name = "Filipa"
 RETURN remote_friend.name</command></para></formalpara>
<simpara>This query finds data in the graph which a shape that fits the pattern: specifically a node (with the name property <literal>Filipa</literal>) and then the <literal>KNOWS</literal> related nodes, one or two steps out.
This is a typical example of finding first and second degree friends.</simpara>
<simpara>Note that variable length relationships can not be used with <literal>CREATE</literal> and <literal>MERGE</literal>.</simpara>
</section>
</section>
<section id="_assigning_to_path_identifiers">
<title>Assigning to path identifiers</title>
<simpara>As described above, a series of connected nodes and relationships is called a "path". Cypher allows paths to be named
using an identifer, like so:</simpara>
<simpara><literal><literal>p = (a)-[*3..5]-&gt;(b)</literal></literal></simpara>
<simpara>You can do this in <literal>MATCH</literal>, <literal>CREATE</literal> and <literal>MERGE</literal>, but not when using patterns as expressions.</simpara>
</section>
</section>
<section id="syntax-collections">
<title>Collections</title>
<simpara>Cypher has good support for collections.</simpara>
<section id="_collections_in_general">
<title>Collections in general</title>
<simpara>A literal collection is created by using brackets and separating the elements in the collection with commas.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN [0,1,2,3,4,5,6,7,8,9] AS collection</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">collection</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[0,1,2,3,4,5,6,7,8,9]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN [0,1,2,3,4,5,6,7,8,9] AS collection</command></para></formalpara>
<simpara>In our examples, we&#8217;ll use the range function.
It gives you a collection containing all numbers between given start and end numbers.</simpara>
<simpara>To access individual elements in the collection, we use the square brackets again.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN range(0,10)[3]</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">range(0,10)[3]</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN range(0,10)[3]</command></para></formalpara>
<simpara>You can also use negative numbers, to start from the end of the collection instead.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN range(0,10)[-3]</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">range(0,10)[-3]</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>8</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN range(0,10)[-3]</command></para></formalpara>
<simpara>Finally, you can use ranges inside the brackets to return ranges of the collection.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN range(0,10)[0..3]</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">range(0,10)[0..3]</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[0,1,2]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN range(0,10)[0..3]</command></para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN range(0,10)[0..-5]</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">range(0,10)[0..-5]</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[0,1,2,3,4,5]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN range(0,10)[0..-5]</command></para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN range(0,10)[-5..]</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">range(0,10)[-5..]</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[6,7,8,9,10]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN range(0,10)[-5..]</command></para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN range(0,10)[..4]</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">range(0,10)[..4]</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[0,1,2,3]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN range(0,10)[..4]</command></para></formalpara>
<simpara>Note: Out-of-bound slices are simply truncated, but out-of-bound single elements return null.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN range(0,10)[15]</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">range(0,10)[15]</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN range(0,10)[15]</command></para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN range(0,10)[5..15]</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">range(0,10)[5..15]</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[5,6,7,8,9,10]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN range(0,10)[5..15]</command></para></formalpara>
</section>
<section id="_list_comprehension">
<title>List comprehension</title>
<simpara>List comprehension is a syntactic construct available in Cypher for creating a collection based on existing collections.
It follows the form of the mathematical set-builder notation (set comprehension) instead of the use of map
and filter functions.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN [x IN range(0,10) WHERE x % 2 = 0 | x^3] AS result</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">result</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[0.0,8.0,64.0,216.0,512.0,1000.0]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN [x IN range(0,10) WHERE x % 2 = 0 | x^3] AS result</command></para></formalpara>
<simpara>Either the <literal>WHERE</literal> part, or the expression, can be omitted, if you only want to filter or map respectively.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN [x IN range(0,10) WHERE x % 2 = 0] AS result</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">result</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[0,2,4,6,8,10]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN [x IN range(0,10) WHERE x % 2 = 0] AS result</command></para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN [x IN range(0,10)| x^3] AS result</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">result</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[0.0,1.0,8.0,27.0,64.0,125.0,216.0,343.0,512.0,729.0,1000.0]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN [x IN range(0,10)| x^3] AS result</command></para></formalpara>
</section>
<section id="_literal_maps">
<title>Literal maps</title>
<simpara>From Cypher, you can also construct maps. Through REST you will get JSON objects; in Java they will be <literal>java.util.Map&lt;String,Object&gt;</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN { key : "Value", collectionKey: [{ inner: "Map1" }, { inner: "Map2" }]}</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">{ key : "Value", collectionKey: [ { inner: "Map1" }, { inner: "Map2" } ] }</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>{key -&gt; "Value", collectionKey -&gt; [{inner -&gt; "Map1"},{inner -&gt; "Map2"}]}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>none</database><command>
 RETURN { key : "Value", collectionKey: [{ inner: "Map1" }, { inner: "Map2" }]}</command></para></formalpara>
</section>
</section>
<section id="cypher-working-with-null">
<title>Working with NULL</title>
<simpara>In Cypher, <literal>NULL</literal> is used to represent missing or undefined values.
Conceptually, <literal>NULL</literal> means &#8220;a missing unknown value&#8221; and it is treated somewhat differently from other values.
E.g. getting a property from a node that does not have said property produces <literal>NULL</literal>.
Most expressions that take <literal>NULL</literal> as input will produce <literal>NULL</literal>.
This includes boolean expressions that are used as predicates in the <literal>WHERE</literal> clause.
In this case, anything that is not <literal>TRUE</literal> is interpreted as being false.</simpara>
<simpara><literal>NULL</literal> is not equal to <literal>NULL</literal>.
Not knowing two values does not imply that they are the same value.
So the expression <literal>NULL</literal> = <literal>NULL</literal> yields <literal>NULL</literal> and not <literal>TRUE</literal>.</simpara>
<simpara>The logical operators (i.e. <literal>AND</literal>, <literal>OR</literal>, <literal>XOR</literal>, <literal>IN</literal>) treat <literal>NULL</literal> as the &#8220;unknown&#8221; value of three-valued logic.
Here is the truth table for <literal>AND</literal>, <literal>OR</literal> and <literal>XOR</literal>.</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="5">
<colspec colname="col_1" colwidth="68*"/>
<colspec colname="col_2" colwidth="68*"/>
<colspec colname="col_3" colwidth="68*"/>
<colspec colname="col_4" colwidth="68*"/>
<colspec colname="col_5" colwidth="68*"/>
<thead>
<row>
<entry align="center" valign="top">a </entry>
<entry align="center" valign="top"> b </entry>
<entry align="center" valign="top"> a <literal>AND</literal> b </entry>
<entry align="center" valign="top"> a <literal>OR</literal> b </entry>
<entry align="center" valign="top"> a <literal>XOR</literal> b</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The <literal>IN</literal> operator follows similar logic.
If Cypher knows that something exists in a collection, the result will be <literal>TRUE</literal>.
Any collection that contains a <literal>NULL</literal> and doesn&#8217;t have a matching element will return <literal>NULL</literal>.
Otherwise, the result will be false.
Here is a table with examples:</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<?dbhtml table-width="60%"?>
<?dbfo table-width="60%"?>
<?dblatex table-width="60%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="128*"/>
<colspec colname="col_2" colwidth="128*"/>
<thead>
<row>
<entry align="center" valign="top">Expression  </entry>
<entry align="center" valign="top"> Result</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>2 IN [1, 2, 3]</simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>2 IN [1, <literal>NULL</literal>, 3]</simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>2 IN [1, 2, <literal>NULL</literal>]</simpara></entry>
<entry align="center" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>2 IN [1]</simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>2 IN []</simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>NULL</literal> IN [1,2,3]</simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>NULL</literal> IN [1,<literal>NULL</literal>,3]</simpara></entry>
<entry align="center" valign="top"><simpara><literal>NULL</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>NULL</literal> IN []</simpara></entry>
<entry align="center" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Using <literal>ALL</literal>, <literal>ANY</literal>, <literal>NONE</literal>, and <literal>SINGLE</literal> follows a similar rule.
If the result can be calculated definitely, <literal>TRUE</literal> or <literal>FALSE</literal> is returned.
Otherwise <literal>NULL</literal> is produced.</simpara>
<section id="_expressions_that_return_null">
<title>Expressions that return NULL</title>
<itemizedlist>
<listitem>
<simpara>
Getting a missing element from a collection: <literal>[][0]</literal>, <literal>head([])</literal>
</simpara>
</listitem>
<listitem>
<simpara>
Trying to access a property that does not exist on a node or relationship: <literal>n.missingProperty</literal>
</simpara>
</listitem>
<listitem>
<simpara>
Comparisons when either side is <literal>NULL</literal>: <literal><literal>1 &lt; NULL</literal></literal>
</simpara>
</listitem>
<listitem>
<simpara>
Arithmetic expressions containing <literal>NULL</literal>: <literal><literal>1 + NULL</literal></literal>
</simpara>
</listitem>
<listitem>
<simpara>
Function calls where any arguments are <literal>NULL</literal>: <literal>sin(NULL)</literal>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter id="query-general">
<title>General Clauses</title>
<section id="query-return">
<title>Return</title>
<simpara>In the <literal>RETURN</literal> part of your query, you define which parts of the pattern you are
interested in. It can be nodes, relationships, or properties on these.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-return-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-return-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-return-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="return-return-nodes">
<title>Return nodes</title>
<simpara>To return a node, list it in the <literal>RETURN</literal> statement.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: "B" })
RETURN n</programlisting>
</para></formalpara>
<simpara>The example will return the node.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"B"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:55, `happy`:"Yes!", `name`:"A"})
create (_1 {`name`:"B"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`BLOCKS`]-&gt;_1
</database><command>
 match (n {name: "B"}) return n</command></para></formalpara>
</section>
<section id="return-return-relationships">
<title>Return relationships</title>
<simpara>To return a relationship, just include it in the <literal>RETURN</literal> list.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: "A" })-[r:KNOWS]-&gt;(c)
RETURN r</programlisting>
</para></formalpara>
<simpara>The relationship is returned by the example.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>:KNOWS[0]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:55, `happy`:"Yes!", `name`:"A"})
create (_1 {`name`:"B"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`BLOCKS`]-&gt;_1
</database><command>
 match (n {name: "A"})-[r:KNOWS]-&gt;(c) return r</command></para></formalpara>
</section>
<section id="return-return-property">
<title>Return property</title>
<simpara>To return a property, use the dot separator, like this:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: "A" })
RETURN n.name</programlisting>
</para></formalpara>
<simpara>The value of the property <literal>name</literal> gets returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"A"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:55, `happy`:"Yes!", `name`:"A"})
create (_1 {`name`:"B"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`BLOCKS`]-&gt;_1
</database><command>
 match (n {name: "A"}) return n.name</command></para></formalpara>
</section>
<section id="return-return-all-elements">
<title>Return all elements</title>
<simpara>When you want to return all nodes, relationships and paths found in a query, you can use the <literal>*</literal> symbol.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p=(a { name: "A" })-[r]-&gt;(b)
RETURN *</programlisting>
</para></formalpara>
<simpara>This returns the two nodes, the relationship and the path used in the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="4"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><colspec colname="col4"/><thead><row><entry align="left" valign="top">b</entry><entry align="left" valign="top">a</entry><entry align="left" valign="top">r</entry><entry align="left" valign="top">p</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col4">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"B"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[0]{name:"A",happy:"Yes!",age:55}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>:KNOWS[0]{}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>[Node[0]{name:"A",happy:"Yes!",age:55},:KNOWS[0]{},Node[1]{name:"B"}]</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"B"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[0]{name:"A",happy:"Yes!",age:55}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>:BLOCKS[1]{}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>[Node[0]{name:"A",happy:"Yes!",age:55},:BLOCKS[1]{},Node[1]{name:"B"}]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:55, `happy`:"Yes!", `name`:"A"})
create (_1 {`name`:"B"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`BLOCKS`]-&gt;_1
</database><command>
 match p=(a {name: "A"})-[r]-&gt;(b) return *</command></para></formalpara>
</section>
<section id="return-identifier-with-uncommon-characters">
<title>Identifier with uncommon characters</title>
<simpara>To introduce a placeholder that is made up of characters that are
      outside of the english alphabet, you can use the <literal>`</literal> to enclose the identifier, like this:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (`This isn't a common identifier`)
WHERE `This isn't a common identifier`.name='A'
RETURN `This isn't a common identifier`.happy</programlisting>
</para></formalpara>
<simpara>The node with name "A" is returned</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">`This isn't a common identifier`.happy</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Yes!"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:55, `happy`:"Yes!", `name`:"A"})
create (_1 {`name`:"B"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`BLOCKS`]-&gt;_1
</database><command>
 match (`This isn't a common identifier`) where `This isn't a common identifier`.name='A'
 return `This isn't a common identifier`.happy</command></para></formalpara>
</section>
<section id="return-column-alias">
<title>Column alias</title>
<simpara>If the name of the column should be different from the expression used, you can rename it by using <literal>AS</literal> &lt;new name&gt;.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a { name: "A" })
RETURN a.age AS SomethingTotallyDifferent</programlisting>
</para></formalpara>
<simpara>Returns the age property of a node, but renames the column.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">SomethingTotallyDifferent</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>55</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:55, `happy`:"Yes!", `name`:"A"})
create (_1 {`name`:"B"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`BLOCKS`]-&gt;_1
</database><command>
 match (a {name: "A"}) return a.age AS SomethingTotallyDifferent</command></para></formalpara>
</section>
<section id="return-optional-properties">
<title>Optional properties</title>
<simpara>If a property might or might not be there, you can still select it as usual. It will be treated as <literal>NULL</literal> if it is missing</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
RETURN n.age</programlisting>
</para></formalpara>
<simpara>This example returns the age when the node has that property, or <literal>null</literal> if the property is not there.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n.age</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>55</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:55, `happy`:"Yes!", `name`:"A"})
create (_1 {`name`:"B"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`BLOCKS`]-&gt;_1
</database><command>
 match (n) return n.age</command></para></formalpara>
</section>
<section id="return-other-expressions">
<title>Other expressions</title>
<simpara>Any expression can be used as a return item&#8201;&#8212;&#8201;literals, predicates, properties, functions, and everything else.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a { name: "A" })
RETURN a.age &gt; 30, "I'm a literal",(a)--&gt;()</programlisting>
</para></formalpara>
<simpara>Returns a predicate, a literal and function call with a pattern expression parameter.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="3"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><thead><row><entry align="left" valign="top">a.age &gt; 30</entry><entry align="left" valign="top">"I'm a literal"</entry><entry align="left" valign="top">(a)--&gt;()</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col3">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"I'm a literal"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>[[Node[0]{name:"A",happy:"Yes!",age:55},:KNOWS[0]{},Node[1]{name:"B"}],[Node[0]{name:"A",happy:"Yes!",age:55},:BLOCKS[1]{},Node[1]{name:"B"}]]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:55, `happy`:"Yes!", `name`:"A"})
create (_1 {`name`:"B"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`BLOCKS`]-&gt;_1
</database><command>
 match (a {name: "A"}) return a.age &gt; 30, "I'm a literal", (a)--&gt;()</command></para></formalpara>
</section>
<section id="return-unique-results">
<title>Unique results</title>
<simpara><literal>DISTINCT</literal> retrieves only unique rows depending on the columns that have been selected to output.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a { name: "A" })--&gt;(b)
RETURN DISTINCT b</programlisting>
</para></formalpara>
<simpara>The node named B is returned by the query, but only once.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">b</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"B"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:55, `happy`:"Yes!", `name`:"A"})
create (_1 {`name`:"B"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`BLOCKS`]-&gt;_1
</database><command>
 match (a {name: "A"})--&gt;(b) return distinct b</command></para></formalpara>
</section>
</section>
<section id="query-order">
<title>Order by</title>
<simpara>To sort the output, use the <literal>ORDER BY</literal> clause. Note that you can not sort on nodes or relationships,
just on properties on these.
<literal>ORDER BY</literal> relies on comparisons to sort the output, see <xref linkend="cypher-ordering"/>.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-orderby-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-orderby-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-orderby-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="order-by-order-nodes-by-property">
<title>Order nodes by property</title>
<simpara><literal>ORDER BY</literal> is used to sort the output.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
RETURN n
ORDER BY n.name</programlisting>
</para></formalpara>
<simpara>The nodes are returned, sorted by their name.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"A",age:34,length:170}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"B",age:34}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"C",age:32,length:185}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:34, `length`:170, `name`:"A"})
create (_1 {`age`:34, `name`:"B"})
create (_2 {`age`:32, `length`:185, `name`:"C"})
create _0-[:`KNOWS`]-&gt;_1
create _1-[:`KNOWS`]-&gt;_2
</database><command>
 match (n) return n order by n.name</command></para></formalpara>
</section>
<section id="order-by-order-nodes-by-multiple-properties">
<title>Order nodes by multiple properties</title>
<simpara>You can order by multiple properties by stating each identifier in the <literal>ORDER BY</literal> clause. Cypher will sort the result by the first identifier listed, and for equals values, go to the next property in the <literal>ORDER BY</literal> clause, and so on.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
RETURN n
ORDER BY n.age, n.name</programlisting>
</para></formalpara>
<simpara>This returns the nodes, sorted first by their age, and then by their name.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"C",age:32,length:185}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"A",age:34,length:170}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"B",age:34}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:34, `length`:170, `name`:"A"})
create (_1 {`age`:34, `name`:"B"})
create (_2 {`age`:32, `length`:185, `name`:"C"})
create _0-[:`KNOWS`]-&gt;_1
create _1-[:`KNOWS`]-&gt;_2
</database><command>
 match (n) return n order by n.age, n.name</command></para></formalpara>
</section>
<section id="order-by-order-nodes-in-descending-order">
<title>Order nodes in descending order</title>
<simpara>By adding <literal>DESC[ENDING]</literal> after the identifier to sort on, the sort will be done in reverse order.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
RETURN n
ORDER BY n.name DESC</programlisting>
</para></formalpara>
<simpara>The example returns the nodes, sorted by their name reversely.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"C",age:32,length:185}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"B",age:34}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"A",age:34,length:170}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:34, `length`:170, `name`:"A"})
create (_1 {`age`:34, `name`:"B"})
create (_2 {`age`:32, `length`:185, `name`:"C"})
create _0-[:`KNOWS`]-&gt;_1
create _1-[:`KNOWS`]-&gt;_2
</database><command>
 match (n) return n order by n.name DESC</command></para></formalpara>
</section>
<section id="order-by-ordering-null">
<title>Ordering NULL</title>
<simpara>When sorting the result set, <literal>NULL</literal> will always come at the end of the result set for ascending sorting, and first when doing descending sort.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
RETURN n.length, n
ORDER BY n.length</programlisting>
</para></formalpara>
<simpara>The nodes are returned sorted by the length property, with a node without that property last.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">n.length</entry><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>170</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[0]{name:"A",age:34,length:170}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>185</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[2]{name:"C",age:32,length:185}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[1]{name:"B",age:34}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:34, `length`:170, `name`:"A"})
create (_1 {`age`:34, `name`:"B"})
create (_2 {`age`:32, `length`:185, `name`:"C"})
create _0-[:`KNOWS`]-&gt;_1
create _1-[:`KNOWS`]-&gt;_2
</database><command>
 match (n) return n.length, n order by n.length</command></para></formalpara>
</section>
</section>
<section id="query-limit">
<title>Limit</title>
<simpara><literal>LIMIT</literal> enables the return of only subsets of the total result.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-limit-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-limit-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-limit-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="limit-return-first-part">
<title>Return first part</title>
<simpara>To return a subset of the result, starting from the top, use this syntax:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
RETURN n
LIMIT 3</programlisting>
</para></formalpara>
<simpara>The top three items are returned by the example query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"D"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"E"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"A"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"D"})
create (_1 {`name`:"E"})
create (_2 {`name`:"A"})
create (_3 {`name`:"B"})
create (_4 {`name`:"C"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) return n limit 3</command></para></formalpara>
</section>
</section>
<section id="query-skip">
<title>Skip</title>
<simpara><literal>SKIP</literal> enables the return of only subsets of the total result.
By using <literal>SKIP</literal>, the result set will get trimmed from the top.
Please note that no guarantees are made on the order of the result unless the query specifies the <literal>ORDER BY</literal> clause.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-skip-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-skip-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-skip-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="skip-skip-first-three">
<title>Skip first three</title>
<simpara>To return a subset of the result, starting from the fourth result, use the following syntax:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
RETURN n
ORDER BY n.name
SKIP 3</programlisting>
</para></formalpara>
<simpara>The first three nodes are skipped, and only the last two are returned in the result.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"D"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"E"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"D"})
create (_1 {`name`:"E"})
create (_2 {`name`:"A"})
create (_3 {`name`:"B"})
create (_4 {`name`:"C"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) return n order by n.name skip 3</command></para></formalpara>
</section>
<section id="skip-return-middle-two">
<title>Return middle two</title>
<simpara>To return a subset of the result, starting from somewhere in the middle, use this syntax:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
RETURN n
ORDER BY n.name
SKIP 1
LIMIT 2</programlisting>
</para></formalpara>
<simpara>Two nodes from the middle are returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"B"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[4]{name:"C"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"D"})
create (_1 {`name`:"E"})
create (_2 {`name`:"A"})
create (_3 {`name`:"B"})
create (_4 {`name`:"C"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) return n order by n.name skip 1 limit 2</command></para></formalpara>
</section>
</section>
<section id="query-with">
<title>With</title>
<simpara>With <literal>WITH</literal>, you can manipulate the result sequence before it is passed on to the following query parts. The
manipulations can be of the shape and/or number of entries in the result set.</simpara>
<simpara>One common usage of <literal>WITH</literal> is to limit the number of entries that are then passed on to other <literal>MATCH</literal> clauses.
By combining <literal>ORDER</literal> <literal>BY</literal> and <literal>LIMIT</literal>, it&#8217;s possible to get the top X entries by some criteria, and then bring
in additional data from the graph.</simpara>
<simpara>Another use is to filter on aggregated values. <literal>WITH</literal> is used to introduce aggregates which can then by used in
predicates in <literal>WHERE</literal>. These aggregate expressions create new bindings in the results. <literal>WITH</literal> can also, just like
<literal>RETURN</literal>, alias expressions that are introduced into the results using the aliases as binding name.</simpara>
<simpara><literal>WITH</literal> is also used to separate reading from updating of the graph. Every part of a query must be either
read-only or write-only. When going from a writing part to a reading part, the switch must be done
with a <literal>WITH</literal> clause.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-with-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-with-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-with-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="with-filter-on-aggregate-function-results">
<title>Filter on aggregate function results</title>
<simpara>Aggregated results have to pass through a <literal>WITH</literal> clause to be able to filter on.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (david { name: "David" })--(otherPerson)--&gt;()
WITH otherPerson, count(*) AS foaf
WHERE foaf &gt; 1
RETURN otherPerson</programlisting>
</para></formalpara>
<simpara>The person connected to David with the at least more than one outgoing relationship will be returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">otherPerson</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Anders"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"David"})
create (_1 {`name`:"Emil"})
create (_2 {`name`:"Anders"})
create (_3 {`name`:"Bossman"})
create (_4 {`name`:"Ceasar"})
create _0-[:`KNOWS`]-&gt;_2
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`BLOCKS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_1
create _3-[:`BLOCKS`]-&gt;_0
create _4-[:`KNOWS`]-&gt;_1
</database><command>
 match (david {name: "David"})--(otherPerson)--&gt;() with otherPerson, count(*) as foaf where foaf &gt; 1 return otherPerson</command></para></formalpara>
</section>
<section id="with-sort-results-before-using-collect-on-them">
<title>Sort results before using collect on them</title>
<simpara>You can sort your results before passing them to collect, thus sorting the resulting collection.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WITH n
ORDER BY n.name DESC LIMIT 3
RETURN collect(n.name)</programlisting>
</para></formalpara>
<simpara>A list of the names of people in reverse order, limited to 3, in a collection.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">collect(n.name)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>["Emil","David","Ceasar"]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"David"})
create (_1 {`name`:"Emil"})
create (_2 {`name`:"Anders"})
create (_3 {`name`:"Bossman"})
create (_4 {`name`:"Ceasar"})
create _0-[:`KNOWS`]-&gt;_2
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`BLOCKS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_1
create _3-[:`BLOCKS`]-&gt;_0
create _4-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) with n order by n.name desc limit 3 return collect(n.name)</command></para></formalpara>
</section>
<section id="with-limit-branching-of-your-path-search">
<title>Limit branching of your path search</title>
<simpara>You can match paths, limit to a certain number, and then match again using those paths as a base As well as any number of similar limited searches.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: "Anders" })--(m)
WITH m
ORDER BY m.name DESC LIMIT 1
MATCH (m)--(o)
RETURN o.name</programlisting>
</para></formalpara>
<simpara>Starting at Anders, find all matching nodes, order by name descending and get the top result, then find all the nodes connected to that top result, and return their names.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">o.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Anders"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Bossman"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"David"})
create (_1 {`name`:"Emil"})
create (_2 {`name`:"Anders"})
create (_3 {`name`:"Bossman"})
create (_4 {`name`:"Ceasar"})
create _0-[:`KNOWS`]-&gt;_2
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`BLOCKS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_1
create _3-[:`BLOCKS`]-&gt;_0
create _4-[:`KNOWS`]-&gt;_1
</database><command>
 match (n {name: "Anders"})--(m) with m order by m.name desc limit 1 match (m)--(o) return o.name</command></para></formalpara>
</section>
</section>
<section id="query-union">
<title>Union</title>
<simpara>Combining results from multiple queries is done through the <literal>UNION</literal> operator.</simpara>
<simpara>Combines the results of two or more queries into a single result set that includes all the rows that belong to all queries in the union.</simpara>
<simpara>The number and the names of the columns must be identical in all queries combined by using <literal>UNION</literal>.</simpara>
<simpara>To keep all the result rows, use <literal>UNION</literal> <literal>ALL</literal>.
Using just <literal>UNION</literal> will combine and remove duplicates from the result set.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-union-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-union-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-union-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="union-combine-two-queries">
<title>Combine two queries</title>
<simpara>Combining the results from two queries is done using <literal>UNION ALL</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n:Actor)
RETURN n.name AS name
UNION ALL MATCH (n:Movie)
RETURN n.title AS name</programlisting>
</para></formalpara>
<simpara>The combined result is returned, including duplicates.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">4 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Anthony Hopkins"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Helen Mirren"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Hitchcock"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Hitchcock"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Actor` {`name`:"Anthony Hopkins"})
create (_1:`Actor` {`name`:"Helen Mirren"})
create (_2:`Actor` {`name`:"Hitchcock"})
create (_3:`Movie` {`title`:"Hitchcock"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`ACTS_IN`]-&gt;_3
create _1-[:`ACTS_IN`]-&gt;_3
</database><command>
 match (n:Actor) return n.name as name
            UNION ALL
            match (n:Movie) return n.title as name</command></para></formalpara>
</section>
<section id="union-combine-two-queries-and-remove-duplicates">
<title>Combine two queries and remove duplicates</title>
<simpara>By not including <literal>ALL</literal> in the <literal>UNION</literal>, duplicates are removed from the combined result set</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n:Actor)
RETURN n.name AS name
UNION
MATCH (n:Movie)
RETURN n.title AS name</programlisting>
</para></formalpara>
<simpara>The combined result is returned, without duplicates.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Anthony Hopkins"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Helen Mirren"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Hitchcock"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Actor` {`name`:"Anthony Hopkins"})
create (_1:`Actor` {`name`:"Helen Mirren"})
create (_2:`Actor` {`name`:"Hitchcock"})
create (_3:`Movie` {`title`:"Hitchcock"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`ACTS_IN`]-&gt;_3
create _1-[:`ACTS_IN`]-&gt;_3
</database><command>
 match (n:Actor) return n.name as name
 UNION
 match (n:Movie) return n.title as name</command></para></formalpara>
</section>
</section>
<section id="query-using">
<title>Using</title>
<simpara>If you do not specify an explicit <literal>START</literal> clause, Cypher needs to infer where in the graph to start your query.
This is done by looking at the <literal>WHERE</literal> clause and the <literal>MATCH</literal> clause and using that information to find a useful index.</simpara>
<simpara>This index might not be the best choice though&#8201;&#8212;&#8201;sometimes multiple indexes could be used, and Cypher has picked the wrong one (from a performance point of view).</simpara>
<simpara>You can force Cypher to use a specific starting point by using the <literal>USING</literal> clause.
This is called giving Cypher an index hint.</simpara>
<simpara>If your query matches large parts of an index, it might be faster to scan the label and filter out nodes that do not match.
To do this, you can use <literal>USING</literal> <literal>SCAN</literal>.
It will force Cypher to not use an index that could have been used, and instead do a label scan.</simpara>
<note><simpara>You cannot use index hints if your query has a <literal>START</literal> clause.</simpara></note>
<section id="using-query-using-an-index-hint">
<title>Query using an index hint</title>
<simpara>To query using an index hint, use <literal>USING</literal> <literal>INDEX</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n:Swedish)
USING INDEX n:Swedish(surname)
WHERE n.surname = 'Taylor'
RETURN n</programlisting>
</para></formalpara>
<simpara>The query result is returned as usual.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"Andres",age:36,awesome:true,surname:"Taylor"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create index on :`Swedish`(`surname`)
create (_0 {`name`:"Emil"})
create (_1:`German` {`name`:"Stefan", `surname`:"Plantikow"})
create (_2 {`age`:34, `name`:"Peter"})
create (_3:`Swedish` {`age`:36, `awesome`:true, `name`:"Andres", `surname`:"Taylor"})
create _0-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _3-[:`KNOWS`]-&gt;_2
</database><command>
 match (n:Swedish) using index n:Swedish(surname) where n.surname = 'Taylor' return n</command></para></formalpara>
</section>
<section id="using-query-using-multiple-index-hints">
<title>Query using multiple index hints</title>
<simpara>To query using multiple index hints, use <literal>USING</literal> <literal>INDEX</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (m:German)--&gt;(n:Swedish)
USING INDEX m:German(surname)
USING INDEX n:Swedish(surname)
WHERE m.surname = 'Plantikow' AND n.surname = 'Taylor'
RETURN m</programlisting>
</para></formalpara>
<simpara>The query result is returned as usual.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">m</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Stefan",surname:"Plantikow"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create index on :`German`(`surname`)
create index on :`Swedish`(`surname`)
create (_0 {`name`:"Emil"})
create (_1:`German` {`name`:"Stefan", `surname`:"Plantikow"})
create (_2 {`age`:34, `name`:"Peter"})
create (_3:`Swedish` {`age`:36, `awesome`:true, `name`:"Andres", `surname`:"Taylor"})
create _0-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _3-[:`KNOWS`]-&gt;_2
</database><command>
 match (m:German)--&gt;(n:Swedish) using index m:German(surname) using index n:Swedish(surname) where m.surname = 'Plantikow' and n.surname = 'Taylor' return m</command></para></formalpara>
</section>
<section id="using-hinting-a-label-scan">
<title>Hinting a label scan</title>
<simpara>If the best performance is to be had by scanning all nodes in a label and then filtering on that set, use <literal>USING</literal> <literal>SCAN</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (m:German)
USING SCAN m:German
WHERE m.surname = 'Plantikow'
RETURN m</programlisting>
</para></formalpara>
<simpara>This query does its work by finding all <literal>:German</literal> labeled nodes and filtering them by the surname property.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">m</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Stefan",surname:"Plantikow"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Emil"})
create (_1:`German` {`name`:"Stefan", `surname`:"Plantikow"})
create (_2 {`age`:34, `name`:"Peter"})
create (_3:`Swedish` {`age`:36, `awesome`:true, `name`:"Andres", `surname`:"Taylor"})
create _0-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _3-[:`KNOWS`]-&gt;_2
</database><command>
 match (m:German) using scan m:German where m.surname = 'Plantikow' return m</command></para></formalpara>
</section>
</section>
</chapter>
<chapter id="query-read">
<title>Reading Clauses</title>
<simpara>The flow of data within a Cypher query is an unordered sequence of maps with key-value pairs&#8201;&#8212;&#8201;a set of possible bindings between the identifiers in the query and values derived from the database.
This set is refined and augmented by subsequent parts of the query.</simpara>
<section id="query-match">
<title>Match</title>
<section id="_introduction_2">
<title>Introduction</title>
<simpara><literal>MATCH</literal> is the primary way of getting data from the database into the current set of bindings.</simpara>
<simpara>The <literal>MATCH</literal> clause allows you to specify the patterns Cypher will search for in the database.</simpara>
<simpara>Nodes and relationships that are already known at this stage are called <emphasis>bound pattern elements</emphasis>.
Cypher will now try to find the unknown parts of the pattern.</simpara>
<simpara>If <literal>MATCH</literal> is the first clause in your query, nothing is bound at this stage.
Cypher needs starting points to do it&#8217;s pattern matching.</simpara>
<simpara>If no bound nodes exist, Cypher can scan all nodes in the database, all nodes with a certain label, or it can use indexes to quickly find the relevant starting points.
For more information on indexes, see <xref linkend="query-schema-index"/>.
If you want to use index hints to force Cypher to use a specific index, read more in <xref linkend="query-using"/>.</simpara>
<simpara><literal>WHERE</literal> defines the <literal>MATCH</literal> patterns in more detail.
The predicates are part of the pattern description, not a filter applied after the matching is done.
This means that <literal>WHERE</literal> should always be put together with the <literal>MATCH</literal> clause it belongs to.</simpara>
<simpara>After finding starting points&#8201;&#8212;&#8201;either by using scans, indexes or already bound points&#8201;&#8212;&#8201;the execution engine will use pattern matching to find matching subgraphs.
As Cypher is declarative, it can change the order of these operations.
Predicates in <literal>WHERE</literal> clauses can be evaluated before pattern matching, during pattern matching, or after finding matches.</simpara>
<tip><simpara>To understand the patterns used in the <literal>MATCH</literal> clause, read <xref linkend="introduction-pattern"/>.</simpara></tip>
<simpara>The following graph is used for the examples below:</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-match-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-match-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-match-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
<section id="_basic_node_finding">
<title>Basic node finding</title>
<section id="match-get-all-nodes">
<title>Get all nodes</title>
<simpara>By just specifying a pattern with a single node and no labels, all nodes in the graph will be returned.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
RETURN n</programlisting>
</para></formalpara>
<simpara>Returns all the nodes in the database.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">7 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Oliver Stone"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Charlie Sheen"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Martin Sheen"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"TheAmericanPresident",title:"The American President"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[4]{name:"WallStreet",title:"Wall Street"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[5]{name:"Rob Reiner"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[6]{name:"Michael Douglas"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (n) return n</command></para></formalpara>
</section>
<section id="match-get-all-nodes-with-a-label">
<title>Get all nodes with a label</title>
<simpara>Getting all nodes with a label on them is done with a single node pattern where the node has a label on it.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (movie:Movie)
RETURN movie</programlisting>
</para></formalpara>
<simpara>Returns all the movies in the database.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">movie</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"TheAmericanPresident",title:"The American President"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[4]{name:"WallStreet",title:"Wall Street"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (movie:Movie) return movie</command></para></formalpara>
</section>
<section id="match-related-nodes">
<title>Related nodes</title>
<simpara>The symbol <literal>--</literal> means <emphasis>related to,</emphasis> without regard to type or direction of the relationship.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (director { name:'Oliver Stone' })--(movie)
RETURN movie.title</programlisting>
</para></formalpara>
<simpara>Returns all the movies directed by Oliver Stone.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">movie.title</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Wall Street"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (director {name:'Oliver Stone'})--(movie) return movie.title</command></para></formalpara>
</section>
<section id="match-match-with-labels">
<title>Match with labels</title>
<simpara>To constrain your pattern with labels on nodes, you add it to your pattern nodes, using the label syntax.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (charlie:Person { name:'Charlie Sheen' })--(movie:Movie)
RETURN movie</programlisting>
</para></formalpara>
<simpara>Return any nodes connected with the <literal>Person</literal> Charlie that are labeled <literal>Movie</literal>.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">movie</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[4]{name:"WallStreet",title:"Wall Street"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (charlie:Person {name:'Charlie Sheen'})--(movie:Movie) return movie</command></para></formalpara>
</section>
</section>
<section id="_relationship_basics">
<title>Relationship basics</title>
<section id="match-outgoing-relationships">
<title>Outgoing relationships</title>
<simpara>When the direction of a relationship is interesting, it is shown by using <literal>--&gt;</literal> or <literal>&lt;--</literal>, like this:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (martin { name:'Martin Sheen' })--&gt;(movie)
RETURN movie.title</programlisting>
</para></formalpara>
<simpara>Returns nodes connected to Martin by outgoing relationships.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">movie.title</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Wall Street"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"The American President"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (martin {name:'Martin Sheen'})--&gt;(movie) return movie.title</command></para></formalpara>
</section>
<section id="match-directed-relationships-and-identifier">
<title>Directed relationships and identifier</title>
<simpara>If an identifier is needed, either for filtering on properties of the relationship, or to return the relationship, this is how you introduce the identifier.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (martin { name:'Martin Sheen' })-[r]-&gt;(movie)
RETURN r</programlisting>
</para></formalpara>
<simpara>Returns all outgoing relationships from Martin.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>:ACTED_IN[1]{}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>:ACTED_IN[3]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (martin {name:'Martin Sheen'})-[r]-&gt;(movie) return r</command></para></formalpara>
</section>
<section id="match-match-by-relationship-type">
<title>Match by relationship type</title>
<simpara>When you know the relationship type you want to match on, you can specify it by using a colon together with the relationship type.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (wallstreet { title:'Wall Street' })&lt;-[:ACTED_IN]-(actor)
RETURN actor</programlisting>
</para></formalpara>
<simpara>Returns nodes that <literal>ACTED_IN</literal> Wall Street.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">actor</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Charlie Sheen"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Martin Sheen"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[6]{name:"Michael Douglas"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (wallstreet {title:'Wall Street'})&lt;-[:ACTED_IN]-(actor) return actor</command></para></formalpara>
</section>
<section id="match-match-by-multiple-relationship-types">
<title>Match by multiple relationship types</title>
<simpara>To match on one of multiple types, you can specify this by chaining them together with the pipe symbol <literal>|</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (wallstreet { title:'Wall Street' })&lt;-[:ACTED_IN|:DIRECTED]-(person)
RETURN person</programlisting>
</para></formalpara>
<simpara>Returns nodes with a <literal>ACTED_IN</literal> or <literal>DIRECTED</literal> relationship to Wall Street.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">person</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">4 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Oliver Stone"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Charlie Sheen"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Martin Sheen"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[6]{name:"Michael Douglas"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (wallstreet {title:'Wall Street'})&lt;-[:ACTED_IN|:DIRECTED]-(person) return person</command></para></formalpara>
</section>
<section id="match-match-by-relationship-type-and-use-an-identifier">
<title>Match by relationship type and use an identifier</title>
<simpara>If you both want to introduce an identifier to hold the relationship, and specify the relationship type you want, just add them both, like this.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (wallstreet { title:'Wall Street' })&lt;-[r:ACTED_IN]-(actor)
RETURN r</programlisting>
</para></formalpara>
<simpara>Returns nodes that <literal>ACTED_IN</literal> Wall Street.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>:ACTED_IN[0]{}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>:ACTED_IN[1]{}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>:ACTED_IN[2]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (wallstreet {title:'Wall Street'})&lt;-[r:ACTED_IN]-(actor) return r</command></para></formalpara>
</section>
</section>
<section id="_relationships_in_depth">
<title>Relationships in depth</title>
<section id="match-relationship-types-with-uncommon-characters">
<title>Relationship types with uncommon characters</title>
<simpara>Sometime your database will have types with non-letter characters, or with spaces in them. Use <literal>`</literal> (backtick) to quote these.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name:'Rob Reiner' })-[r:`TYPE THAT HAS SPACE IN IT`]-&gt;()
RETURN r</programlisting>
</para></formalpara>
<simpara>Returns a relationship of a type with spaces in it.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>:TYPE THAT HAS SPACE IN IT[8]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _5-[:`TYPE THAT HAS SPACE IN IT`]-&gt;_1
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (n {name:'Rob Reiner'})-[r:`TYPE THAT HAS SPACE IN IT`]-&gt;() return r</command></para></formalpara>
</section>
<section id="match-multiple-relationships">
<title>Multiple relationships</title>
<simpara>Relationships can be expressed by using multiple statements in the form of <literal>()--()</literal>, or they can be strung together, like this:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (charlie { name:'Charlie Sheen' })-[:ACTED_IN]-&gt;(movie)&lt;-[:DIRECTED]-&gt;(director)
RETURN charlie,movie,director</programlisting>
</para></formalpara>
<simpara>Returns the three nodes in the path.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="3"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><thead><row><entry align="left" valign="top">charlie</entry><entry align="left" valign="top">movie</entry><entry align="left" valign="top">director</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col3">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Charlie Sheen"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[4]{name:"WallStreet",title:"Wall Street"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Oliver Stone"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (charlie {name:'Charlie Sheen'})-[:ACTED_IN]-&gt;(movie)&lt;-[:DIRECTED]-&gt;(director) return charlie,movie,director</command></para></formalpara>
</section>
<section id="match-variable-length-relationships">
<title>Variable length relationships</title>
<simpara>Nodes that are a variable number of relationship&#8594;node hops away can be found using the following syntax: <literal>-[:TYPE*minHops..maxHops]-&gt;</literal>. minHops and maxHops are optional and default to 1 and infinity respectively. When no bounds are given the dots may be omitted.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (martin { name:"Martin Sheen" })-[:ACTED_IN*1..2]-(x)
RETURN x</programlisting>
</para></formalpara>
<simpara>Returns nodes that are 1 or 2 relationships away from Martin.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">x</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">5 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[4]{name:"WallStreet",title:"Wall Street"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Charlie Sheen"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[6]{name:"Michael Douglas"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"TheAmericanPresident",title:"The American President"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[6]{name:"Michael Douglas"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (martin {name:"Martin Sheen"})-[:ACTED_IN*1..2]-(x) return x</command></para></formalpara>
</section>
<section id="match-relationship-identifier-in-variable-length-relationships">
<title>Relationship identifier in variable length relationships</title>
<simpara>When the connection between two nodes is of variable length, a relationship identifier becomes an collection of relationships.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (actor { name:'Charlie Sheen' })-[r:ACTED_IN*2]-(co_actor)
RETURN r</programlisting>
</para></formalpara>
<simpara>The query returns a collection of relationships.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[:ACTED_IN[0]{},:ACTED_IN[1]{}]</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>[:ACTED_IN[0]{},:ACTED_IN[2]{}]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (actor {name:'Charlie Sheen'})-[r:ACTED_IN*2]-(co_actor) return r</command></para></formalpara>
</section>
<section id="match-match-with-properties-on-a-variable-length-path">
<title>Match with properties on a variable length path</title>
<simpara>A variable length relationship with properties defined on in it means that all relationships in the path
must have the property set to the given value. In this query, there are two paths between Charile Sheen and his
dad Martin Sheen. One of the includes a &#8220;blocked&#8221; relationship and the other doesn&#8217;t.
In this case we first alter the original graph by using the following query to add &#8220;blocked&#8221; and &#8220;unblocked&#8221; relationships:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (charlie:Person { name:'Charlie Sheen' }),(martin:Person { name:'Martin Sheen' })
CREATE (charlie)-[:X { blocked:false }]-&gt;(:Unblocked)&lt;-[:X { blocked:false }]-(martin)
CREATE (charlie)-[:X { blocked:true }]-&gt;(:Blocked)&lt;-[:X { blocked:false }]-(martin);</programlisting>
<simpara>This means that we are starting out with the following graph:</simpara>
<informalfigure>
<ulink url="images/match-match-with-properties-on-a-variable-length-path.preparation-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/match-match-with-properties-on-a-variable-length-path.preparation-graph.svg"/>
  </imageobject>
  <textobject><phrase>match-match-with-properties-on-a-variable-length-path.preparation-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p =(charlie:Person)-[* { blocked:false }]-(martin:Person)
WHERE charlie.name = 'Charlie Sheen' AND martin.name = 'Martin Sheen'
RETURN p</programlisting>
</para></formalpara>
<simpara>Returns the paths between Charlie and Martin Sheen where all relationships have the <literal>blocked</literal> property set to <literal>FALSE</literal>.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">p</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[Node[1]{name:"Charlie Sheen"},:X[12]{blocked:false},Node[9]{},:X[13]{blocked:false},Node[2]{name:"Martin Sheen"}]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 MATCH p = (charlie:Person)-[* {blocked:false}]-(martin:Person) WHERE charlie.name = 'Charlie Sheen' AND martin.name = 'Martin Sheen' RETURN p</command></para></formalpara>
</section>
<section id="match-zero-length-paths">
<title>Zero length paths</title>
<simpara>Using variable length paths that have the lower bound zero means that two identifiers can point to the same node. If the distance between two nodes is zero, they are by definition the same node. Note that when matching zero length paths the result may contain a match even when matching on a relationship type not in use.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (wallstreet:Movie { title:'Wall Street' })-[*0..1]-(x)
RETURN x</programlisting>
</para></formalpara>
<simpara>Returns all nodes that are zero or one relationships away from Wall Street.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">x</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">5 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[4]{name:"WallStreet",title:"Wall Street"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Charlie Sheen"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Martin Sheen"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[6]{name:"Michael Douglas"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Oliver Stone"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (wallstreet:Movie {title:'Wall Street'})-[*0..1]-(x) return x</command></para></formalpara>
</section>
<section id="match-named-path">
<title>Named path</title>
<simpara>If you want to return or filter on a path in your pattern graph, you can a introduce a named path.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p =(michael { name:'Michael Douglas' })--&gt;()
RETURN p</programlisting>
</para></formalpara>
<simpara>Returns the two paths starting from Michael.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">p</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[Node[6]{name:"Michael Douglas"},:ACTED_IN[2]{},Node[4]{name:"WallStreet",title:"Wall Street"}]</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>[Node[6]{name:"Michael Douglas"},:ACTED_IN[4]{},Node[3]{name:"TheAmericanPresident",title:"The American President"}]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match p = (michael {name:'Michael Douglas'})--&gt;() return p</command></para></formalpara>
</section>
<section id="match-matching-on-a-bound-relationship">
<title>Matching on a bound relationship</title>
<simpara>When your pattern contains a bound relationship, and that relationship pattern doesn&#8217;t specify direction,
Cypher will try to match the relationship in both directions.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a)-[r]-(b)
WHERE id(r)= 0
RETURN a,b</programlisting>
</para></formalpara>
<simpara>This returns the two connected nodes, once as the start node, and once as the end node.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">a</entry><entry align="left" valign="top">b</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Charlie Sheen"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[4]{name:"WallStreet",title:"Wall Street"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[4]{name:"WallStreet",title:"Wall Street"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Charlie Sheen"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (a)-[r]-(b) where id(r) = 0 return a,b</command></para></formalpara>
</section>
</section>
<section id="_shortest_path">
<title>Shortest path</title>
<section id="match-single-shortest-path">
<title>Single shortest path</title>
<simpara>Finding a single shortest path between two nodes is as easy as using the <literal>shortestPath</literal> function. It&#8217;s done like this:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (martin:Person { name:"Martin Sheen" }),(oliver:Person { name:"Oliver Stone" }),
  p = shortestPath((martin)-[*..15]-(oliver))
RETURN p</programlisting>
</para></formalpara>
<simpara>This means: find a single shortest path between two nodes, as long as the path is max 15 relationships long. Inside of the parentheses
 you define a single link of a path&#8201;&#8212;&#8201;the starting node, the connecting relationship and the end node. Characteristics describing the relationship
 like relationship type, max hops and direction are all used when finding the shortest path. You can also mark the path as optional.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">p</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[Node[2]{name:"Martin Sheen"},:ACTED_IN[1]{},Node[4]{name:"WallStreet",title:"Wall Street"},:DIRECTED[5]{},Node[0]{name:"Oliver Stone"}]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>

 match (martin:Person {name:"Martin Sheen"} ),
       (oliver:Person {name:"Oliver Stone"}),
       p = shortestPath( (martin)-[*..15]-(oliver) )
 return p</command></para></formalpara>
</section>
<section id="match-all-shortest-paths">
<title>All shortest paths</title>
<simpara>Finds all the shortest paths between two nodes.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (martin:Person { name:"Martin Sheen" }),(michael:Person { name:"Michael Douglas" }),
  p = allShortestPaths((martin)-[*]-(michael))
RETURN p</programlisting>
</para></formalpara>
<simpara>Finds the two shortest paths between Martin and Michael.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">p</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[Node[2]{name:"Martin Sheen"},:ACTED_IN[3]{},Node[3]{name:"TheAmericanPresident",title:"The American President"},:ACTED_IN[4]{},Node[6]{name:"Michael Douglas"}]</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>[Node[2]{name:"Martin Sheen"},:ACTED_IN[1]{},Node[4]{name:"WallStreet",title:"Wall Street"},:ACTED_IN[2]{},Node[6]{name:"Michael Douglas"}]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>

 match (martin:Person {name:"Martin Sheen"} ),
       (michael:Person {name:"Michael Douglas"}),
       p = allShortestPaths( (martin)-[*]-(michael) ) return p</command></para></formalpara>
</section>
</section>
</section>
<section id="query-optional-match">
<title>Optional Match</title>
<section id="_introduction_3">
<title>Introduction</title>
<simpara><literal>OPTIONAL</literal> <literal>MATCH</literal> matches patterns against your graph database, just like <literal>MATCH</literal> does.
The difference is that if no matches are found, <literal>OPTIONAL</literal> <literal>MATCH</literal> will use <literal>NULL</literal>s for missing parts of the pattern.
<literal>OPTIONAL</literal> <literal>MATCH</literal> could be considered the Cypher equivalent of the outer join in SQL.</simpara>
<simpara>Either the whole pattern is matched, or nothing is matched.
Remember that <literal>WHERE</literal> is part of the pattern description, and the predicates will be considered while looking for matches, not after.
This matters especially in the case of multiple (<literal>OPTIONAL</literal>) <literal>MATCH</literal> clauses, where it is crucial to put <literal>WHERE</literal> together with the <literal>MATCH</literal> it belongs to.</simpara>
<tip><simpara>To understand the patterns used in the <literal>OPTIONAL</literal> <literal>MATCH</literal> clause, read <xref linkend="introduction-pattern"/>.</simpara></tip>
<simpara>The following graph is used for the examples below:</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-optionalmatch-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-optionalmatch-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-optionalmatch-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
<section id="optional-match-relationship">
<title>Relationship</title>
<simpara>If a relationship is optional, use the <literal>OPTIONAL</literal> <literal>MATCH</literal> clause. This is similar to how a SQL outer join works. If the relationship is there, it is returned. If it&#8217;s not, <literal>NULL</literal> is returned in it&#8217;s place.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a:Movie { title: 'Wall Street' })
OPTIONAL MATCH (a)--&gt;(x)
RETURN x</programlisting>
</para></formalpara>
<simpara>Returns <literal>NULL</literal>, since the node has no outgoing relationships.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">x</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (a:Movie {title: 'Wall Street'}) optional match (a)--&gt;(x) return x</command></para></formalpara>
</section>
<section id="optional-match-properties-on-optional-elements">
<title>Properties on optional elements</title>
<simpara>Returning a property from an optional element that is <literal>NULL</literal> will also return <literal>NULL</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a:Movie { title: 'Wall Street' })
OPTIONAL MATCH (a)--&gt;(x)
RETURN x, x.name</programlisting>
</para></formalpara>
<simpara>Returns the element x (<literal>NULL</literal> in this query), and <literal>NULL</literal> as its name.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">x</entry><entry align="left" valign="top">x.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (a:Movie {title: 'Wall Street'}) optional match (a)--&gt;(x) return x, x.name</command></para></formalpara>
</section>
<section id="optional-match-optional-typed-and-named-relationship">
<title>Optional typed and named relationship</title>
<simpara>Just as with a normal relationship, you can decide which identifier it goes into, and what relationship type you need.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a:Movie { title: 'Wall Street' })
OPTIONAL MATCH (a)-[r:ACTS_IN]-&gt;()
RETURN r</programlisting>
</para></formalpara>
<simpara>This returns a node, and <literal>NULL</literal>, since the node has no outgoing <literal>ACTS_IN</literal> relationships.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (a:Movie {title: 'Wall Street'}) optional match (a)-[r:ACTS_IN]-&gt;() return r</command></para></formalpara>
</section>
</section>
<section id="query-where">
<title>Where</title>
<simpara><literal>WHERE</literal> is not a clause in it&#8217;s own right&#8201;&#8212;&#8201;rather, it&#8217;s part of <literal>MATCH</literal>, <literal>OPTIONAL</literal> <literal>MATCH</literal>, <literal>START</literal> and <literal>WITH</literal>.</simpara>
<simpara>In the case of <literal>WITH</literal> and <literal>START</literal>, <literal>WHERE</literal> simply filters the results.</simpara>
<simpara>For <literal>MATCH</literal> and <literal>OPTIONAL</literal> <literal>MATCH</literal> on the other hand, <literal>WHERE</literal> adds constraints to the patterns described.
It should not be seen as a filter after the matching is finished.</simpara>
<note><simpara>In the case of multiple (<literal>OPTIONAL</literal>) <literal>MATCH</literal> clauses, the predicate in <literal>WHERE</literal> is always a part of the patterns in the directly preceding <literal>MATCH</literal>.
Both results and performance may be impacted if the <literal>WHERE</literal> is put inside the wrong <literal>MATCH</literal> clause.</simpara></note>
<figure><title>Graph</title>
<ulink url="images/cypher-where-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-where-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-where-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="_basic_usage">
<title>Basic usage</title>
<section id="where-boolean-operations">
<title>Boolean operations</title>
<simpara>You can use the expected boolean operators <literal>AND</literal> and <literal>OR</literal>, and also the boolean function <literal>NOT</literal>. See <xref linkend="cypher-working-with-null"/> for more information on how this works with <literal>NULL</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.name = 'Peter' XOR (n.age &lt; 30 AND n.name = "Tobias") OR NOT (n.name = "Tobias" OR
  n.name="Peter")
RETURN n</programlisting>
</para></formalpara>
<simpara>This query shows how boolean operators can be used.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Tobias",age:25}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Peter",age:34}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Andres",age:36,belt:"white"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) where n.name = 'Peter' xor (n.age &lt; 30 and n.name = "Tobias") or not (n.name = "Tobias" or n.name="Peter") return n</command></para></formalpara>
</section>
<section id="where-filter-on-node-label">
<title>Filter on node label</title>
<simpara>To filter nodes by label, write a label predicate after the <literal>WHERE</literal> keyword using <literal>WHERE n:foo</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n:Swedish
RETURN n</programlisting>
</para></formalpara>
<simpara>The "<literal>Andres</literal>" node will be returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Andres",age:36,belt:"white"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) where n:Swedish return n</command></para></formalpara>
</section>
<section id="where-filter-on-node-property">
<title>Filter on node property</title>
<simpara>To filter on a property, write your clause after the <literal>WHERE</literal> keyword. Filtering on relationship properties works just the same way.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.age &lt; 30
RETURN n</programlisting>
</para></formalpara>
<simpara>The "<literal>Tobias</literal>" node will be returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Tobias",age:25}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) where n.age &lt; 30 return n</command></para></formalpara>
</section>
<section id="where-property-exists">
<title>Property exists</title>
<simpara>To only include nodes/relationships that have a property, use the <literal>HAS()</literal> function and just write out the identifier and the property you expect it to have.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE HAS (n.belt)
RETURN n</programlisting>
</para></formalpara>
<simpara>The node named "<literal>Andres</literal>" is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Andres",age:36,belt:"white"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) where has(n.belt) return n</command></para></formalpara>
</section>
</section>
<section id="_regular_expressions">
<title>Regular expressions</title>
<section id="where-regular-expressions">
<title>Regular expressions</title>
<simpara>You can match on regular expressions by using <literal>=~ "regexp"</literal>, like this:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.name =~ 'Tob.*'
RETURN n</programlisting>
</para></formalpara>
<simpara>The "<literal>Tobias</literal>" node will be returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Tobias",age:25}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) where n.name =~ 'Tob.*' return n</command></para></formalpara>
</section>
<section id="where-escaping-in-regular-expressions">
<title>Escaping in regular expressions</title>
<simpara>If you need a forward slash inside of your regular expression, escape it. Remember that back slash needs to be escaped in string literals</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.name =~ 'Some\/thing'
RETURN n</programlisting>
</para></formalpara>
<simpara>No nodes match this regular expression.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">0 row</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) where n.name =~ 'Some\\/thing' return n</command></para></formalpara>
</section>
<section id="where-case-insensitive-regular-expressions">
<title>Case insensitive regular expressions</title>
<simpara>By pre-pending a regular expression with <literal>(?i)</literal>, the whole expression becomes case insensitive.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.name =~ '(?i)ANDR.*'
RETURN n</programlisting>
</para></formalpara>
<simpara>The node with name "<literal>Andres</literal>" is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Andres",age:36,belt:"white"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) where n.name =~ '(?i)ANDR.*' return n</command></para></formalpara>
</section>
</section>
<section id="query-where-patterns">
<title>Using patterns in WHERE</title>
<section id="where-filter-on-patterns">
<title>Filter on patterns</title>
<simpara>Patterns are expressions in Cypher, expressions that return a collection of paths. Collection
expressions are also predicates&#8201;&#8212;&#8201;an empty collection represents <literal>false</literal>, and a non-empty represents <literal>true</literal>.</simpara>
<simpara>So, patterns are not only expressions, they are also predicates. The only limitation to your pattern is that you must be
able to express it in a single path. You can not use commas between multiple paths like you do in <literal>MATCH</literal>. You can achieve
the same effect by combining multiple patterns with <literal>AND</literal>.</simpara>
<simpara>Note that you can not introduce new identifiers here. Although it might look very similar to the <literal>MATCH</literal> patterns, the
<literal>WHERE</literal> clause is all about eliminating matched subgraphs. <literal>MATCH (a)-[*]-&gt;(b)</literal> is very different from <literal>WHERE (a)-[*]-&gt;(b)</literal>; the
first will produce a subgraph for every path it can find between <literal>a</literal> and <literal>b</literal>, and the latter will eliminate any matched
subgraphs where <literal>a</literal> and <literal>b</literal> do not have a directed relationship chain between them.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (tobias { name: 'Tobias' }),(others)
WHERE others.name IN ['Andres', 'Peter'] AND (tobias)&lt;--(others)
RETURN others</programlisting>
</para></formalpara>
<simpara>Nodes that have an outgoing relationship to the "<literal>Tobias</literal>" node are returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">others</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Andres",age:36,belt:"white"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (tobias {name: 'Tobias'}), (others) where others.name IN ['Andres', 'Peter'] and (tobias)&lt;--(others) return others</command></para></formalpara>
</section>
<section id="where-filter-on-patterns-using-not">
<title>Filter on patterns using NOT</title>
<simpara>The <literal>NOT</literal> function can be used to exclude a pattern.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (persons),(peter { name: 'Peter' })
WHERE NOT (persons)--&gt;(peter)
RETURN persons</programlisting>
</para></formalpara>
<simpara>Nodes that do not have an outgoing relationship to the "<literal>Peter</literal>" node are returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">persons</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Tobias",age:25}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Peter",age:34}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 MATCH (persons), (peter {name: 'Peter'}) where not (persons)--&gt;(peter) return persons</command></para></formalpara>
</section>
<section id="where-filter-on-patterns-with-properties">
<title>Filter on patterns with properties</title>
<simpara>You can also add properties to your patterns:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE (n)-[:KNOWS]-({ name:'Tobias' })
RETURN n</programlisting>
</para></formalpara>
<simpara>Finds all nodes that have a <literal>KNOWS</literal> relationship to a node with the name <literal>Tobias</literal>.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Andres",age:36,belt:"white"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) where (n)-[:KNOWS]-({name:'Tobias'}) return n</command></para></formalpara>
</section>
<section id="where-filtering-on-relationship-type">
<title>Filtering on relationship type</title>
<simpara>You can put the exact relationship type in the <literal>MATCH</literal> pattern, but sometimes you want to be able to do more advanced filtering on the type. You can use the special property <literal>TYPE</literal> to compare the type with something else. In this example, the query does a regular expression comparison with the name of the relationship type.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)-[r]-&gt;()
WHERE n.name='Andres' AND type(r)=~ 'K.*'
RETURN r</programlisting>
</para></formalpara>
<simpara>This returns relationships that has a type whose name starts with K.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>:KNOWS[0]{}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>:KNOWS[1]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n)-[r]-&gt;() where n.name='Andres' and type(r) =~ 'K.*' return r</command></para></formalpara>
</section>
</section>
<section id="_collections">
<title>Collections</title>
<section id="where-in-operator">
<title>IN operator</title>
<simpara>To check if an element exists in a collection, you can use the <literal>IN</literal> operator.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a)
WHERE a.name IN ["Peter", "Tobias"]
RETURN a</programlisting>
</para></formalpara>
<simpara>This query shows how to check if a property exists in a literal collection.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">a</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Tobias",age:25}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Peter",age:34}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (a) where a.name IN ["Peter", "Tobias"] return a</command></para></formalpara>
</section>
</section>
<section id="_missing_properties_and_values">
<title>Missing properties and values</title>
<section id="where-default-to-false-if-property-is-missing">
<title>Default to false if property is missing</title>
<simpara>As missing properties evaluate to <literal>NULL</literal>, the comparision in the example will evaluate to <literal>FALSE</literal> for nodes without the <literal>belt</literal> property.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.belt = 'white'
RETURN n</programlisting>
</para></formalpara>
<simpara>Only nodes with the belt property are returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Andres",age:36,belt:"white"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) where n.belt = 'white' return n</command></para></formalpara>
</section>
<section id="where-default-to-true-if-property-is-missing">
<title>Default to true if property is missing</title>
<simpara>If you want to compare a property on a graph element, but only if it exists, you can compare the property against both the value you are looking for and <literal>NULL</literal>, like:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.belt = 'white' OR n.belt IS NULL RETURN n
ORDER BY n.name</programlisting>
</para></formalpara>
<simpara>This returns all nodes, even those without the belt property.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Andres",age:36,belt:"white"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Peter",age:34}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Tobias",age:25}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n) where n.belt = 'white' or n.belt IS NULL return n order by n.name</command></para></formalpara>
</section>
<section id="where-filter-on-null">
<title>Filter on NULL</title>
<simpara>Sometimes you might want to test if a value or an identifier is <literal>NULL</literal>. This is done just like SQL does it, with <literal>IS NULL</literal>. Also like SQL, the negative is <literal>IS NOT NULL</literal>, although <literal>NOT(IS NULL x)</literal> also works.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (person)
WHERE person.name = 'Peter' AND person.belt IS NULL RETURN person</programlisting>
</para></formalpara>
<simpara>Nodes that Tobias is not connected to are returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">person</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Peter",age:34}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `belt`:"white", `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (person) where person.name = 'Peter' AND person.belt is null return person</command></para></formalpara>
</section>
</section>
</section>
<section id="query-start">
<title>Start</title>
<simpara>Every query describes a pattern, and in that pattern one can have multiple starting points.
A starting point is a relationship or a node where a pattern is anchored.
You can either introduce starting points by id, or by index lookups.
Note that trying to use an index that doesn&#8217;t exist will generate an error.</simpara>
<note><simpara><literal>START</literal> is optional.
If you do not specify explicit starting points, Cypher will try and infer starting points from your query.
This is done based on node labels and predicates contained in your query.
See <xref linkend="cypher-schema"/> for more information.
In general, the <literal>START</literal> clause is only really needed when using legacy indexes.</simpara></note>
<simpara>This is the graph the examples are using:</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-start-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-start-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-start-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="_get_node_or_relationship_from_index">
<title>Get node or relationship from index</title>
<section id="start-node-by-index-lookup">
<title>Node by index lookup</title>
<simpara>When the starting point can be found by using index lookups, it can be done like this: <literal>node:index-name(key = "value")</literal>. In this example, there exists a node index named <literal>nodes</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START n=node:nodes(name = "A")
RETURN n</programlisting>
</para></formalpara>
<simpara>The query returns the node indexed with the name "<literal>A</literal>".</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"A"}</literal></simpara></entry></row></tbody></tgroup></table>
</section>
<section id="start-relationship-by-index-lookup">
<title>Relationship by index lookup</title>
<simpara>When the starting point can be found by using index lookups, it can be done like this: <literal>relationship:index-name(key = "value")</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START r=relationship:rels(name = "Andrés")
RETURN r</programlisting>
</para></formalpara>
<simpara>The relationship indexed with the <literal>name</literal> property set to "<literal>Andrés</literal>" is returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>:KNOWS[0]{name:"Andrés"</literal></simpara></entry></row></tbody></tgroup></table>
</section>
<section id="start-node-by-index-query">
<title>Node by index query</title>
<simpara>When the starting point can be found by more complex Lucene queries, this is the syntax to use: <literal>node:index-name("query")</literal>.This allows you to write more advanced index queries.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START n=node:nodes("name:A")
RETURN n</programlisting>
</para></formalpara>
<simpara>The node indexed with name "A" is returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"A"}</literal></simpara></entry></row></tbody></tgroup></table>
</section>
</section>
<section id="_get_node_or_relationship_by_id">
<title>Get node or relationship by id</title>
<section id="start-node-by-id">
<title>Node by id</title>
<simpara>Binding a node as a starting point is done with the <literal>node(*)</literal> function.</simpara>
<note><simpara>Neo4j reuses its internal ids when nodes and relationships are deleted, which means it&#8217;s bad practice to refer to them this way. Instead, use application generated ids.</simpara></note>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START n=node(0)
RETURN n</programlisting>
</para></formalpara>
<simpara>The corresponding node is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"A"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"B"})
create (_2 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`KNOWS`]-&gt;_2
</database><command>
 start n=node(0) return n</command></para></formalpara>
</section>
<section id="start-relationship-by-id">
<title>Relationship by id</title>
<simpara>Binding a relationship as a starting point is done with the <literal>relationship(*)</literal> function, which can also be abbreviated <literal>rel(*)</literal>. See <xref linkend="start-node-by-id"/> for more information on Neo4j ids.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START r=relationship(0)
RETURN r</programlisting>
</para></formalpara>
<simpara>The relationship with id <literal>0</literal> is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>:KNOWS[0]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"B"})
create (_2 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`KNOWS`]-&gt;_2
</database><command>
 start r=relationship(0) return r</command></para></formalpara>
</section>
<section id="start-multiple-nodes-by-id">
<title>Multiple nodes by id</title>
<simpara>Multiple nodes are selected by listing them separated by commas.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START n=node(0, 1, 2)
RETURN n</programlisting>
</para></formalpara>
<simpara>This returns the nodes listed in the <literal>START</literal> statement.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"A"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"B"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"C"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"B"})
create (_2 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`KNOWS`]-&gt;_2
</database><command>
 start n=node(0, 1, 2) return n</command></para></formalpara>
</section>
</section>
<section id="_get_multiple_or_all_nodes">
<title>Get multiple or all nodes</title>
<section id="start-all-nodes">
<title>All nodes</title>
<simpara>To get all the nodes, use an asterisk.
This can be done with relationships as well.</simpara>
<tip><simpara>The preferred way to do this is to use a <literal>MATCH</literal> clause, see <xref linkend="match-get-all-nodes"/> in <xref linkend="query-match"/> for how to do that.</simpara></tip>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START n=node(*)
RETURN n</programlisting>
</para></formalpara>
<simpara>This query returns all the nodes in the graph.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"A"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"B"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"C"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"B"})
create (_2 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`KNOWS`]-&gt;_2
</database><command>
 start n=node(*) return n</command></para></formalpara>
</section>
<section id="start-multiple-starting-points">
<title>Multiple starting points</title>
<simpara>Sometimes you want to bind multiple starting points. Just list them separated by commas.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START a=node(0), b=node(1)
RETURN a,b</programlisting>
</para></formalpara>
<simpara>Both the nodes <literal>A</literal> and the <literal>B</literal>  are returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">a</entry><entry align="left" valign="top">b</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"A"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[1]{name:"B"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"B"})
create (_2 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_1
create _0-[:`KNOWS`]-&gt;_2
</database><command>
 start a=node(0), b=node(1) return a,b</command></para></formalpara>
</section>
</section>
</section>
<section id="query-aggregation">
<title>Aggregation</title>
<section id="aggregation-introduction">
<title>Introduction</title>
<simpara>To calculate aggregated data, Cypher offers aggregation, much like SQL&#8217;s <literal>GROUP BY</literal>.</simpara>
<simpara>Aggregate functions take multiple input values and calculate an aggregated value from them.
Examples are <literal>avg</literal> that calculates the average of multiple numeric values, or <literal>min</literal> that finds the smallest numeric value in a set of values.</simpara>
<simpara>Aggregation can be done over all the matching sub graphs, or it can be further divided by introducing key values.
These are non-aggregate expressions, that are used to group the values going into the aggregate functions.</simpara>
<simpara>So, if the return statement looks something like this:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">RETURN n, count(*)</programlisting>
<simpara>We have two return expressions&#8201;&#8212;&#8201;<literal>n</literal>, and <literal>count(*)</literal>.
The first, <literal>n</literal>, is no aggregate function, and so it will be the grouping key.
The latter, <literal>count(*)</literal> is an aggregate expression.
So the matching subgraphs will be divided into different buckets, depending on the grouping key.
The aggregate function will then run on these buckets, calculating the aggregate values.</simpara>
<simpara>If you want to use aggregations to sort your result set, the aggregation must be included in the <literal>RETURN</literal> to be used in your <literal>ORDER BY</literal>.</simpara>
<simpara>The last piece of the puzzle is the <literal>DISTINCT</literal> keyword.
It is used to make all values unique before running them through an aggregate function.</simpara>
<simpara>An example might be helpful.
In this case, we are running the query against the following data:</simpara>
<informalfigure>
<ulink url="images/aggregation-introduction.preparation-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/aggregation-introduction.preparation-graph.svg"/>
  </imageobject>
  <textobject><phrase>aggregation-introduction.preparation-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (me:Person)--&gt;(friend:Person)--&gt;(friend_of_friend:Person)
WHERE me.name = 'A'
RETURN count(DISTINCT friend_of_friend), count(friend_of_friend)</programlisting>
</para></formalpara>
<simpara>In this example we are trying to find all our friends of friends, and count them.
The first aggregate function, <literal>count(DISTINCT friend_of_friend)</literal>, will only see a <literal>friend_of_friend</literal> once&#8201;&#8212;&#8201;<literal>DISTINCT</literal> removes the duplicates.
The latter aggregate function, <literal>count(friend_of_friend)</literal>, might very well see the same <literal>friend_of_friend</literal> multiple times.
In this case, both <literal>B</literal> and <literal>C</literal> know <literal>D</literal> and thus <literal>D</literal> will get counted twice, when not using <literal>DISTINCT</literal>.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">count(distinct friend_of_friend)</entry><entry align="left" valign="top">count(friend_of_friend)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 MATCH (me:Person)--&gt;(friend:Person)--&gt;(friend_of_friend:Person) WHERE me.name = 'A'RETURN count(distinct friend_of_friend), count(friend_of_friend)</command></para></formalpara>
<simpara>The following examples are assuming the example graph structure below.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-aggregation-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-aggregation-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-aggregation-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
<section id="_count">
<title>COUNT</title>
<simpara><literal>COUNT</literal> is used to count the number of rows.
<literal>COUNT</literal> can be used in two forms&#8201;&#8212;&#8201;<literal>COUNT(*)</literal> which just counts the number of matching rows, and <literal>COUNT(&lt;identifier&gt;)</literal>, which counts the number of non-<literal>NULL</literal> values in <literal>&lt;identifier&gt;</literal>.</simpara>
<section id="aggregation-count-nodes">
<title>Count nodes</title>
<simpara>To count the number of nodes, for example the number of nodes connected to one node, you can use <literal>count(*)</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'A' })--&gt;(x)
RETURN n, count(*)</programlisting>
</para></formalpara>
<simpara>This returns the start node and the count of related nodes.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">n</entry><entry align="left" valign="top">count(*)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"A",property:13}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n {name: 'A'})--&gt;(x) return n, count(*)</command></para></formalpara>
</section>
<section id="aggregation-group-count-relationship-types">
<title>Group Count Relationship Types</title>
<simpara>To count the groups of relationship types, return the types and count them with <literal>count(*)</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'A' })-[r]-&gt;()
RETURN type(r), count(*)</programlisting>
</para></formalpara>
<simpara>The relationship types and their group count is returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">type(r)</entry><entry align="left" valign="top">count(*)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"KNOWS"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n {name: 'A'})-[r]-&gt;() return type(r), count(*)</command></para></formalpara>
</section>
<section id="aggregation-count-entities">
<title>Count entities</title>
<simpara>Instead of counting the number of results with <literal>count(*)</literal>, it might be more expressive to include the name of the identifier you care about.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'A' })--&gt;(x)
RETURN count(x)</programlisting>
</para></formalpara>
<simpara>The example query returns the number of connected nodes from the start node.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">count(x)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n {name: 'A'})--&gt;(x) return count(x)</command></para></formalpara>
</section>
<section id="aggregation-count-non-null-values">
<title>Count non-null values</title>
<simpara>You can count the non-<literal>null</literal> values by using <literal>count(&lt;identifier&gt;)</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n:Person)
RETURN count(n.property)</programlisting>
</para></formalpara>
<simpara>The count of related nodes with the <literal>property</literal> property set is returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">count(n.property)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n:Person) return count(n.property)</command></para></formalpara>
</section>
</section>
<section id="_statistics">
<title>Statistics</title>
<section id="aggregation-sum">
<title>sum</title>
<simpara>The <literal>sum</literal> aggregation function simply sums all the numeric values it encounters. <literal>NULL</literal>s are silently dropped.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n:Person)
RETURN sum(n.property)</programlisting>
</para></formalpara>
<simpara>This returns the sum of all the values in the property <literal>property</literal>.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">sum(n.property)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>90</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n:Person) return sum(n.property)</command></para></formalpara>
</section>
<section id="aggregation-avg">
<title>avg</title>
<simpara><literal>avg</literal> calculates the average of a numeric column.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n:Person)
RETURN avg(n.property)</programlisting>
</para></formalpara>
<simpara>The average of all the values in the property <literal>property</literal> is returned by the example query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">avg(n.property)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>30.0</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n:Person) return avg(n.property)</command></para></formalpara>
</section>
<section id="aggregation-percentiledisc">
<title>percentileDisc</title>
<simpara><literal>percentileDisc</literal> calculates the percentile of a given value over a group, with a percentile from 0.0 to 1.0.
It uses a rounding method, returning the nearest value to the percentile.
For interpolated values, see <literal>percentileCont</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n:Person)
RETURN percentileDisc(n.property, 0.5)</programlisting>
</para></formalpara>
<simpara>The 50th percentile of the values in the property <literal>property</literal> is returned by the example query. In this case, 0.5 is the median, or 50th percentile.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">percentileDisc(n.property, 0.5)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>33</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n:Person) return percentileDisc(n.property, 0.5)</command></para></formalpara>
</section>
<section id="aggregation-percentilecont">
<title>percentileCont</title>
<simpara><literal>percentileCont</literal> calculates the percentile of a given value over a group, with a percentile from 0.0 to 1.0.
It uses a linear interpolation method, calculating a weighted average between two values, if the desired percentile lies between them.
For nearest values using a rounding method, see <literal>percentileDisc</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n:Person)
RETURN percentileCont(n.property, 0.4)</programlisting>
</para></formalpara>
<simpara>The 40th percentile of the values in the property <literal>property</literal> is returned by the example query, calculated with a weighted average.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">percentileCont(n.property, 0.4)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>29.0</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n:Person) return percentileCont(n.property, 0.4)</command></para></formalpara>
</section>
<section id="aggregation-stdev">
<title>stdev</title>
<simpara><literal>stdev</literal> calculates the standard deviation for a given value over a group.
It uses a standard two-pass method, with <literal>N - 1</literal> as the denominator, and should be used when taking a sample of the population for an unbiased estimate.
When the standard variation of the entire population is being calculated, <literal>stdevp</literal> should be used.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.name IN ['A', 'B', 'C']
RETURN stdev(n.property)</programlisting>
</para></formalpara>
<simpara>The standard deviation of the values in the property <literal>property</literal> is returned by the example query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">stdev(n.property)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>15.716233645501712</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n) where n.name IN ['A','B','C'] return stdev(n.property)</command></para></formalpara>
</section>
<section id="aggregation-stdevp">
<title>stdevp</title>
<simpara><literal>stdevp</literal> calculates the standard deviation for a given value over a group.
It uses a standard two-pass method, with <literal>N</literal> as the denominator, and should be used when calculating the standard deviation for an entire population.
When the standard variation of only a sample of the population is being calculated, <literal>stdev</literal> should be used.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.name IN ['A', 'B', 'C']
RETURN stdevp(n.property)</programlisting>
</para></formalpara>
<simpara>The population standard deviation of the values in the property <literal>property</literal> is returned by the example query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">stdevp(n.property)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>12.832251036613439</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n) where n.name IN ['A','B','C'] return stdevp(n.property)</command></para></formalpara>
</section>
<section id="aggregation-max">
<title>max</title>
<simpara><literal>max</literal> find the largest value in a numeric column.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n:Person)
RETURN max(n.property)</programlisting>
</para></formalpara>
<simpara>The largest of all the values in the property <literal>property</literal> is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">max(n.property)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>44</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n:Person) return max(n.property)</command></para></formalpara>
</section>
<section id="aggregation-min">
<title>min</title>
<simpara><literal>min</literal> takes a numeric property as input, and returns the smallest value in that column.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n:Person)
RETURN min(n.property)</programlisting>
</para></formalpara>
<simpara>This returns the smallest of all the values in the property <literal>property</literal>.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">min(n.property)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>13</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n:Person) return min(n.property)</command></para></formalpara>
</section>
</section>
<section id="aggregation-collect">
<title>collect</title>
<simpara><literal>collect</literal> collects all the values into a list. It will ignore <literal>NULL</literal>s.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n:Person)
RETURN collect(n.property)</programlisting>
</para></formalpara>
<simpara>Returns a single row, with all the values collected.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">collect(n.property)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[13,33,44]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (n:Person) return collect(n.property)</command></para></formalpara>
</section>
<section id="aggregation-distinct">
<title>DISTINCT</title>
<simpara>All aggregation functions also take the <literal>DISTINCT</literal> modifier, which removes duplicates from the values.
So, to count the number of unique eye colors from nodes related to <literal>a</literal>, this query can be used:</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a:Person { name: 'A' })--&gt;(b)
RETURN count(DISTINCT b.eyes)</programlisting>
</para></formalpara>
<simpara>Returns the number of eye colors.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">count(distinct b.eyes)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`eyes`:"brown", `name`:"D"})
create (_1:`Person` {`name`:"A", `property`:13})
create (_2:`Person` {`eyes`:"blue", `name`:"B", `property`:33})
create (_3:`Person` {`eyes`:"blue", `name`:"C", `property`:44})
create _1-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _1-[:`KNOWS`]-&gt;_0
</database><command>
 match (a:Person {name: 'A'})--&gt;(b) return count(distinct b.eyes)</command></para></formalpara>
</section>
</section>
</chapter>
<chapter id="query-write">
<title>Writing Clauses</title>
<simpara>Write data to the database.</simpara>
<section id="query-create">
<title>Create</title>
<simpara>Creating graph elements&#8201;&#8212;&#8201;nodes and relationships, is done with <literal>CREATE</literal>.</simpara>
<tip><simpara>In the <literal>CREATE</literal> clause, patterns are used a lot.
Read <xref linkend="introduction-pattern"/> for an introduction.</simpara></tip>
<section id="_create_nodes">
<title>Create nodes</title>
<section id="create-create-single-node">
<title>Create single node</title>
<simpara>Creating a single node is done by issuing the following query.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (n)</programlisting>
</para></formalpara>
<simpara>Nothing is returned from this query, except the count of affected nodes.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>(0)
</database><command>create (n)</command></para></formalpara>
</section>
<section id="create-create-a-node-with-a-label">
<title>Create a node with a label</title>
<simpara>To add a label when creating a node, use the syntax below.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (n:Person)</programlisting>
</para></formalpara>
<simpara>Nothing is returned from this query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 1</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>(0)
</database><command>create (n:Person)</command></para></formalpara>
</section>
<section id="create-create-a-node-with-multiple-labels">
<title>Create a node with multiple labels</title>
<simpara>To add labels when creating a node, use the syntax below. In this case, we add two labels.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (n:Person:Swedish)</programlisting>
</para></formalpara>
<simpara>Nothing is returned from this query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 2</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>(0)
</database><command>create (n:Person:Swedish)</command></para></formalpara>
</section>
<section id="create-create-node-and-add-labels-and-properties">
<title>Create node and add labels and properties</title>
<simpara>When creating a new node with labels, you can add properties at the same time.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (n:Person { name : 'Andres', title : 'Developer' })</programlisting>
</para></formalpara>
<simpara>Nothing is returned from this query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 2
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 1</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>(0)
</database><command>create (n:Person {name : 'Andres', title : 'Developer'})</command></para></formalpara>
</section>
<section id="create-return-created-node">
<title>Return created node</title>
<simpara>Creating a single node is done by issuing the following query.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (a { name : 'Andres' })
RETURN a</programlisting>
</para></formalpara>
<simpara>The newly created node is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">a</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Andres"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>(0)
</database><command>create (a {name : 'Andres'}) return a</command></para></formalpara>
</section>
</section>
<section id="_create_relationships">
<title>Create relationships</title>
<section id="create-create-a-relationship-between-two-nodes">
<title>Create a relationship between two nodes</title>
<simpara>To create a relationship between two nodes, we first get the two nodes. Once the nodes are loaded, we simply create a relationship between them.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a:Person),(b:Person)
WHERE a.name = 'Node A' AND b.name = 'Node B'
CREATE (a)-[r:RELTYPE]-&gt;(b)
RETURN r</programlisting>
</para></formalpara>
<simpara>The created relationship is returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>:RELTYPE[1]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Node A"})
create (_1:`Person` {`name`:"Node B"})
</database><command>
 match (a:Person), (b:Person) where a.name = 'Node A' and b.name = 'Node B' create (a)-[r:RELTYPE]-&gt;(b) return r</command></para></formalpara>
</section>
<section id="create-create-a-relationship-and-set-properties">
<title>Create a relationship and set properties</title>
<simpara>Setting properties on relationships is done in a similar manner to how it&#8217;s done when creating nodes. Note that the values can be any expression.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a:Person),(b:Person)
WHERE a.name = 'Node A' AND b.name = 'Node B'
CREATE (a)-[r:RELTYPE { name : a.name + '&lt;-&gt;' + b.name }]-&gt;(b)
RETURN r</programlisting>
</para></formalpara>
<simpara>The newly created relationship is returned by the example query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>:RELTYPE[1]{name:"Node A&lt;-&gt;Node B"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Person` {`name`:"Node A"})
create (_1:`Person` {`name`:"Node B"})
</database><command>
 match (a:Person), (b:Person) where a.name = 'Node A' and b.name = 'Node B' create (a)-[r:RELTYPE {name : a.name + '&lt;-&gt;' + b.name }]-&gt;(b) return r</command></para></formalpara>
</section>
</section>
<section id="create-create-a-full-path">
<title>Create a full path</title>
<simpara>When you use <literal>CREATE</literal> and a pattern, all parts of the pattern that are not already in scope at this time
will be created.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE p =(andres { name:'Andres' })-[:WORKS_AT]-&gt;(neo)&lt;-[:WORKS_AT]-(michael { name:'Michael' })
RETURN p</programlisting>
</para></formalpara>
<simpara>This query creates three nodes and two relationships in one go, assigns it to a path identifier, and returns it.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">p</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 3
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 2
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 2</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[Node[3]{name:"Andres"},:WORKS_AT[2]{},Node[4]{},:WORKS_AT[3]{},Node[5]{name:"Michael"}]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>(0)
</database><command>create p = (andres {name:'Andres'})-[:WORKS_AT]-&gt;(neo)&lt;-[:WORKS_AT]-(michael {name:'Michael'}) return p</command></para></formalpara>
</section>
<section id="_use_parameters_with_create">
<title>Use parameters with CREATE</title>
<section id="create-create-node-with-a-parameter-for-the-properties">
<title>Create node with a parameter for the properties</title>
<simpara>You can also create a graph entity from a map.
All the key/value pairs in the map will be set as properties on the created relationship or node.
In this case we add a <literal>Person</literal> label to the node as well.</simpara>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "props" : {
    "name" : "Andres",
    "position" : "Developer"
  }
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (n:Person { props })
RETURN n</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 2
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Andres",position:"Developer"}</literal></simpara></entry></row></tbody></tgroup></table>
</section>
<section id="create-create-multiple-nodes-with-a-parameter-for-their-properties">
<title>Create multiple nodes with a parameter for their properties</title>
<simpara>By providing Cypher an array of maps, it will create a node for each map.</simpara>
<note><simpara>When you do this, you can&#8217;t create anything else in the same <literal>CREATE</literal> clause.</simpara></note>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "props" : [ {
    "name" : "Andres",
    "position" : "Developer"
  }, {
    "name" : "Michael",
    "position" : "Developer"
  } ]
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (n { props })
RETURN n</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 2
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 4</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Andres",position:"Developer"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"Michael",position:"Developer"}</literal></simpara></entry></row></tbody></tgroup></table>
</section>
</section>
</section>
<section id="query-create-unique">
<title>Create Unique</title>
<simpara><literal>CREATE UNIQUE</literal> is in the middle of <literal>MATCH</literal> and <literal>CREATE</literal>&#8201;&#8212;&#8201;it will match what it can, and create what is missing.
<literal>CREATE UNIQUE</literal> will always make the least change possible to the graph&#8201;&#8212;&#8201;if it can use parts of the existing graph, it will.</simpara>
<simpara>Another difference to <literal>MATCH</literal> is that <literal>CREATE UNIQUE</literal> assumes the pattern to be unique.
If multiple matching subgraphs are found an error will be generated.</simpara>
<tip><simpara>In the <literal>CREATE UNIQUE</literal> clause, patterns are used a lot.
Read <xref linkend="introduction-pattern"/> for an introduction.</simpara></tip>
<simpara>The examples start out with the following data set:</simpara>
<informalfigure>
<ulink url="images/cypher-createunique-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-createunique-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-createunique-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<section id="_create_unique_nodes">
<title>Create unique nodes</title>
<section id="create-unique-create-node-if-missing">
<title>Create node if missing</title>
<simpara>If the pattern described needs a node, and it can&#8217;t be matched, a new node will be created.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (root { name: 'root' })
CREATE UNIQUE (root)-[:LOVES]-(someone)
RETURN someone</programlisting>
</para></formalpara>
<simpara>The root node doesn&#8217;t have any <literal>LOVES</literal> relationships, and so a node is created, and also a relationship to that node.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">someone</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[5]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"root"})
create (_2 {`name`:"B"})
create (_3 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_3
create _1-[:`X`]-&gt;_0
create _1-[:`X`]-&gt;_2
create _1-[:`X`]-&gt;_3
</database><command>
 match (root {name: 'root'}) create unique (root)-[:LOVES]-(someone) return someone</command></para></formalpara>
</section>
<section id="create-unique-create-nodes-with-values">
<title>Create nodes with values</title>
<simpara>The pattern described can also contain values on the node. These are given using the following syntax: <literal>prop : &lt;expression&gt;</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (root { name: 'root' })
CREATE UNIQUE (root)-[:X]-(leaf { name:'D' })
RETURN leaf</programlisting>
</para></formalpara>
<simpara>No node connected with the root node has the name <literal>D</literal>, and so a new node is created to match the pattern.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">leaf</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[5]{name:"D"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"root"})
create (_2 {`name`:"B"})
create (_3 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_3
create _1-[:`X`]-&gt;_0
create _1-[:`X`]-&gt;_2
create _1-[:`X`]-&gt;_3
</database><command>
 match (root {name: 'root'}) create unique (root)-[:X]-(leaf {name:'D'} ) return leaf</command></para></formalpara>
</section>
<section id="create-unique-create-labeled-node-if-missing">
<title>Create labeled node if missing</title>
<simpara>If the pattern described needs a labeled node and there is none with the given labels, Cypher will create a new one.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a { name: 'A' })
CREATE UNIQUE (a)-[:KNOWS]-(c:blue)
RETURN c</programlisting>
</para></formalpara>
<simpara>The A node is connected in a <literal>KNOWS</literal> relationship to the c node, but since C doesn&#8217;t have the <literal>:blue</literal> label, a new node labeled as <literal>:blue</literal> is created along with a <literal>KNOWS</literal> relationship from A to it.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">c</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[5]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"root"})
create (_2 {`name`:"B"})
create (_3 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_3
create _1-[:`X`]-&gt;_0
create _1-[:`X`]-&gt;_2
create _1-[:`X`]-&gt;_3
</database><command>
 match (a {name: 'A'}) create unique (a)-[:KNOWS]-(c:blue) return c</command></para></formalpara>
</section>
</section>
<section id="_create_unique_relationships">
<title>Create unique relationships</title>
<section id="create-unique-create-relationship-if-it-is-missing">
<title>Create relationship if it is missing</title>
<simpara><literal>CREATE UNIQUE</literal> is used to describe the pattern that should be found or created.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (lft { name: 'A' }),(rgt)
WHERE rgt.name IN ['B', 'C']
CREATE UNIQUE (lft)-[r:KNOWS]-&gt;(rgt)
RETURN r</programlisting>
</para></formalpara>
<simpara>The left node is matched agains the two right nodes. One relationship already exists and can be matched, and the other relationship is created before it is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>:KNOWS[5]{}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>:KNOWS[3]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"root"})
create (_2 {`name`:"B"})
create (_3 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_3
create _1-[:`X`]-&gt;_0
create _1-[:`X`]-&gt;_2
create _1-[:`X`]-&gt;_3
</database><command>
 match (lft {name: 'A'}), (rgt) where rgt.name in ['B','C'] create unique (lft)-[r:KNOWS]-&gt;(rgt) return r</command></para></formalpara>
</section>
<section id="create-unique-create-relationship-with-values">
<title>Create relationship with values</title>
<simpara>Relationships to be created can also be matched on values.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (root { name: 'root' })
CREATE UNIQUE (root)-[r:X { since:'forever' }]-()
RETURN r</programlisting>
</para></formalpara>
<simpara>In this example, we want the relationship to have a value, and since no such relationship can be found, a new node and relationship are created. Note that since we are not interested in the created node, we don&#8217;t name it.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>:X[5]{since:"forever"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"root"})
create (_2 {`name`:"B"})
create (_3 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_3
create _1-[:`X`]-&gt;_0
create _1-[:`X`]-&gt;_2
create _1-[:`X`]-&gt;_3
</database><command>
 match (root {name: 'root'}) create unique (root)-[r:X {since:'forever'}]-() return r</command></para></formalpara>
</section>
</section>
<section id="create-unique-describe-complex-pattern">
<title>Describe complex pattern</title>
<simpara>The pattern described by <literal>CREATE UNIQUE</literal> can be separated by commas, just like in <literal>MATCH</literal> and <literal>CREATE</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (root { name: 'root' })
CREATE UNIQUE (root)-[:FOO]-&gt;(x),(root)-[:BAR]-&gt;(x)
RETURN x</programlisting>
</para></formalpara>
<simpara>This example pattern uses two paths, separated by a comma.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">x</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 2</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[5]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"root"})
create (_2 {`name`:"B"})
create (_3 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_3
create _1-[:`X`]-&gt;_0
create _1-[:`X`]-&gt;_2
create _1-[:`X`]-&gt;_3
</database><command>
 match (root {name: 'root'}) create unique (root)-[:FOO]-&gt;(x), (root)-[:BAR]-&gt;(x) return x</command></para></formalpara>
</section>
</section>
<section id="query-merge">
<title>Merge</title>
<section id="_introduction_4">
<title>Introduction</title>
<caution>
<title>Provisional Feature</title>
<simpara><literal>MERGE</literal> is a new addition and a provisional feature of Cypher.
Its scope and syntax are subject to change.
Therefore, please be aware that you may need to change queries that use <literal>MERGE</literal> in the future.</simpara>
</caution>
<simpara><literal>MERGE</literal> ensures that a pattern exists in the graph.
Either the pattern already exists, or it needs to be created.</simpara>
<simpara><literal>MERGE</literal> either matches existing nodes and binds them, or it creates new data and binds that.
It&#8217;s like a combination of <literal>MATCH</literal> and <literal>CREATE</literal> that additionally allows you to specify what happens if the data was matched or created.</simpara>
<simpara>For example, you can specify that the graph must contain a node for a user with a certain name.
If there isn&#8217;t a node with the correct name, a new node will be created and its name property set.</simpara>
<simpara>When using <literal>MERGE</literal> on full patterns, the behavior is that either the whole pattern matches, or the whole pattern is created.
<literal>MERGE</literal> will not partially use existing patterns&#8201;&#8212;&#8201;it&#8217;s all or nothing.
If partial matches are needed, this can be accomplished by splitting a pattern up into multiple <literal>MERGE</literal> clauses.</simpara>
<simpara>As with <literal>MATCH</literal>, <literal>MERGE</literal> can match multiple occurrences of a pattern.
If there are multiple matches, they will all be passed on to later stages of the query.</simpara>
<simpara>The last part of <literal>MERGE</literal> is the <literal>ON CREATE</literal> and <literal>ON MATCH</literal>.
These allow a query to express additional changes to the properties of a node or relationship, depending on if the element was <literal>MATCH</literal>ed in the database or if it was <literal>CREATE</literal>d.</simpara>
<simpara>The following graph is used for the examples below:</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-merge-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-merge-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-merge-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
<section id="_merge_nodes">
<title>Merge nodes</title>
<section id="merge-merge-single-node-with-a-label">
<title>Merge single node with a label</title>
<simpara>Merging a single node with a given label.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MERGE (robert:Critic)
RETURN robert, labels(robert)</programlisting>
</para></formalpara>
<simpara>Because there are no nodes labeled <literal>Critic</literal> in the database, a new node is created.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">robert</entry><entry align="left" valign="top">labels(robert)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col2">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col2">Labels added: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[8]{}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>["Critic"]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create constraint on (n:`Person`) assert n.`name` is unique
create constraint on (n:`Person`) assert n.`role` is unique
create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 merge (robert:Critic)
 return robert, labels(robert)</command></para></formalpara>
</section>
<section id="merge-merge-single-node-with-properties">
<title>Merge single node with properties</title>
<simpara>Merging a single node with properties where not all properties match any existing node.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MERGE (charlie { name:'Charlie Sheen', age:10 })
RETURN charlie</programlisting>
</para></formalpara>
<simpara>A new node with the name Charlie Sheen will be created since not all properties matched the existing Charlie Sheen node.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">charlie</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 2</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[8]{name:"Charlie Sheen",age:10}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create constraint on (n:`Person`) assert n.`name` is unique
create constraint on (n:`Person`) assert n.`role` is unique
create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 merge (charlie {name:'Charlie Sheen', age:10})
 return charlie</command></para></formalpara>
</section>
<section id="merge-merge-single-node-specifying-both-label-and-property">
<title>Merge single node specifying both label and property</title>
<simpara>Merging a single node with both label and property matching an existing node.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MERGE (michael:Person { name:'Michael Douglas' })
RETURN michael</programlisting>
</para></formalpara>
<simpara>Michael Douglas will be matched and returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">michael</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[6]{name:"Michael Douglas"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create constraint on (n:`Person`) assert n.`name` is unique
create constraint on (n:`Person`) assert n.`role` is unique
create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 merge (michael:Person {name:'Michael Douglas'})
 return michael</command></para></formalpara>
</section>
</section>
<section id="_use_on_create_and_on_match">
<title>Use ON CREATE and ON MATCH</title>
<section id="merge-merge-with-on-create">
<title>Merge with ON CREATE</title>
<simpara>Merge a node and set properties if the node needs to be created.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MERGE (keanu:Person { name:'Keanu Reeves' })
ON CREATE SET keanu.created = timestamp()
RETURN keanu</programlisting>
</para></formalpara>
<simpara>Creates the Keanu node, and sets a timestamp on creation time.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">keanu</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 2
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[8]{created:1390989343699,name:"Keanu Reeves"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create constraint on (n:`Person`) assert n.`name` is unique
create constraint on (n:`Person`) assert n.`role` is unique
create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 merge (keanu:Person {name:'Keanu Reeves'})
 on create set keanu.created = timestamp()
 return keanu</command></para></formalpara>
</section>
<section id="merge-merge-with-on-match">
<title>Merge with ON MATCH</title>
<simpara>Merging nodes and setting properties on found nodes.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MERGE (person:Person)
ON MATCH SET person.found = TRUE RETURN person</programlisting>
</para></formalpara>
<simpara>Finds all the <literal>Person</literal> nodes, sets a property on them, and returns them.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">person</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">5 rows
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 5</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Oliver Stone",found:true}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Charlie Sheen",found:true}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Martin Sheen",found:true}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[5]{name:"Rob Reiner",found:true}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[6]{name:"Michael Douglas",found:true}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create constraint on (n:`Person`) assert n.`name` is unique
create constraint on (n:`Person`) assert n.`role` is unique
create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 merge (person:Person)
 on match set person.found = true
 return person</command></para></formalpara>
</section>
<section id="merge-merge-with-on-create-and-on-match">
<title>Merge with ON CREATE and ON MATCH</title>
<simpara>Merge a node and set properties if the node needs to be created.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MERGE (keanu:Person { name:'Keanu Reeves' })
ON CREATE SET keanu.created = timestamp()
ON MATCH SET keanu.lastSeen = timestamp()
RETURN keanu</programlisting>
</para></formalpara>
<simpara>The query creates the Keanu node, and sets a timestamp on creation time. If Keanu already existed, a different property would have been set.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">keanu</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 2
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[8]{created:1390989346100,name:"Keanu Reeves"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create constraint on (n:`Person`) assert n.`name` is unique
create constraint on (n:`Person`) assert n.`role` is unique
create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 merge (keanu:Person {name:'Keanu Reeves'})
 on create set keanu.created = timestamp()
 on match set keanu.lastSeen = timestamp()
 return keanu</command></para></formalpara>
</section>
</section>
<section id="_merge_relationships">
<title>Merge relationships</title>
<section id="merge-merge-on-a-relationship">
<title>Merge on a relationship</title>
<simpara><literal>MERGE</literal> can be used to match or create a relationship.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (charlie:Person { name:'Charlie Sheen' }),(wallStreet:Movie { title:'Wall Street' })
MERGE (charlie)-[r:ACTED_IN]-&gt;(wallStreet)
RETURN r</programlisting>
</para></formalpara>
<simpara>Charlie Sheen had already been marked as acting on Wall Street, so the existing relationship is found and returned. Note that in order to match or create a relationship when using <literal>MERGE</literal>, at least one bound node must be specified, which is done via the <literal>MATCH</literal> clause in the above example.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>:ACTED_IN[0]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create constraint on (n:`Person`) assert n.`name` is unique
create constraint on (n:`Person`) assert n.`role` is unique
create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (charlie:Person {name:'Charlie Sheen'}), (wallStreet:Movie {title:'Wall Street'})
 merge (charlie)-[r:ACTED_IN]-&gt;(wallStreet)
 return r</command></para></formalpara>
</section>
<section id="merge-merge-on-multiple-relationships">
<title>Merge on multiple relationships</title>
<simpara>When <literal>MERGE</literal> is used on a whole pattern, either everything matches, or everything is created.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (oliver:Person { name:'Oliver Stone' }),(reiner:Person { name:'Rob Reiner' })
MERGE (oliver)-[:DIRECTED]-&gt;(movie:Movie)&lt;-[:ACTED_IN]-(reiner)
RETURN movie</programlisting>
</para></formalpara>
<simpara>In our example graph, Oliver Stone and Rob Reiner have never worked together. When we try to <literal>MERGE</literal> a movie between them, Cypher will not use any of the existing movies already connected to either person. Instead, a new movie node is created.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">movie</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships created: 2
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[8]{}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create constraint on (n:`Person`) assert n.`name` is unique
create constraint on (n:`Person`) assert n.`role` is unique
create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 match (oliver:Person {name:'Oliver Stone'}), (reiner:Person {name:'Rob Reiner'})
 merge (oliver)-[:DIRECTED]-&gt;(movie:Movie)&lt;-[:ACTED_IN]-(reiner)
 return movie</command></para></formalpara>
</section>
</section>
<section id="_using_unique_constraints_with_merge">
<title>Using unique constraints with MERGE</title>
<simpara>Cypher prevents getting conflicting results from <literal>MERGE</literal> when using patterns that involve uniqueness constrains.
In this case, there must be at most one node that matches that pattern.</simpara>
<simpara>For example, given two uniqueness constraints on <literal>:Person(id)</literal> and <literal>:Person(ssn)</literal>: then a query such as <literal>MERGE (n:Person {id: 12, ssn: 437})</literal> will fail, if there are two different nodes (one with <literal>id</literal> 12 and one with <literal>ssn</literal> 437) or if there is only one node with only one of the properties.
In other words, there must be exactly one node that matches the pattern, or no matching nodes.</simpara>
<simpara>Note that the following examples assume the existence of uniqueness constraints that have been created using:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE CONSTRAINT ON (n:Person) ASSERT n.name IS UNIQUE;
CREATE CONSTRAINT ON (n:Person) ASSERT n.role IS UNIQUE;</programlisting>
<section id="merge-merge-using-unique-constraints-creates-a-new-node-if-no-node-is-found">
<title>Merge using unique constraints creates a new node if no node is found</title>
<simpara>Merge using unique constraints creates a new node if no node is found.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MERGE (laurence:Person { name: 'Laurence Fishburne' })
RETURN laurence</programlisting>
</para></formalpara>
<simpara>The query creates the laurence node. If laurence already existed, merge would just return the existing node.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">laurence</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[8]{name:"Laurence Fishburne"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create constraint on (n:`Person`) assert n.`name` is unique
create constraint on (n:`Person`) assert n.`role` is unique
create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 merge (laurence:Person {name: 'Laurence Fishburne'}) return laurence</command></para></formalpara>
</section>
<section id="merge-merge-using-unique-constraints-matches-an-existing-node">
<title>Merge using unique constraints matches an existing node</title>
<simpara>Merge using unique constraints matches an existing node.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MERGE (oliver:Person { name:'Oliver Stone' })
RETURN oliver</programlisting>
</para></formalpara>
<simpara>The oliver node already exists, so merge just returns it.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">oliver</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Oliver Stone"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create constraint on (n:`Person`) assert n.`name` is unique
create constraint on (n:`Person`) assert n.`role` is unique
create (_0:`Person` {`name`:"Oliver Stone"})
create (_1:`Person` {`name`:"Charlie Sheen"})
create (_2:`Person` {`name`:"Martin Sheen"})
create (_3:`Movie` {`name`:"TheAmericanPresident", `title`:"The American President"})
create (_4:`Movie` {`name`:"WallStreet", `title`:"Wall Street"})
create (_5:`Person` {`name`:"Rob Reiner"})
create (_6:`Person` {`name`:"Michael Douglas"})
create _0-[:`DIRECTED`]-&gt;_4
create _1-[:`ACTED_IN`]-&gt;_4
create _1-[:`FATHER`]-&gt;_2
create _2-[:`ACTED_IN`]-&gt;_4
create _2-[:`ACTED_IN`]-&gt;_3
create _5-[:`DIRECTED`]-&gt;_3
create _6-[:`ACTED_IN`]-&gt;_4
create _6-[:`ACTED_IN`]-&gt;_3
</database><command>
 merge (oliver:Person {name:'Oliver Stone'}) return oliver</command></para></formalpara>
</section>
<section id="merge-merge-with-unique-constraints-and-partial-matches">
<title>Merge with unique constraints and partial matches</title>
<simpara>Merge using unique constraints fails when finding partial matches.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MERGE (michael:Person { name:'Michael Douglas', role:'Gordon Gekko' })
RETURN michael</programlisting>
</para></formalpara>
<simpara>While there is a matching unique michael node with the name <emphasis>Michael Douglas</emphasis>, there is no unique node with the role of <emphasis>Gordon Gekko</emphasis> and merge fails to match.</simpara>
<formalpara><title>Error message</title><para>
<programlisting language="plain" linenumbering="unnumbered">Merge did not find a matching node and can not create a new node due to conflicts
with both existing and missing unique nodes. The conflicting constraints are on:
:Person.name and :Person.role</programlisting>
</para></formalpara>
</section>
<section id="merge-merge-with-unique-constraints-and-conflicting-matches">
<title>Merge with unique constraints and conflicting matches</title>
<simpara>Merge using unique constraints fails when finding conflicting matches.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MERGE (oliver:Person { name:'Oliver Stone', role:'Gordon Gekko' })
RETURN oliver</programlisting>
</para></formalpara>
<simpara>While there is a matching unique oliver node with the name <emphasis>Oliver Stone</emphasis>, there is also another unique node with the role of <emphasis>Gordon Gekko</emphasis> and merge fails to match.</simpara>
<formalpara><title>Error message</title><para>
<programlisting language="plain" linenumbering="unnumbered">Merge did not find a matching node and can not create a new node due to conflicts
with both existing and missing unique nodes. The conflicting constraints are on:
:Person.name and :Person.role</programlisting>
</para></formalpara>
</section>
</section>
<section id="merge-using-map-parameters-with-merge">
<title>Using map parameters with MERGE</title>
<simpara><literal>MERGE</literal> does not support map parameters like for example <literal>CREATE</literal> does.
To use map parameters with <literal>MERGE</literal>, it is necessary to explicitly use the expected properties, like in the following example.
For more information on parameters, see <xref linkend="cypher-parameters"/>.</simpara>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "param" : {
    "name" : "Keanu Reeves",
    "role" : "Neo"
  }
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MERGE (oliver:Person { name: { param }.name, role: { param }.role })
RETURN oliver</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">oliver</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 2
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[8]{name:"Keanu Reeves",role:"Neo"}</literal></simpara></entry></row></tbody></tgroup></table>
</section>
</section>
<section id="query-set">
<title>Set</title>
<simpara>Updating labels on nodes and properties on nodes and relationships is done with the <literal>SET</literal> clause.
<literal>SET</literal> can also be used with maps from parameters to set properties.</simpara>
<note><simpara>Setting labels on a node is an idempotent operations&#8201;&#8212;&#8201;if you try to set a label on a node that already has that label on it, nothing happens.
The query statistics will tell you if something needed to be done or not.</simpara></note>
<simpara>The examples use this graph as a starting point:</simpara>
<informalfigure>
<ulink url="images/cypher-set-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-set-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-set-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<section id="set-set-a-property">
<title>Set a property</title>
<simpara>To set a property on a node or relationship, use <literal>SET</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'Andres' })
SET n.surname = 'Taylor'
RETURN n</programlisting>
</para></formalpara>
<simpara>The newly changed node is returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"Andres",age:36,awesome:true,surname:"Taylor"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Emil"})
create (_1 {`name`:"Stefan"})
create (_2 {`age`:34, `name`:"Peter"})
create (_3:`Swedish` {`age`:36, `awesome`:true, `name`:"Andres"})
create _0-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _3-[:`KNOWS`]-&gt;_2
</database><command>
 match (n {name: 'Andres'}) set n.surname = 'Taylor' return n</command></para></formalpara>
</section>
<section id="set-remove-a-property">
<title>Remove a property</title>
<simpara>Normally you remove a property by using <literal><link linkend="query-remove">REMOVE</link></literal>, but it&#8217;s sometimes handy to do
it using the <literal>SET</literal> command. One example is if the property comes from a parameter.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'Andres' })
SET n.name = NULL RETURN n</programlisting>
</para></formalpara>
<simpara>The node is returned by the query, and the name property is now missing.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[3]{age:36,awesome:true}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Emil"})
create (_1 {`name`:"Stefan"})
create (_2 {`age`:34, `name`:"Peter"})
create (_3:`Swedish` {`age`:36, `awesome`:true, `name`:"Andres"})
create _0-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _3-[:`KNOWS`]-&gt;_2
</database><command>
 match (n {name: 'Andres'}) set n.name = null return n</command></para></formalpara>
</section>
<section id="set-copying-properties-between-nodes-and-relationships">
<title>Copying properties between nodes and relationships</title>
<simpara>You can also use <literal>SET</literal> to copy all properties from one graph element to another. Remember that doing this
will remove all other properties on the receiving graph element.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (at { name: 'Andres' }),(pn { name: 'Peter' })
SET at = pn
RETURN at, pn</programlisting>
</para></formalpara>
<simpara>The Andres node has had all it&#8217;s properties replaced by the properties in the Peter node.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">at</entry><entry align="left" valign="top">pn</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col2">Properties set: 3</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[3]{age:34,name:"Peter"}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Peter",age:34}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Emil"})
create (_1 {`name`:"Stefan"})
create (_2 {`age`:34, `name`:"Peter"})
create (_3:`Swedish` {`age`:36, `awesome`:true, `name`:"Andres"})
create _0-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _3-[:`KNOWS`]-&gt;_2
</database><command>
 match (at {name: 'Andres'}), (pn {name: 'Peter'}) set at = pn return at, pn</command></para></formalpara>
</section>
<section id="set-set-a-property-using-a-parameter">
<title>Set a property using a parameter</title>
<simpara>Use a parameter to give the value of a property.</simpara>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "surname" : "Taylor"
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'Andres' })
SET n.surname = { surname }
RETURN n</programlisting>
</para></formalpara>
<simpara>The Andres node has got an surname added.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"Andres",age:36,awesome:true,surname:"Taylor"}</literal></simpara></entry></row></tbody></tgroup></table>
</section>
<section id="set-set-all-properties-using-a-parameter">
<title>Set all properties using a parameter</title>
<simpara>This will replace all existing properties on the node with the new set provided by the parameter.</simpara>
<formalpara><title>Parameters</title><para>
<programlisting language="javascript" linenumbering="unnumbered">{
  "props" : {
    "name" : "Andres",
    "position" : "Developer"
  }
}</programlisting>
</para></formalpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'Andres' })
SET n = { props }
RETURN n</programlisting>
</para></formalpara>
<simpara>The Andres node has had all it&#8217;s properties replaced by the properties in the <literal>props</literal> parameter.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 4</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[3]{position:"Developer",name:"Andres"}</literal></simpara></entry></row></tbody></tgroup></table>
</section>
<section id="set-set-a-label-on-a-node">
<title>Set a label on a node</title>
<simpara>To set a label on a node, use <literal>SET</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'Stefan' })
SET n :German
RETURN n</programlisting>
</para></formalpara>
<simpara>The newly labeled node is returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Stefan"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Emil"})
create (_1 {`name`:"Stefan"})
create (_2 {`age`:34, `name`:"Peter"})
create (_3:`Swedish` {`age`:36, `awesome`:true, `name`:"Andres"})
create _0-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _3-[:`KNOWS`]-&gt;_2
</database><command>
 match (n {name: 'Stefan'}) set n :German return n</command></para></formalpara>
</section>
<section id="set-set-multiple-labels-on-a-node">
<title>Set multiple labels on a node</title>
<simpara>To set multiple labels on a node, use <literal>SET</literal> and separate the different labels using <literal>:</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'Emil' })
SET n :Swedish:Bossman
RETURN n</programlisting>
</para></formalpara>
<simpara>The newly labeled node is returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 2</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Emil"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"Emil"})
create (_1 {`name`:"Stefan"})
create (_2 {`age`:34, `name`:"Peter"})
create (_3:`Swedish` {`age`:36, `awesome`:true, `name`:"Andres"})
create _0-[:`KNOWS`]-&gt;_2
create _1-[:`KNOWS`]-&gt;_3
create _3-[:`KNOWS`]-&gt;_2
</database><command>
 match (n {name: 'Emil'}) set n :Swedish:Bossman return n</command></para></formalpara>
</section>
</section>
<section id="query-delete">
<title>Delete</title>
<simpara>Deleting graph elements&#8201;&#8212;&#8201;nodes and relationships, is done with <literal>DELETE</literal>.</simpara>
<simpara>For removing properties and labels, see <xref linkend="query-remove"/>.</simpara>
<simpara>The examples start out with the following database:</simpara>
<informalfigure>
<ulink url="images/cypher-delete-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-delete-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-delete-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<section id="delete-delete-single-node">
<title>Delete single node</title>
<simpara>To delete a node, use the <literal>DELETE</literal> clause.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'Peter' })
DELETE n</programlisting>
</para></formalpara>
<simpara>Nothing is returned from this query, except the count of affected nodes.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes deleted: 1</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2 {`age`:36, `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n {name: 'Peter'}) delete n</command></para></formalpara>
</section>
<section id="delete-delete-a-node-and-connected-relationships">
<title>Delete a node and connected relationships</title>
<simpara>If you are trying to delete a node with relationships on it, you have to delete these as well.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'Andres' })-[r]-()
DELETE n, r</programlisting>
</para></formalpara>
<simpara>Nothing is returned from this query, except the count of affected nodes.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes deleted: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships deleted: 2</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2 {`age`:36, `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n {name: 'Andres'})-[r]-() delete n, r</command></para></formalpara>
</section>
<section id="delete-delete-all-nodes-and-relationships">
<title>Delete all nodes and relationships</title>
<simpara>This query isn&#8217;t for deleting large amounts of data, but is nice when playing around with small example data sets.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
OPTIONAL MATCH (n)-[r]-()
DELETE n,r</programlisting>
</para></formalpara>
<simpara>Nothing is returned from this query, except the count of affected nodes.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes deleted: 3
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Relationships deleted: 2</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:25, `name`:"Tobias"})
create (_1 {`age`:34, `name`:"Peter"})
create (_2 {`age`:36, `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE n,r</command></para></formalpara>
</section>
</section>
<section id="query-remove">
<title>Remove</title>
<simpara>Removing properties and labels from graph elements is done using <literal>REMOVE</literal>.</simpara>
<simpara>For deleting nodes and relationships, see <xref linkend="query-delete"/>.</simpara>
<note><simpara>Removing labels from a node is an idempotent operation:
If you try to remove a label from a node that does not have that label on it, nothing happens.
The query statistics will tell you if something needed to be done or not.</simpara></note>
<simpara>The examples start out with the following database:</simpara>
<informalfigure>
<ulink url="images/cypher-remove-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-remove-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-remove-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<section id="remove-remove-a-property">
<title>Remove a property</title>
<simpara>Neo4j doesn&#8217;t allow storing <literal>null</literal> in properties. Instead, if no value exists, the property is just not there. So, to remove a property value on a node or a relationship, is also done with <literal>REMOVE</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (andres { name: 'Andres' })
REMOVE andres.age
RETURN andres</programlisting>
</para></formalpara>
<simpara>The node is returned, and no property <literal>age</literal> exists on it.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">andres</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Andres"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Swedish` {`age`:25, `name`:"Tobias"})
create (_1:`Swedish`:`German` {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (andres {name: 'Andres'}) remove andres.age return andres</command></para></formalpara>
</section>
<section id="remove-remove-a-label-from-a-node">
<title>Remove a label from a node</title>
<simpara>To remove labels, you use <literal>REMOVE</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'Peter' })
REMOVE n:German
RETURN n</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels removed: 1</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Peter",age:34}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Swedish` {`age`:25, `name`:"Tobias"})
create (_1:`Swedish`:`German` {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n {name: 'Peter'}) remove n:German return n</command></para></formalpara>
</section>
<section id="remove-removing-multiple-labels">
<title>Removing multiple labels</title>
<simpara>To remove multiple labels, you use <literal>REMOVE</literal>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'Peter' })
REMOVE n:German:Swedish
RETURN n</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels removed: 2</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Peter",age:34}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0:`Swedish` {`age`:25, `name`:"Tobias"})
create (_1:`Swedish`:`German` {`age`:34, `name`:"Peter"})
create (_2:`Swedish` {`age`:36, `name`:"Andres"})
create _2-[:`KNOWS`]-&gt;_0
create _2-[:`KNOWS`]-&gt;_1
</database><command>
 match (n {name: 'Peter'}) remove n:German:Swedish return n</command></para></formalpara>
</section>
</section>
<section id="query-foreach">
<title>Foreach</title>
<simpara>Collections and paths are key concepts in Cypher.
To use them for updating data, you can use the <literal>FOREACH</literal> construct.
It allows you to do updating commands on elements in a collection&#8201;&#8212;&#8201;a path, or a collection created by aggregation.</simpara>
<simpara>The identifier context inside of the foreach parenthesis is separate from the one outside it.
This means that  if you <literal>CREATE</literal> a node identifier inside of a <literal>FOREACH</literal>, you will <emphasis>not</emphasis> be able to use it outside of the foreach statement, unless you match to find it.</simpara>
<simpara>Inside of the <literal>FOREACH</literal> parentheses, you can do any of the updating commands&#8201;&#8212;&#8201;<literal>CREATE</literal>, <literal>CREATE UNIQUE</literal>, <literal>DELETE</literal>, and <literal>FOREACH</literal>.</simpara>
<figure><title>Data for the examples</title>
<ulink url="images/cypher-foreach-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-foreach-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-foreach-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="foreach-mark-all-nodes-along-a-path">
<title>Mark all nodes along a path</title>
<simpara>This query will set the property <literal>marked</literal> to true on all nodes along a path.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p =(begin)-[*]-&gt;(END )
WHERE begin.name='A' AND END .name='D'
FOREACH (n IN nodes(p)| SET n.marked = TRUE )</programlisting>
</para></formalpara>
<simpara>Nothing is returned from this query, but four properties are set.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 4</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"D"})
create (_1 {`name`:"A"})
create (_2 {`name`:"B"})
create (_3 {`name`:"C"})
create _1-[:`KNOWS`]-&gt;_2
create _2-[:`KNOWS`]-&gt;_3
create _3-[:`KNOWS`]-&gt;_0
</database><command>
 match p = (begin)-[*]-&gt;(end) where begin.name='A' and end.name='D' foreach(n in nodes(p) | set n.marked = true)</command></para></formalpara>
</section>
</section>
</chapter>
<chapter id="query-function">
<title>Functions</title>
<simpara>This chapter contains information on all functions in Cypher.
Note that related information exists in <xref linkend="query-operators"/>.</simpara>
<note><simpara>Most functions in Cypher will return <literal>NULL</literal> if an input parameter is <literal>NULL</literal>.</simpara></note>
<section id="query-predicates">
<title>Predicates</title>
<simpara>Predicates are boolean functions that return true or false for a given set of input.
They are most commonly used to filter out subgraphs in the <literal>WHERE</literal> part of a query.</simpara>
<simpara>See also <xref linkend="query-operators-comparison"/>.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-functions-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-functions-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-functions-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="functions-all">
<title>ALL</title>
<simpara>Tests whether a predicate holds for all element of this collection collection.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>ALL(identifier in collection WHERE predicate)</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>collection:</emphasis> An expression that returns a collection
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>identifier:</emphasis> This is the identifier that can be used from the predicate.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>predicate:</emphasis> A predicate that is tested against all items in the collection.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p=(a)-[*1..3]-&gt;(b)
WHERE a.name='Alice' AND b.name='Daniel' AND ALL (x IN nodes(p) WHERE x.age &gt; 30)
RETURN p</programlisting>
</para></formalpara>
<simpara>All nodes in the returned paths will have an <literal>age</literal> property of at least 30.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">p</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[Node[2]{name:"Alice",age:38,eyes:"brown"},:KNOWS[1]{},Node[4]{name:"Charlie",age:53,eyes:"green"},:KNOWS[3]{},Node[0]{name:"Daniel",age:54,eyes:"brown"}]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match p=(a)-[*1..3]-&gt;(b) where a.name='Alice' and b.name='Daniel' and all(x in nodes(p) WHERE x.age &gt; 30) return p</command></para></formalpara>
</section>
<section id="functions-any">
<title>ANY</title>
<simpara>Tests whether a predicate holds for at least one element in the collection.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>ANY(identifier in collection WHERE predicate)</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>collection:</emphasis> An expression that returns a collection
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>identifier:</emphasis> This is the identifier that can be used from the predicate.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>predicate:</emphasis> A predicate that is tested against all items in the collection.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a)
WHERE a.name='Eskil' AND ANY (x IN a.array WHERE x = "one")
RETURN a</programlisting>
</para></formalpara>
<simpara>All nodes in the returned paths has at least one <literal>one</literal> value set in the array property named <literal>array</literal>.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">a</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Eskil",age:41,eyes:"blue",array:["one","two","three"]}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match (a) where a.name='Eskil' and any(x in a.array WHERE x = "one") return a</command></para></formalpara>
</section>
<section id="functions-none">
<title>NONE</title>
<simpara>Returns true if the predicate holds for no element in the collection.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>NONE(identifier in collection WHERE predicate)</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>collection:</emphasis> An expression that returns a collection
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>identifier:</emphasis> This is the identifier that can be used from the predicate.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>predicate:</emphasis> A predicate that is tested against all items in the collection.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p=(n)-[*1..3]-&gt;(b)
WHERE n.name='Alice' AND NONE (x IN nodes(p) WHERE x.age = 25)
RETURN p</programlisting>
</para></formalpara>
<simpara>No nodes in the returned paths has a <literal>age</literal> property set to <literal>25</literal>.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">p</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[Node[2]{name:"Alice",age:38,eyes:"brown"},:KNOWS[1]{},Node[4]{name:"Charlie",age:53,eyes:"green"}]</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>[Node[2]{name:"Alice",age:38,eyes:"brown"},:KNOWS[1]{},Node[4]{name:"Charlie",age:53,eyes:"green"},:KNOWS[3]{},Node[0]{name:"Daniel",age:54,eyes:"brown"}]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match p=(n)-[*1..3]-&gt;(b) where n.name='Alice' and NONE(x in nodes(p) WHERE x.age = 25) return p</command></para></formalpara>
</section>
<section id="functions-single">
<title>SINGLE</title>
<simpara>Returns true if the predicate holds for exactly one of the elements in the collection.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>SINGLE(identifier in collection WHERE predicate)</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>collection:</emphasis> An expression that returns a collection
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>identifier:</emphasis> This is the identifier that can be used from the predicate.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>predicate:</emphasis> A predicate that is tested against all items in the collection.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p=(n)--&gt;(b)
WHERE n.name='Alice' AND SINGLE (var IN nodes(p) WHERE var.eyes = "blue")
RETURN p</programlisting>
</para></formalpara>
<simpara>Exactly one node in every returned path will have the <literal>eyes</literal> property set to <literal>"blue"</literal>.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">p</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[Node[2]{name:"Alice",age:38,eyes:"brown"},:KNOWS[0]{},Node[3]{name:"Bob",age:25,eyes:"blue"}]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match p=(n)--&gt;(b) where n.name='Alice' and SINGLE(var in nodes(p) WHERE var.eyes = "blue") return p</command></para></formalpara>
</section>
</section>
<section id="query-functions-scalar">
<title>Scalar functions</title>
<simpara>Scalar functions return a single value.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-functions-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-functions-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-functions-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="functions-length">
<title>LENGTH</title>
<simpara>To return or filter on the length of a collection, use the <literal>LENGTH()</literal> function.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>LENGTH( collection )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>collection:</emphasis> An expression that returns a collection
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p=(a)--&gt;(b)--&gt;(c)
WHERE a.name='Alice'
RETURN length(p)</programlisting>
</para></formalpara>
<simpara>The length of the path <literal>p</literal> is returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">length(p)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match p=(a)--&gt;(b)--&gt;(c) where a.name='Alice' return length(p)</command></para></formalpara>
</section>
<section id="functions-type">
<title>TYPE</title>
<simpara>Returns a string representation of the relationship type.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>TYPE( relationship )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>relationship:</emphasis> A relationship.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)-[r]-&gt;()
WHERE n.name='Alice'
RETURN type(r)</programlisting>
</para></formalpara>
<simpara>The relationship type of <literal>r</literal> is returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">type(r)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"KNOWS"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"KNOWS"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match (n)-[r]-&gt;() where n.name='Alice' return type(r)</command></para></formalpara>
</section>
<section id="functions-id">
<title>ID</title>
<simpara>Returns the id of the relationship or node.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>ID( property-container )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>property-container:</emphasis> A node or a relationship.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a)
RETURN id(a)</programlisting>
</para></formalpara>
<simpara>This returns the node id for three nodes.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">id(a)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">5 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>0</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match (a) return id(a)</command></para></formalpara>
</section>
<section id="functions-coalesce">
<title>COALESCE</title>
<simpara>Returns the first non-<literal>NULL</literal> value in the list of expressions passed to it.
In case all arguments are <literal>NULL</literal>, <literal>NULL</literal> will be returned.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>COALESCE( expression [, expression]* )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> The expression that might return NULL.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a)
WHERE a.name='Alice'
RETURN coalesce(a.hairColor, a.eyes)</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">coalesce(a.hairColor, a.eyes)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"brown"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match (a) where a.name='Alice' return coalesce(a.hairColor, a.eyes)</command></para></formalpara>
</section>
<section id="functions-head">
<title>HEAD</title>
<simpara><literal>HEAD</literal> returns the first element in a collection.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>HEAD( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> This expression should return a collection of some kind.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a)
WHERE a.name='Eskil'
RETURN a.array, head(a.array)</programlisting>
</para></formalpara>
<simpara>The first node in the path is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">a.array</entry><entry align="left" valign="top">head(a.array)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>["one","two","three"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"one"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match (a) where a.name='Eskil' return a.array, head(a.array)</command></para></formalpara>
</section>
<section id="functions-last">
<title>LAST</title>
<simpara><literal>LAST</literal> returns the last element in a collection.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>LAST( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> This expression should return a collection of some kind.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a)
WHERE a.name='Eskil'
RETURN a.array, last(a.array)</programlisting>
</para></formalpara>
<simpara>The last node in the path is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">a.array</entry><entry align="left" valign="top">last(a.array)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>["one","two","three"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"three"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match (a) where a.name='Eskil' return a.array, last(a.array)</command></para></formalpara>
</section>
<section id="functions-timestamp">
<title>TIMESTAMP</title>
<simpara><literal>TIMESTAMP</literal> returns the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC. It will return the same value during the whole one query, even if the query is a long running one.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>TIMESTAMP()</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN timestamp()</programlisting>
</para></formalpara>
<simpara>The time in milliseconds is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">timestamp()</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>1390989351172</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return timestamp()</command></para></formalpara>
</section>
<section id="functions-startnode">
<title>STARTNODE</title>
<simpara><literal>STARTNODE</literal> returns the starting node of a relationship</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>STARTNODE( relationship )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>relationship:</emphasis> An expression that returns a relationship
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (x:foo)-[r]-()
RETURN startNode(r)</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">startNode(r)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Alice",age:38,eyes:"brown"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[2]{name:"Alice",age:38,eyes:"brown"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 MATCH (x:foo)-[r]-() return startNode(r)</command></para></formalpara>
</section>
<section id="functions-endnode">
<title>ENDNODE</title>
<simpara><literal>ENDNODE</literal> returns the end node of a relationship</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>ENDNODE( relationship )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>relationship:</emphasis> An expression that returns a relationship
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (x:foo)-[r]-()
RETURN endNode(r)</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">endNode(r)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[3]{name:"Bob",age:25,eyes:"blue"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[4]{name:"Charlie",age:53,eyes:"green"}</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 MATCH (x:foo)-[r]-() return endNode(r)</command></para></formalpara>
</section>
</section>
<section id="query-functions-collection">
<title>Collection functions</title>
<simpara>Collection functions return collections of things&#8201;&#8212;&#8201;nodes in a path, and so on.</simpara>
<simpara>See also <xref linkend="query-operators-collection"/>.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-functions-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-functions-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-functions-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="functions-nodes">
<title>NODES</title>
<simpara>Returns all nodes in a path.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>NODES( path )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>path:</emphasis> A path.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p=(a)--&gt;(b)--&gt;(c)
WHERE a.name='Alice' AND c.name='Eskil'
RETURN nodes(p)</programlisting>
</para></formalpara>
<simpara>All the nodes in the path <literal>p</literal> are returned by the example query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">nodes(p)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[Node[2]{name:"Alice",age:38,eyes:"brown"},Node[3]{name:"Bob",age:25,eyes:"blue"},Node[1]{name:"Eskil",age:41,eyes:"blue",array:["one","two","three"]}]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match p=(a)--&gt;(b)--&gt;(c) where a.name='Alice' and c.name='Eskil' return nodes(p)</command></para></formalpara>
</section>
<section id="functions-relationships">
<title>RELATIONSHIPS</title>
<simpara>Returns all relationships in a path.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>RELATIONSHIPS( path )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>path:</emphasis> A path.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p=(a)--&gt;(b)--&gt;(c)
WHERE a.name='Alice' AND c.name='Eskil'
RETURN relationships(p)</programlisting>
</para></formalpara>
<simpara>All the relationships in the path <literal>p</literal> are returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">relationships(p)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[:KNOWS[0]{},:MARRIED[4]{}]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match p=(a)--&gt;(b)--&gt;(c) where a.name='Alice' and c.name='Eskil' return relationships(p)</command></para></formalpara>
</section>
<section id="functions-labels">
<title>LABELS</title>
<simpara>Returns a collection of string representations for the labels attached to a node.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>LABELS( node )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>node:</emphasis> Any expression that returns a single node
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a)
WHERE a.name='Alice'
RETURN labels(a)</programlisting>
</para></formalpara>
<simpara>The labels of <literal>n</literal> is returned by the query.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">labels(a)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>["foo","bar"]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match (a) where a.name='Alice' return labels(a)</command></para></formalpara>
</section>
<section id="functions-extract">
<title>EXTRACT</title>
<simpara>To return a single property, or the value of a function from a collection of nodes or relationships,
 you can use <literal>EXTRACT</literal>. It will go through a collection, run an expression on every element, and return the results
 in an collection with these values. It works like the <literal>map</literal> method in functional languages such as Lisp and Scala.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>EXTRACT( identifier in collection | expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>collection:</emphasis> An expression that returns a collection
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>identifier:</emphasis> The closure will have an identifier introduced in it&#8217;s context. Here you decide which identifier to use.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>expression:</emphasis> This expression will run once per value in the collection, and produces the result collection.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p=(a)--&gt;(b)--&gt;(c)
WHERE a.name='Alice' AND b.name='Bob' AND c.name='Daniel'
RETURN extract(n IN nodes(p)| n.age) AS extracted</programlisting>
</para></formalpara>
<simpara>The age property of all nodes in the path are returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">extracted</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[38,25,54]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match p=(a)--&gt;(b)--&gt;(c) where a.name='Alice' and b.name='Bob' and c.name='Daniel' return extract(n in nodes(p) | n.age) AS extracted</command></para></formalpara>
</section>
<section id="functions-filter">
<title>FILTER</title>
<simpara><literal>FILTER</literal> returns all the elements in a collection that comply to a predicate.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>FILTER(identifier in collection WHERE predicate)</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>collection:</emphasis> An expression that returns a collection
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>identifier:</emphasis> This is the identifier that can be used from the predicate.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>predicate:</emphasis> A predicate that is tested against all items in the collection.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a)
WHERE a.name='Eskil'
RETURN a.array, filter(x IN a.array WHERE length(x)= 3)</programlisting>
</para></formalpara>
<simpara>This returns the property named <literal>array</literal> and a list of values in it, which have the length <literal>3</literal>.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">a.array</entry><entry align="left" valign="top">filter(x in a.array WHERE length(x) = 3)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>["one","two","three"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>["one","two"]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match (a) where a.name='Eskil' return a.array, filter(x in a.array WHERE length(x) = 3)</command></para></formalpara>
</section>
<section id="functions-tail">
<title>TAIL</title>
<simpara><literal>TAIL</literal> returns all but the first element in a collection.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>TAIL( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> This expression should return a collection of some kind.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a)
WHERE a.name='Eskil'
RETURN a.array, tail(a.array)</programlisting>
</para></formalpara>
<simpara>This returns the property named <literal>array</literal> and all elements of that property except the first one.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">a.array</entry><entry align="left" valign="top">tail(a.array)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>["one","two","three"]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>["two","three"]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match (a) where a.name='Eskil' return a.array, tail(a.array)</command></para></formalpara>
</section>
<section id="functions-range">
<title>RANGE</title>
<simpara>Returns numerical values in a range with a non-zero step value step. Range is inclusive in both ends.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>RANGE( start, end [, step] )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>start:</emphasis> A numerical expression.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>end:</emphasis> A numerical expression.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>step:</emphasis> A numerical expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN range(0,10), range(2,18,3)</programlisting>
</para></formalpara>
<simpara>Two lists of numbers are returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">range(0,10)</entry><entry align="left" valign="top">range(2,18,3)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>[0,1,2,3,4,5,6,7,8,9,10]</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>[2,5,8,11,14,17]</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return range(0,10), range(2,18,3)</command></para></formalpara>
</section>
<section id="functions-reduce">
<title>REDUCE</title>
<simpara>To run an expression against individual elements of a collection, and store the result of the expression in
 an accumulator, you can use <literal>REDUCE</literal>. It will go through a collection, run an expression on every element, storing the partial result
 in the accumulator. It works like the <literal>fold</literal> or <literal>reduce</literal> method in functional languages such as Lisp and Scala.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>REDUCE( accumulator = initial,  identifier in collection | expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>accumulator:</emphasis> An identifier that will hold the result and the partial results as the collection is iterated
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>initial:</emphasis> An expression that runs once to give a starting value to the accumulator
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>collection:</emphasis> An expression that returns a collection
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>identifier:</emphasis> The closure will have an identifier introduced in it&#8217;s context. Here you decide which identifier to use.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>expression:</emphasis> This expression will run once per value in the collection, and produces the result value.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH p=(a)--&gt;(b)--&gt;(c)
WHERE a.name='Alice' AND b.name='Bob' AND c.name='Daniel'
RETURN reduce(totalAge = 0, n IN nodes(p)| totalAge + n.age) AS reduction</programlisting>
</para></formalpara>
<simpara>The age property of all nodes in the path are summed and returned as a single value.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">reduction</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>117</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match p=(a)--&gt;(b)--&gt;(c) where a.name='Alice' and b.name='Bob' and c.name='Daniel' return reduce(totalAge = 0, n in nodes(p) | totalAge + n.age) AS reduction</command></para></formalpara>
</section>
</section>
<section id="query-functions-mathematical">
<title>Mathematical functions</title>
<simpara>These functions all operate on numerical expressions only, and will return an error if used on any other values.</simpara>
<simpara>See also <xref linkend="query-operators-mathematical"/>.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-functions-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-functions-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-functions-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="functions-abs">
<title>ABS</title>
<simpara><literal>ABS</literal> returns the absolute value of a number.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>ABS( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (a),(e)
WHERE a.name = 'Alice' AND e.name = 'Eskil'
RETURN a.age, e.age, abs(a.age - e.age)</programlisting>
</para></formalpara>
<simpara>The absolute value of the age difference is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="3"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><thead><row><entry align="left" valign="top">a.age</entry><entry align="left" valign="top">e.age</entry><entry align="left" valign="top">abs(a.age - e.age)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col3">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>38</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>41</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>3.0</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 match (a), (e) where a.name = 'Alice' and e.name = 'Eskil' return a.age, e.age, abs(a.age - e.age)</command></para></formalpara>
</section>
<section id="functions-acos">
<title>ACOS</title>
<simpara><literal>ACOS</literal> returns the arccosine of the expression, in radians.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>ACOS( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN acos(0.5)</programlisting>
</para></formalpara>
<simpara>The arccosine of 0.5.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">acos(0.5)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>1.0471975511965979</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return acos(0.5)</command></para></formalpara>
</section>
<section id="functions-asin">
<title>ASIN</title>
<simpara><literal>ASIN</literal> returns the arcsine of the expression, in radians.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>ASIN( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN asin(0.5)</programlisting>
</para></formalpara>
<simpara>The arcsine of 0.5.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">asin(0.5)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>0.5235987755982989</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return asin(0.5)</command></para></formalpara>
</section>
<section id="functions-atan">
<title>ATAN</title>
<simpara><literal>ATAN</literal> returns the arctangent of the expression, in radians.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>ATAN( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN atan(0.5)</programlisting>
</para></formalpara>
<simpara>The arctangent of 0.5.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">atan(0.5)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>0.4636476090008061</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return atan(0.5)</command></para></formalpara>
</section>
<section id="functions-atan2">
<title>ATAN2</title>
<simpara><literal>ATAN2</literal> returns the arctangent2 of a set of coordinates, in radians.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>ATAN2( expression , expression)</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression for y.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression for x.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN atan2(0.5, 0.6)</programlisting>
</para></formalpara>
<simpara>The arctangent2 of 0.5, 0.6.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">atan2(0.5, 0.6)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>0.6947382761967033</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return atan2(0.5, 0.6)</command></para></formalpara>
</section>
<section id="functions-cos">
<title>COS</title>
<simpara><literal>COS</literal> returns the cosine of the expression.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>COS( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN cos(0.5)</programlisting>
</para></formalpara>
<simpara>The cosine of 0.5 is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">cos(0.5)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>0.8775825618903728</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return cos(0.5)</command></para></formalpara>
</section>
<section id="functions-cot">
<title>COT</title>
<simpara><literal>COT</literal> returns the cotangent of the expression.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>COT( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN cot(0.5)</programlisting>
</para></formalpara>
<simpara>The cotangent of 0.5 is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">cot(0.5)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>1.830487721712452</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return cot(0.5)</command></para></formalpara>
</section>
<section id="functions-degrees">
<title>DEGREES</title>
<simpara><literal>DEGREES</literal> converts radians to degrees.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>DEGREES( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN degrees(3.14159)</programlisting>
</para></formalpara>
<simpara>The number of degrees in something close to pi.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">degrees(3.14159)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>179.99984796050427</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return degrees(3.14159)</command></para></formalpara>
</section>
<section id="functions-e">
<title>E</title>
<simpara><literal>E</literal> returns the constant, e.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>E()</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN e()</programlisting>
</para></formalpara>
<simpara>The constant e is returned (the base of natural log).</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">e()</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>2.718281828459045</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return e()</command></para></formalpara>
</section>
<section id="functions-exp">
<title>EXP</title>
<simpara><literal>EXP</literal> returns the value e raised to the power of the expression.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>EXP( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN exp(2)</programlisting>
</para></formalpara>
<simpara>The exp of 2 is returned: e<superscript>2</superscript>.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">exp(2)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>7.38905609893065</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return exp(2)</command></para></formalpara>
</section>
<section id="functions-floor">
<title>FLOOR</title>
<simpara><literal>FLOOR</literal> returns the greatest integer less than or equal to the expression.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>FLOOR( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN floor(0.9)</programlisting>
</para></formalpara>
<simpara>The floor of 0.9 is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">floor(0.9)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>0.0</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return floor(0.9)</command></para></formalpara>
</section>
<section id="functions-haversin">
<title>HAVERSIN</title>
<simpara><literal>HAVERSIN</literal> returns the half versine of the expression.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>HAVERSIN( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN haversin(0.5)</programlisting>
</para></formalpara>
<simpara>The haversine of 0.5 is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">haversin(0.5)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>0.06120871905481362</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return haversin(0.5)</command></para></formalpara>
<section id="functions-spherical-distance-using-the-haversin-function">
<title>Spherical distance using the haversin function</title>
<simpara>The <literal>haversin</literal> function may be used to compute the distance on the surface of a sphere between two points (each given by their latitude and longitude). In this example the spherical distance (in km) between Berlin in Germany (at lat 52.5, lon 13.4) and San Mateo in California (at lat 37.5, lon -122.3) is calculated using an average earth radius of 6371 km.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (ber:City { lat: 52.5, lon: 13.4 }),(sm:City { lat: 37.5, lon: -122.3 })
RETURN 2 * 6371 * asin(sqrt(haversin(radians(sm.lat - ber.lat))+ cos(radians(sm.lat))*
  cos(radians(ber.lat))* haversin(radians(sm.lon - ber.lon)))) AS dist</programlisting>
</para></formalpara>
<simpara>The distance between Berlin and San Mateo is returned (about 9129 km).</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">dist</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 2
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 4
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 2</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>9129.969740051658</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 CREATE (ber:City {lat: 52.5, lon: 13.4}), (sm:City {lat: 37.5, lon: -122.3}) RETURN 2 * 6371 * asin(sqrt(haversin(radians( sm.lat - ber.lat )) + cos(radians( sm.lat )) * cos(radians( ber.lat )) * haversin(radians( sm.lon - ber.lon )))) AS dist</command></para></formalpara>
</section>
</section>
<section id="functions-log">
<title>LOG</title>
<simpara><literal>LOG</literal> returns the natural logarithm of the expression.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>LOG( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN log(27)</programlisting>
</para></formalpara>
<simpara>The log of 27 is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">log(27)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>3.295836866004329</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return log(27)</command></para></formalpara>
</section>
<section id="functions-log10">
<title>LOG10</title>
<simpara><literal>LOG10</literal> returns the base 10 logarithm of the expression.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>LOG10( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN log10(27)</programlisting>
</para></formalpara>
<simpara>The log10 of 27 is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">log10(27)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>1.4313637641589874</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return log10(27)</command></para></formalpara>
</section>
<section id="functions-pi">
<title>PI</title>
<simpara><literal>PI</literal> returns the mathmatical constant pi.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>PI()</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN pi()</programlisting>
</para></formalpara>
<simpara>The constant pi is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">pi()</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>3.141592653589793</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return pi()</command></para></formalpara>
</section>
<section id="functions-radians">
<title>RADIANS</title>
<simpara><literal>RADIANS</literal> converts degrees to radians.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>RADIANS( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN radians(180)</programlisting>
</para></formalpara>
<simpara>The number of radians in 180 is returned (pi).</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">radians(180)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>3.141592653589793</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return radians(180)</command></para></formalpara>
</section>
<section id="functions-rand">
<title>RAND</title>
<simpara><literal>RAND</literal> returns a random double between 0 and 1.0.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>RAND( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN rand() AS x1</programlisting>
</para></formalpara>
<simpara>A random number is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">x1</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>0.7662709332538921</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return rand() as x1</command></para></formalpara>
</section>
<section id="functions-round">
<title>ROUND</title>
<simpara><literal>ROUND</literal> returns the numerical expression, rounded to the nearest integer.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>ROUND( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numerical expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN round(3.141592)</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">round(3.141592)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return round(3.141592)</command></para></formalpara>
</section>
<section id="functions-sign">
<title>SIGN</title>
<simpara><literal>SIGN</literal> returns the signum of a number&#8201;&#8212;&#8201;zero if the expression is zero, <literal>-1</literal> for any negative number, and <literal>1</literal> for any positive number.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>SIGN( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numerical expression
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN sign(-17), sign(0.1)</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">sign(-17)</entry><entry align="left" valign="top">sign(0.1)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>-1.0</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1.0</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return sign(-17), sign(0.1)</command></para></formalpara>
</section>
<section id="functions-sin">
<title>SIN</title>
<simpara><literal>SIN</literal> returns the sine of the expression.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>SIN( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN sin(0.5)</programlisting>
</para></formalpara>
<simpara>The sine of 0.5 is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">sin(0.5)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>0.479425538604203</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return sin(0.5)</command></para></formalpara>
</section>
<section id="functions-sqrt">
<title>SQRT</title>
<simpara><literal>SQRT</literal> returns the square root of a number.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>SQRT( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numerical expression
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN sqrt(256)</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">sqrt(256)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>16.0</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return sqrt(256)</command></para></formalpara>
</section>
<section id="functions-tan">
<title>TAN</title>
<simpara><literal>TAN</literal> returns the tangent of the expression.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>TAN( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> A numeric expression.
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN tan(0.5)</programlisting>
</para></formalpara>
<simpara>The tangent of 0.5 is returned.</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">tan(0.5)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>0.5463024898437905</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return tan(0.5)</command></para></formalpara>
</section>
</section>
<section id="query-functions-string">
<title>String functions</title>
<simpara>These functions all operate on string expressions only, and will return an error if used on any other values.
Except <literal>STR()</literal>, which converts to strings.</simpara>
<simpara>See also <xref linkend="query-operators-string"/>.</simpara>
<figure><title>Graph</title>
<ulink url="images/cypher-functions-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/cypher-functions-graph.svg"/>
  </imageobject>
  <textobject><phrase>cypher-functions-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<section id="functions-str">
<title>STR</title>
<simpara><literal>STR</literal> returns a string representation of the expression.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>STR( expression )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>expression:</emphasis> An expression that returns anything
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN str(1)</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">str(1)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"1"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return str(1)</command></para></formalpara>
</section>
<section id="functions-replace">
<title>REPLACE</title>
<simpara><literal>REPLACE</literal> returns a string with the search string replaced by the replace string. It replaces all occurrences.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>REPLACE( original, search, replace )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>original:</emphasis> An expression that returns a string
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>search:</emphasis> An expression that returns a string to search for
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>replace:</emphasis> An expression that returns the string to replace the search string with
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN replace("hello", "l", "w")</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">replace("hello", "l", "w")</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"hewwo"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return replace("hello", "l", "w")</command></para></formalpara>
</section>
<section id="functions-substring">
<title>SUBSTRING</title>
<simpara><literal>SUBSTRING</literal> returns a substring of the original, with a 0-based index start and length. If length is omitted, it returns a substring from start until the end of the string.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>SUBSTRING( original, start [, length] )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>original:</emphasis> An expression that returns a string
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>start:</emphasis> An expression that returns a positive number
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>length:</emphasis> An expression that returns a positive number
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN substring("hello", 1, 3), substring("hello", 2)</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">substring("hello", 1, 3)</entry><entry align="left" valign="top">substring("hello", 2)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"ell"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"llo"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return substring("hello", 1, 3), substring("hello", 2)</command></para></formalpara>
</section>
<section id="functions-left">
<title>LEFT</title>
<simpara><literal>LEFT</literal> returns a string containing the left n characters of the original string.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>LEFT( original, length )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>original:</emphasis> An expression that returns a string
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>n:</emphasis> An expression that returns a positive number
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN left("hello", 3)</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">left("hello", 3)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"hel"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return left("hello", 3)</command></para></formalpara>
</section>
<section id="functions-right">
<title>RIGHT</title>
<simpara><literal>RIGHT</literal> returns a string containing the right n characters of the original string.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>RIGHT( original, length )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>original:</emphasis> An expression that returns a string
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>n:</emphasis> An expression that returns a positive number
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN right("hello", 3)</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">right("hello", 3)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"llo"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return right("hello", 3)</command></para></formalpara>
</section>
<section id="functions-ltrim">
<title>LTRIM</title>
<simpara><literal>LTRIM</literal> returns the original string with whitespace removed from the left side.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>LTRIM( original )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>original:</emphasis> An expression that returns a string
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN ltrim("   hello")</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">ltrim("   hello")</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"hello"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return ltrim("   hello")</command></para></formalpara>
</section>
<section id="functions-rtrim">
<title>RTRIM</title>
<simpara><literal>RTRIM</literal> returns the original string with whitespace removed from the right side.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>RTRIM( original )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>original:</emphasis> An expression that returns a string
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN rtrim("hello   ")</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">rtrim("hello   ")</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"hello"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return rtrim("hello   ")</command></para></formalpara>
</section>
<section id="functions-trim">
<title>TRIM</title>
<simpara><literal>TRIM</literal> returns the original string with whitespace removed from both sides.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>TRIM( original )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>original:</emphasis> An expression that returns a string
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN trim("   hello   ")</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">trim("   hello   ")</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"hello"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return trim("   hello   ")</command></para></formalpara>
</section>
<section id="functions-lower">
<title>LOWER</title>
<simpara><literal>LOWER</literal> returns the original string in lowercase.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>LOWER( original )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>original:</emphasis> An expression that returns a string
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN lower("HELLO")</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">lower("HELLO")</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"hello"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return lower("HELLO")</command></para></formalpara>
</section>
<section id="functions-upper">
<title>UPPER</title>
<simpara><literal>UPPER</literal> returns the original string in uppercase.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis> <literal>UPPER( original )</literal></simpara>
<simpara><emphasis role="strong">Arguments:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>original:</emphasis> An expression that returns a string
</simpara>
</listitem>
</itemizedlist>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">RETURN upper("hello")</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">upper("hello")</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"HELLO"</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`age`:54, `eyes`:"brown", `name`:"Daniel"})
create (_1:`Spouse` {`age`:41, `array`:["one", "two", "three"], `eyes`:"blue", `name`:"Eskil"})
create (_2:`foo`:`bar` {`age`:38, `eyes`:"brown", `name`:"Alice"})
create (_3 {`age`:25, `eyes`:"blue", `name`:"Bob"})
create (_4 {`age`:53, `eyes`:"green", `name`:"Charlie"})
create _2-[:`KNOWS`]-&gt;_3
create _2-[:`KNOWS`]-&gt;_4
create _3-[:`KNOWS`]-&gt;_0
create _3-[:`MARRIED`]-&gt;_1
create _4-[:`KNOWS`]-&gt;_0
</database><command>
 return upper("hello")</command></para></formalpara>
</section>
</section>
</chapter>
<chapter id="cypher-schema">
<title>Schema</title>
<simpara>Neo4j 2.0 introduced an optional schema for the graph, based around the concept of labels.
Labels are used in the specification of indexes, and for defining constraints on the graph.
Together, indexes and constraints are the schema of the graph.
Cypher includes data definition language (DDL) statements for manipulating the schema.</simpara>
<section id="query-schema-index">
<title>Indexes</title>
<simpara>Cypher allows the creation of indexes over a property for all nodes that have a given label.
These indexes are automatically managed and kept up to date by the database whenever the graph is changed.</simpara>
<section id="schema-index-create-index-on-a-label">
<title>Create index on a label</title>
<simpara>To create an index on a property for all nodes that have a label, use <literal>CREATE</literal> <literal>INDEX</literal> <literal>ON</literal>. Note that the index is not immediately available, but will be created in the background. See <xref linkend="graphdb-neo4j-schema-indexes"/> for details.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE INDEX ON :Person(name)</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Indexes added: 1</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"root"})
create (_2 {`name`:"B"})
create (_3 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_3
create _1-[:`X`]-&gt;_0
create _1-[:`X`]-&gt;_2
create _1-[:`X`]-&gt;_3
</database><command>
 create index on :Person(name)</command></para></formalpara>
</section>
<section id="schema-index-drop-index-on-a-label">
<title>Drop index on a label</title>
<simpara>To drop an index on all nodes that have a label, use the <literal>DROP</literal> <literal>INDEX</literal> clause.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">DROP INDEX ON :Person(name)</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Indexes removed: 1</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"root"})
create (_2 {`name`:"B"})
create (_3 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_3
create _1-[:`X`]-&gt;_0
create _1-[:`X`]-&gt;_2
create _1-[:`X`]-&gt;_3
</database><command>
 drop index on :Person(name)</command></para></formalpara>
</section>
<section id="schema-index-use-index">
<title>Use index</title>
<simpara>There is usually no need to specify which indexes to use in a query, Cypher will figure that out by itself. For example the query below will use the <literal>Person(name)</literal> index, if it exists. If you for some reason want to hint to specific indexes, see <xref linkend="query-using"/>.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n:Person { name: 'Andres' })
RETURN n</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">n</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">0 row</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>create (_0 {`name`:"A"})
create (_1 {`name`:"root"})
create (_2 {`name`:"B"})
create (_3 {`name`:"C"})
create _0-[:`KNOWS`]-&gt;_3
create _1-[:`X`]-&gt;_0
create _1-[:`X`]-&gt;_2
create _1-[:`X`]-&gt;_3
</database><command>
 match (n:Person {name: 'Andres'}) return n</command></para></formalpara>
</section>
</section>
<section id="query-constraints">
<title>Constraints</title>
<simpara>Neo4j helps enforce data integrity with the use of constraints.</simpara>
<simpara>You can use unique constraints to ensure that property values are unique for all nodes with a specific label.
Unique constraints do not mean that all nodes have to have a unique value for the properties&#8201;&#8212;&#8201;nodes without the property are not subject to this rule.</simpara>
<simpara>Remember that adding constraints is an atomic operation that can take a while&#8201;&#8212;&#8201;all existing data has to be scanned before Neo4j can turn the constraint &#8220;on&#8221;.</simpara>
<simpara>You can have multiple unique constraints for a given label.</simpara>
<simpara>Note that adding a uniqueness constraint on a property will also add an index on that property, so you cannot add such an index separately.
Cypher will use that index for lookups just like other indexes.
If you drop a constraint and still want an index on the property, you will have to create the index.</simpara>
<section id="constraints-create-uniqueness-constraint">
<title>Create uniqueness constraint</title>
<simpara>To create a constraint that makes sure that your database will never contain more than one node with a specific label and one property value, use the <literal>IS</literal> <literal>UNIQUE</literal> syntax.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE CONSTRAINT ON (book:Book) ASSERT book.isbn IS UNIQUE</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Constraints added: 1</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
<formalpara role="cypherconsole"><title>Try this query live</title><para><database>(0)
</database><command>CREATE CONSTRAINT ON (book:Book) ASSERT book.isbn IS UNIQUE</command></para></formalpara>
</section>
<section id="constraints-drop-uniqueness-constraint">
<title>Drop uniqueness constraint</title>
<simpara>By using <literal>DROP</literal> <literal>CONSTRAINT</literal>, you remove a constraint from the database.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">DROP CONSTRAINT ON (book:Book) ASSERT book.isbn IS UNIQUE</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Constraints removed: 1</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
</section>
<section id="constraints-create-a-node-that-complies-with-constraints">
<title>Create a node that complies with constraints</title>
<simpara>Create a <literal>Book</literal> node with an <literal>isbn</literal> that isn&#8217;t already in the database.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (book:Book { isbn: '1449356265', title: 'Graph Databases' })</programlisting>
</para></formalpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">Nodes created: 1
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Properties set: 2
</entry></row><row><entry align="left" valign="top" namest="col1" nameend="col1">Labels added: 1</entry></row></tfoot><tbody><row><entry role="emptyresult" align="left" valign="top" namest="col1" nameend="col1"><simpara><literal>(empty result)</literal></simpara></entry></row></tbody></tgroup></table>
</section>
<section id="constraints-create-a-node-that-breaks-a-constraint">
<title>Create a node that breaks a constraint</title>
<simpara>Create a <literal>Book</literal> node with an <literal>isbn</literal> that is already used in the database.</simpara>
<formalpara><title>Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (book:Book { isbn: '1449356265', title: 'Graph Databases' })</programlisting>
</para></formalpara>
<formalpara><title>Error message</title><para>
<programlisting language="plain" linenumbering="unnumbered">Node 0 already exists with label Book and property "isbn"=[1449356265]</programlisting>
</para></formalpara>
</section>
</section>
</chapter>
<chapter id="examples-from-sql-to-cypher">
<title>From SQL to Cypher</title>
<simpara>This guide is for people who understand SQL. You can use that prior
knowledge to quickly get going with Cypher and start exploring Neo4j.</simpara>
<section id="query-sql-start">
<title>Start</title>
<simpara>SQL starts with the result you want&#8201;&#8212;&#8201;we <literal>SELECT</literal> what we want and then
declare how to source it. In Cypher, the <literal>START</literal> clause is quite a
different concept which specifies starting points in the graph from which
the query will execute.</simpara>
<simpara>From a SQL point of view, the identifiers in <literal>START</literal> are like table names
that point to a set of nodes or relationships. The set can be listed
literally, come via parameters, or as I show in the following example, be
defined by an index look-up.</simpara>
<simpara>So in fact rather than being <literal>SELECT</literal>-like, the <literal>START</literal> clause is
somewhere between the <literal>FROM</literal> and the <literal>WHERE</literal> clause in SQL.</simpara>
<formalpara><title>SQL Query</title><para>
<programlisting language="sql" linenumbering="unnumbered">SELECT *
FROM "Person"
WHERE name = 'Anakin'</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="4"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><colspec colname="col4"/><thead><row><entry align="left" valign="top">NAME</entry><entry align="left" valign="top">ID</entry><entry align="left" valign="top">AGE</entry><entry align="left" valign="top">HAIR</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col4">1 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Anakin</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>20</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>blonde</literal></simpara></entry></row></tbody></tgroup></informaltable>
<formalpara><title>Cypher Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START person=node:Person(name = 'Anakin')
RETURN person</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">person</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[0]{name:"Anakin",id:1,age:20,hair:"blonde"}</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Cypher allows multiple starting points. This should not be strange from a SQL perspective&#8201;&#8212;&#8201;every table in the <literal>FROM</literal> clause is another starting point.</simpara>
</section>
<section id="query-sql-match">
<title>Match</title>
<simpara>Unlike SQL which operates on sets, Cypher predominantly works on sub-graphs.
The relational equivalent is the current set of tuples being evaluated during a <literal>SELECT</literal> query.</simpara>
<simpara>The shape of the sub-graph is specified in the <literal>MATCH</literal> clause.
The <literal>MATCH</literal> clause is analogous to the <literal>JOIN</literal> in SQL. A normal a&#8594;b relationship is an
inner join between nodes a and b&#8201;&#8212;&#8201;both sides have to have at least one match, or nothing is returned.</simpara>
<simpara>We&#8217;ll start with a simple example, where we find all email addresses that are connected to
the person &#8220;Anakin&#8221;. This is an ordinary one-to-many relationship.</simpara>
<formalpara><title>SQL Query</title><para>
<programlisting language="sql" linenumbering="unnumbered">SELECT "Email".*
FROM "Person"
JOIN "Email" ON "Person".id = "Email".person_id
WHERE "Person".name = 'Anakin'</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="3"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><thead><row><entry align="left" valign="top">ADDRESS</entry><entry align="left" valign="top">COMMENT</entry><entry align="left" valign="top">PERSON_ID</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col3">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>anakin@example.com</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>home</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>anakin@example.org</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>work</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row></tbody></tgroup></informaltable>
<formalpara><title>Cypher Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START person=node:Person(name = 'Anakin')
MATCH person-[:email]-&gt;email
RETURN email</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">email</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[6]{address:"anakin@example.com",comment:"home"}</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Node[7]{address:"anakin@example.org",comment:"work"}</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>There is no join table here, but if one is necessary the next example will show how to do that, writing the pattern relationship like so:
<literal>-[r:belongs_to]-&gt;</literal> will introduce (the equivalent of) join table available as the variable <literal>r</literal>.
In reality this is a named relationship in Cypher, so we&#8217;re saying &#8220;join <literal>Person</literal> to <literal>Group</literal> via <literal>belongs_to</literal>.&#8221;
To illustrate this, consider this image, comparing the SQL model and Neo4j/Cypher.</simpara>
<informalfigure>
<ulink url="images/RDBMSvsGraph.svg.png">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/RDBMSvsGraph.svg.png" width="100%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>RDBMSvsGraph.svg.png</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>And here are example queries:</simpara>
<formalpara><title>SQL Query</title><para>
<programlisting language="sql" linenumbering="unnumbered">SELECT "Group".*, "Person_Group".*
FROM "Person"
JOIN "Person_Group" ON "Person".id = "Person_Group".person_id
JOIN "Group" ON "Person_Group".Group_id="Group".id
WHERE "Person".name = 'Bridget'</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="5"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><colspec colname="col4"/><colspec colname="col5"/><thead><row><entry align="left" valign="top">NAME</entry><entry align="left" valign="top">ID</entry><entry align="left" valign="top">BELONGS_TO_GROUP_ID</entry><entry align="left" valign="top">PERSON_ID</entry><entry align="left" valign="top">GROUP_ID</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col5">1 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Admin</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry></row></tbody></tgroup></informaltable>
<formalpara><title>Cypher Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START person=node:Person(name = 'Bridget')
MATCH person-[r:belongs_to]-&gt;group
RETURN group, r</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">group</entry><entry align="left" valign="top">r</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[5]{name:"Admin",id:4}</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>:belongs_to[0]{}</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>An <ulink url="http://www.codinghorror.com/blog/2007/10/a-visual-explanation-of-sql-joins.html">outer join</ulink> is just as easy.
Add <literal>OPTIONAL</literal> before the match and it&#8217;s an optional relationship between nodes&#8201;&#8212;&#8201;the outer join of Cypher.</simpara>
<simpara>Whether it&#8217;s a left outer join, or a right outer join is defined by which side of the pattern has a starting point.
This example is a left outer join, because the bound node is on the left side:</simpara>
<formalpara><title>SQL Query</title><para>
<programlisting language="sql" linenumbering="unnumbered">SELECT "Person".name, "Email".address
FROM "Person" LEFT
JOIN "Email" ON "Person".id = "Email".person_id</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">NAME</entry><entry align="left" valign="top">ADDRESS</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Anakin</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>anakin@example.com</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Anakin</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>anakin@example.org</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Bridget</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry></row></tbody></tgroup></informaltable>
<formalpara><title>Cypher Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START person=node:Person('name: *')
OPTIONAL MATCH person-[:email]-&gt;email
RETURN person.name, email.address</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">person.name</entry><entry align="left" valign="top">email.address</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Anakin"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"anakin@example.com"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Anakin"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"anakin@example.org"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Bridget"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>&lt;null&gt;</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Relationships in Neo4j are first class citizens&#8201;&#8212;&#8201;it&#8217;s like the SQL tables are pre-joined with each other.
So, naturally, Cypher is designed to be able to handle highly connected data easily.</simpara>
<simpara>One such domain is tree structures&#8201;&#8212;&#8201;anyone that has tried storing tree structures in SQL knows
that you have to work hard to get around the limitations of the relational model.
There are even books on the subject.</simpara>
<simpara>To find all the groups and sub-groups that Bridget belongs to, this query is enough in Cypher:</simpara>
<formalpara><title>Cypher Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START person=node:Person('name: Bridget')
MATCH person-[:belongs_to*]-&gt;group
RETURN person.name, group.name</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">person.name</entry><entry align="left" valign="top">group.name</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">3 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Bridget"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Admin"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Bridget"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"Technichian"</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Bridget"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>"User"</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>The * after the relationship type means that there can be multiple hops across <literal>belongs_to</literal> relationships between group and user.
Some SQL dialects have recursive abilities, that allow the expression of queries like this, but you may have a hard time wrapping your head around those.
Expressing something like this in SQL is hugely impractical if not practically impossible.</simpara>
</section>
<section id="query-sql-where">
<title>Where</title>
<simpara>This is the easiest thing to understand&#8201;&#8212;&#8201;it&#8217;s the same animal in both languages.
It filters out result sets/subgraphs.
Not all predicates have an equivalent in the other language, but the concept is the same.</simpara>
<formalpara><title>SQL Query</title><para>
<programlisting language="sql" linenumbering="unnumbered">SELECT *
FROM "Person"
WHERE "Person".age &gt; 35 AND "Person".hair = 'blonde'</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="4"><colspec colname="col1"/><colspec colname="col2"/><colspec colname="col3"/><colspec colname="col4"/><thead><row><entry align="left" valign="top">NAME</entry><entry align="left" valign="top">ID</entry><entry align="left" valign="top">AGE</entry><entry align="left" valign="top">HAIR</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col4">1 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Bridget</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>40</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>blonde</literal></simpara></entry></row></tbody></tgroup></informaltable>
<formalpara><title>Cypher Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START person=node:Person('name: *')
WHERE person.age &gt; 35 AND person.hair = 'blonde'
RETURN person</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="1"><colspec colname="col1"/><thead><row><entry align="left" valign="top">person</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col1">1 row</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Node[1]{name:"Bridget",id:2,age:40,hair:"blonde"}</literal></simpara></entry></row></tbody></tgroup></informaltable>
</section>
<section id="query-sql-return">
<title>Return</title>
<simpara>This is SQL&#8217;s <literal>SELECT</literal>.
We just put it in the end because it felt better to have it there&#8201;&#8212;&#8201;you do a lot of matching and filtering, and finally, you return something.</simpara>
<simpara>Aggregate queries work just like they do in SQL, apart from the fact that there is no explicit <literal>GROUP BY</literal> clause.
Everything in the return clause that is not an aggregate function will be used as the grouping columns.</simpara>
<formalpara><title>SQL Query</title><para>
<programlisting language="sql" linenumbering="unnumbered">SELECT "Person".name, count(*)
FROM "Person"
GROUP BY "Person".name
ORDER BY "Person".name</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">NAME</entry><entry align="left" valign="top">C2</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Anakin</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Bridget</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row></tbody></tgroup></informaltable>
<formalpara><title>Cypher Query</title><para>
<programlisting language="cypher" linenumbering="unnumbered">START person=node:Person('name: *')
RETURN person.name, count(*)
ORDER BY person.name</programlisting>
</para></formalpara>
<informaltable tabstyle="queryresult table" frame="none" rowsep="1" colsep="1"><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">person.name</entry><entry align="left" valign="top">count(*)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">2 rows</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>"Anakin"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>"Bridget"</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row></tbody></tgroup></informaltable>
<simpara>Order by is the same in both languages&#8201;&#8212;&#8201;<literal>ORDER BY</literal> expression <literal>ASC</literal>/<literal>DESC</literal>.
Nothing weird here.</simpara>
</section>
</chapter>
</part>
<part id="reference-documentation">
<title>Reference</title>
<partintro>
<simpara>The reference part is the authoritative source for details on Neo4j usage.
It covers details on capabilities, transactions, indexing and queries among other topics.</simpara>
</partintro>
<chapter id="capabilities">
<title>Capabilities</title>
<section id="capabilities-data-security">
<title>Data Security</title>
<simpara>Some data may need to be protected from unauthorized access (e.g., theft, modification).
Neo4j does not deal with data encryption explicitly, but supports all means built into the Java programming language and the JVM to protect data by encrypting it before storing.</simpara>
<simpara>Furthermore, data can be easily secured by running on an encrypted datastore at the file system level.
Finally, data protection should be considered in the upper layers of the surrounding system in order to prevent problems with scraping, malicious data insertion, and other threats.</simpara>
</section>
<section id="capabilities-data-integrity">
<title>Data Integrity</title>
<simpara>In order to keep data consistent, there needs to be mechanisms and structures that guarantee the integrity of all stored data.
In Neo4j, data integrity is maintained for the core graph engine together with other data sources - see below.</simpara>
<section id="capabilities-core-graph-engine">
<title>Core Graph Engine</title>
<simpara>In Neo4j, the whole data model is stored as a graph on disk and persisted as
part of every committed transaction.
In the storage layer, Relationships, Nodes, and Properties have direct pointers to each other.
This maintains integrity without the need for data duplication between the different backend store files.</simpara>
</section>
<section id="capabilities-different-data-sources">
<title>Different Data Sources</title>
<simpara>In a number of scenarios, the core graph engine is combined with other systems
in order to achieve optimal performance for non-graph lookups.
For example, Apache Lucene is frequently used as an additional index system for text queries that would otherwise be very processing-intensive in the graph layer.</simpara>
<simpara>To keep these external systems in synchronization with each other, Neo4j provides
full Two Phase Commit transaction management, with rollback support over all data
sources.
Thus, failed index insertions into Lucene can be transparently rolled back in all data sources and thus keep data up-to-date.</simpara>
</section>
</section>
<section id="capabilities-data-integration">
<title>Data Integration</title>
<simpara>Most enterprises rely primarily on relational databases to store their data, but
this may cause performance limitations.
In some of these cases, Neo4j can be used as an extension to supplement search/lookup for faster decision making.
However, in any situation where multiple data repositories contain the same data, synchronization can be an issue.</simpara>
<simpara>In some applications, it is acceptable for the search platform to be slightly out
of sync with the relational database.
In others, tight data integrity (eg., between Neo4j and RDBMS) is necessary.
Typically, this has to be addressed for data changing in real-time and for bulk data changes happening in the RDBMS.</simpara>
<simpara>A few strategies for synchronizing integrated data follows.</simpara>
<section id="capabilities-event-based-synchronization">
<title>Event-based Synchronization</title>
<simpara>In this scenario, all data stores, both RDBMS and Neo4j, are fed with domain-specific
events via an event bus.
Thus, the data held in the different backends is not actually synchronized but rather replicated.</simpara>
</section>
<section id="capabilities-periodic-synchronization">
<title>Periodic Synchronization</title>
<simpara>Another viable scenario is the periodic export of the latest changes in the RDBMS to
Neo4j via some form of SQL query.
This allows a small amount of latency in the synchronization, but has the advantage of using the RDBMS as the master for all data purposes.
The same process can be applied with Neo4j as the master data source.</simpara>
</section>
<section id="capabilities-full-export">
<title>Periodic Full Export/Import of Data</title>
<simpara>Using the Batch Inserter tools for Neo4j, even large amounts of data can be imported
into the database in very short times.
Thus, a full export from the RDBMS and import into Neo4j becomes possible.
If the propagation lag between the RDBMS and Neo4j is not a big issue, this is a very viable solution.</simpara>
</section>
</section>
<section id="capabilities-availability">
<title>Availability and Reliability</title>
<simpara>Most mission-critical systems require the database subsystem to be accessible at all
times.
Neo4j ensures availability and reliability through a few different strategies.</simpara>
<section id="capabilities-op-availability">
<title>Operational Availability</title>
<simpara>In order not to create a single point of failure, Neo4j supports different
approaches which provide transparent fallback and/or recovery from failures.</simpara>
<section id="_online_backup_cold_spare">
<title>Online backup (Cold spare)</title>
<simpara>In this approach, a single instance of the master database is used, with Online
Backup enabled.
In case of a failure, the backup files can be mounted onto a new
Neo4j instance and reintegrated into the application.</simpara>
</section>
<section id="_online_backup_high_availability_hot_spare">
<title>Online Backup High Availability (Hot spare)</title>
<simpara>Here, a Neo4j "backup" instance listens to online transfers of changes from the
master.
In the event of a failure of the master, the backup is already running
and can directly take over the load.</simpara>
</section>
<section id="_high_availability_cluster">
<title>High Availability cluster</title>
<simpara>This approach uses a cluster of database instances, with one (read/write) master
and a number of (read-only) slaves.
Failing slaves can simply be restarted and brought back online.
Alternatively, a new slave may be added by cloning an existing one.
Should the master instance fail, a new master will be elected by the remaining
cluster nodes.</simpara>
</section>
</section>
<section id="capabilities-disaster">
<title>Disaster Recovery/ Resiliency</title>
<simpara>In cases of a breakdown of major part of the IT infrastructure, there need to be
mechanisms in place that enable the fast recovery and regrouping of the remaining
services and servers.
In Neo4j, there are different components that are suitable to be part of a disaster recovery strategy.</simpara>
<section id="_prevention">
<title>Prevention</title>
<itemizedlist>
<listitem>
<simpara>
Online Backup High Availability to other locations outside the current data center.
</simpara>
</listitem>
<listitem>
<simpara>
Online Backup to different file system locations: this is a simpler form of backup,
applying changes directly to backup files; it is thus more suited for local backup scenarios.
</simpara>
</listitem>
<listitem>
<simpara>
Neo4j High Availability cluster: a cluster of one write-master Neo4j server and a number of read-slaves, getting transaction logs from the master.
  Write-master failover is handled by quorum election among the read-slaves for a new master.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_detection">
<title>Detection</title>
<itemizedlist>
<listitem>
<simpara>
SNMP and JMX monitoring can be used for the Neo4j database.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_correction">
<title>Correction</title>
<itemizedlist>
<listitem>
<simpara>
Online Backup: A new Neo4j server can be started directly on the backed-up files
and take over new requests.
</simpara>
</listitem>
<listitem>
<simpara>
Neo4j High Availability cluster: A broken Neo4j read slave can be reinserted into the cluster, getting the latest updates from the master.
  Alternatively, a new server can be inserted by copying an existing server and applying the latest updates to it.
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section id="capabilities-capacity">
<title>Capacity</title>
<section id="capabilities-file-sizes">
<title>File Sizes</title>
<simpara>Neo4j relies on Java&#8217;s Non-blocking I/O subsystem for all file handling.
Furthermore, while the storage file layout is optimized for interconnected data, Neo4j does not require raw devices.
Thus, filesizes are only limited by the underlying operating system&#8217;s capacity to handle large files.
Physically, there is no built-in limit of the file handling capacity in Neo4j.</simpara>
<simpara>Neo4j tries to memory-map as much of the underlying store files as possible.
If the available RAM is not sufficient to keep all data in RAM, Neo4j will use buffers in some cases, reallocating the memory-mapped high-performance I/O windows to the regions with the most I/O activity dynamically.
Thus, ACID speed degrades gracefully as RAM becomes the limiting factor.</simpara>
</section>
<section id="capabilities-read-speed">
<title>Read speed</title>
<simpara>Enterprises want to optimize the use of hardware to deliver the maximum business value
from available resources.
Neo4j&#8217;s approach to reading data provides the best possible usage of all available hardware resources.
Neo4j does not block or lock any read operations; thus, there is no danger for deadlocks in read operations and no need for read transactions.
With a threaded read access to the database, queries can be run simultaneously on as many processors as may be available.
This provides very good scale-up scenarios with bigger servers.</simpara>
</section>
<section id="capabilities-write-speed">
<title>Write speed</title>
<simpara>Write speed is a consideration for many enterprise applications.
However, there are two different scenarios:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
sustained continuous operation and
</simpara>
</listitem>
<listitem>
<simpara>
bulk access (e.g., backup, initial or batch loading).
</simpara>
</listitem>
</orderedlist>
<simpara>To support the disparate requirements of these scenarios, Neo4j supports two modes of writing to the storage layer.</simpara>
<simpara>In transactional, ACID-compliant normal operation, isolation level is maintained and
read operations can occur at the same time as the writing process.
At every commit, the data is persisted to disk and can be recovered to a consistent state upon system failures.
This requires disk write access and a real flushing of data.
Thus, the write speed of Neo4j on a single server in continuous mode is limited by the I/O capacity of the hardware.
Consequently, the use of fast SSDs is highly recommended for production scenarios.</simpara>
<simpara>Neo4j has a Batch Inserter that operates directly on the store files.
This mode does not provide transactional security, so it can only be used when there is a single write thread.
Because data is written sequentially, and never flushed to the logical logs, huge performance boosts are achieved.
The Batch Inserter is optimized for non-transactional bulk import of large amounts of data.</simpara>
</section>
<section id="capabilities-data-size">
<title>Data size</title>
<simpara>In Neo4j, data size is mainly limited by the address space of the primary keys for Nodes, Relationships, Properties and RelationshipTypes.
Currently, the address space is as follows:</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>nodes</simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>35</superscript> (&#8764; 34 billion)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>relationships</simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>35</superscript> (&#8764; 34 billion)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>properties</simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>36</superscript> to 2<superscript>38</superscript> depending on property types (maximum &#8764; 274 billion, always at least &#8764; 68 billion)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>relationship types</simpara></entry>
<entry align="left" valign="top"><simpara>2<superscript>15</superscript> (&#8764; 32 000)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
</chapter>
<chapter id="transactions">
<title>Transaction Management</title>
<simpara>In order to fully maintain data integrity and ensure good transactional behavior, Neo4j supports the ACID properties:</simpara>
<itemizedlist>
<listitem>
<simpara>
atomicity: If any part of a transaction fails, the database state is left unchanged.
</simpara>
</listitem>
<listitem>
<simpara>
consistency: Any transaction will leave the database in a consistent state.
</simpara>
</listitem>
<listitem>
<simpara>
isolation: During a transaction, modified data cannot be accessed by other operations.
</simpara>
</listitem>
<listitem>
<simpara>
durability: The DBMS can always recover the results of a committed transaction.
</simpara>
</listitem>
</itemizedlist>
<simpara>Specifically:</simpara>
<itemizedlist>
<listitem>
<simpara>
All database operations that access the graph, indexes, or the schema must be performed in a transaction.
</simpara>
</listitem>
<listitem>
<simpara>
The default isolation level is <literal>READ_COMMITTED</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Data retrieved by traversals is not protected from modification by other transactions.
</simpara>
</listitem>
<listitem>
<simpara>
Non-repeatable reads may occur (i.e., only write locks are acquired and held until the end of the transaction).
</simpara>
</listitem>
<listitem>
<simpara>
One can manually acquire write locks on nodes and relationships to achieve higher level of isolation (<literal>SERIALIZABLE</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
Locks are acquired at the Node and Relationship level.
</simpara>
</listitem>
<listitem>
<simpara>
Deadlock detection is built into the core transaction management.
</simpara>
</listitem>
</itemizedlist>
<section id="transactions-interaction">
<title>Interaction cycle</title>
<simpara>All database operations that access the graph, indexes, or the schema must be performed in a transaction.
Transactions are thread confined and can be nested as “flat nested transactions”.
Flat nested transactions means that all nested transactions are added to the scope of the top level transaction.
A nested transaction can mark the top level transaction for rollback, meaning the entire transaction will be rolled back.
To only rollback changes made in a nested transaction is not possible.</simpara>
<simpara>The interaction cycle of working with transactions looks like this:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Begin a transaction.
</simpara>
</listitem>
<listitem>
<simpara>
Perform database operations.
</simpara>
</listitem>
<listitem>
<simpara>
Mark the transaction as successful or not.
</simpara>
</listitem>
<listitem>
<simpara>
Finish the transaction.
</simpara>
</listitem>
</orderedlist>
<simpara><emphasis>It is very important to finish each transaction</emphasis>. The transaction will not release the locks or memory it has acquired until it has been finished.
The idiomatic use of transactions in Neo4j is to use a try-finally block, starting the transaction and then try to perform the write operations.
The last operation in the try block should mark the transaction as successful while the finally block should finish the transaction.
Finishing the transaction will perform commit or rollback depending on the success status.</simpara>
<caution><simpara><emphasis>All modifications performed in a transaction are kept in memory.</emphasis>
This means that very large updates have to be split into several top level transactions to avoid running out of memory.
It must be a top level transaction since splitting up the work in many nested transactions will just add all the work to the top level transaction.</simpara></caution>
<simpara>In an environment that makes use of <emphasis><indexterm><primary>thread pooling</primary></indexterm>thread pooling</emphasis> other errors may occur when failing to finish a transaction properly.
Consider a leaked transaction that did not get finished properly.
It will be tied to a thread and when that thread gets scheduled to perform work starting a new (what looks to be a) top level transaction it will actually be a nested transaction.
If the leaked transaction state is “marked for rollback” (which will happen if a deadlock was detected) no more work can be performed on that transaction.
Trying to do so will result in error on each call to a write operation.</simpara>
</section>
<section id="transactions-isolation">
<title>Isolation levels</title>
<simpara>By default a read operation will read the last committed value unless a local modification within the current transaction exist.
The default isolation level is very similar to <literal>READ_COMMITTED</literal>: reads do not block or take any locks so non-repeatable reads can occur.
It is possible to achieve a stronger isolation level (such as <literal>REPETABLE_READ</literal> and <literal>SERIALIZABLE</literal>) by manually acquiring read and write locks.</simpara>
</section>
<section id="transactions-locking">
<title>Default locking behavior</title>
<itemizedlist>
<listitem>
<simpara>
When adding, changing or removing a property on a node or relationship a write lock will be taken on the specific node or relationship.
</simpara>
</listitem>
<listitem>
<simpara>
When creating or deleting a node a write lock will be taken for the specific node.
</simpara>
</listitem>
<listitem>
<simpara>
When creating or deleting a relationship a write lock will be taken on the specific relationship and both its nodes.
</simpara>
</listitem>
</itemizedlist>
<simpara>The locks will be added to the transaction and released when the transaction finishes.</simpara>
</section>
<section id="transactions-deadlocks">
<title>Deadlocks</title>
<simpara>Since locks are used it is possible for deadlocks to happen.
Neo4j will however detect any deadlock (caused by acquiring a lock) before they happen and throw an exception.
Before the exception is thrown the transaction is marked for rollback.
All locks acquired by the transaction are still being held but will be released when the transaction is finished (in the finally block as pointed out earlier).
Once the locks are released other transactions that were waiting for locks held by the transaction causing the deadlock can proceed.
The work performed by the transaction causing the deadlock can then be retried by the user if needed.</simpara>
<simpara>Experiencing frequent deadlocks is an indication of concurrent write requests happening in such a way that it is not possible to execute them while at the same time live up to the intended isolation and consistency.
The solution is to make sure concurrent updates happen in a reasonable way.
For example given two specific nodes (A and B), adding or deleting relationships to both these nodes in random order for each transaction will result in deadlocks when there are two or more transactions doing that concurrently.
One solution is to make sure that updates always happens in the same order (first A then B).
Another solution is to make sure that each thread/transaction does not have any conflicting writes to a node or relationship as some other concurrent transaction.
This can for example be achieved by letting a single thread do all updates of a specific type.</simpara>
<important><simpara>Deadlocks caused by the use of other synchronization than the locks managed by Neo4j can still happen.
Since all operations in the Neo4j API are thread safe unless specified otherwise, there is no need for external synchronization.
Other code that requires synchronization should be synchronized in such a way that it never performs any Neo4j operation in the synchronized block.</simpara></important>
</section>
<section id="transactions-delete">
<title>Delete semantics</title>
<simpara>When deleting a node or a relationship all properties for that entity will be automatically removed but the relationships of a node will not be removed.</simpara>
<caution><simpara>Neo4j enforces a constraint (upon commit) that all relationships must have a valid start node and end node.
In effect this means that trying to delete a node that still has relationships attached to it will throw an exception upon commit.
It is however possible to choose in which order to delete the node and the attached relationships as long as no relationships exist when the transaction is committed.</simpara></caution>
<simpara>The delete semantics can be summarized in the following bullets:</simpara>
<itemizedlist>
<listitem>
<simpara>
All properties of a node or relationship will be removed when it is deleted.
</simpara>
</listitem>
<listitem>
<simpara>
A deleted node can not have any attached relationships when the transaction commits.
</simpara>
</listitem>
<listitem>
<simpara>
It is possible to acquire a reference to a deleted relationship or node that has not yet been committed.
</simpara>
</listitem>
<listitem>
<simpara>
Any write operation on a node or relationship after it has been deleted (but not yet committed) will throw an exception
</simpara>
</listitem>
<listitem>
<simpara>
After commit trying to acquire a new or work with an old reference to a deleted node or relationship will throw an exception.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="transactions-unique-nodes">
<title>Creating unique nodes</title>
<simpara>In many use cases, a certain level of uniqueness is desired among entities.
You could for instance imagine that only one user with a certain e-mail address may exist in a system.
If multiple concurrent threads naively try to create the user, duplicates will be created.
There are three main strategies for ensuring uniqueness, and they all work across High Availability and single-instance deployments.</simpara>
<section id="_single_thread">
<title>Single thread</title>
<simpara>By using a single thread, no two threads will even try to create a particular entity simultaneously.
On High Availability, an external single-threaded client can perform the operations on the cluster.</simpara>
</section>
<section id="transactions-get-or-create">
<title>Get or create</title>
<simpara>The preferred way to get or create a unique node is to use unique constraints and Cypher.
See <xref linkend="tutorials-java-embedded-unique-get-or-create"/> for more information.</simpara>
<simpara>By using <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/Index.html#putIfAbsent%28T,%20java.lang.String,%20java.lang.Object%29"><literal>put-if-absent</literal></ulink> functionality,
entity uniqueness can be guaranteed using a legacy index. Here the legacy index acts as the lock and will only lock the smallest part needed to guaranteed uniqueness across threads and transactions.</simpara>
<simpara>See <xref linkend="tutorials-java-embedded-unique-get-or-create-with-factory"/> for how to do this using the core Java API.
When using the REST API, see <xref linkend="rest-api-unique-indexes"/>.</simpara>
</section>
<section id="_pessimistic_locking">
<title>Pessimistic locking</title>
<important><simpara>While this is a working solution, please consider using the preferred  <xref linkend="transactions-get-or-create"/> instead.</simpara></important>
<simpara>By using explicit, pessimistic locking, unique creation of entities can be achieved in a multi-threaded environment.
It is most commonly done by locking on a single or a set of common nodes.</simpara>
<simpara>See <xref linkend="tutorials-java-embedded-unique-pessimistic"/> for how to do this using the core Java API.</simpara>
</section>
</section>
<section id="transactions-events">
<title>Transaction events</title>
<simpara>Transaction event handlers can be registered to receive Neo4j Transaction events.
Once it has been registered at a <literal>GraphDatabaseService</literal> instance it will receive events about what has happened in each transaction which is about to be committed.
Handlers won&#8217;t get notified about transactions which haven&#8217;t performed any write operation or won&#8217;t be committed (either if <literal>Transaction#success()</literal> hasn&#8217;t been called or the transaction has been marked as failed <literal>Transaction#failure()</literal>.
Right before a transaction is about to be committed the <literal>beforeCommit</literal> method is called with the entire diff of modifications made in the transaction.
At this point the transaction is still running so changes can still be made. However there&#8217;s no guarantee that other handlers will see such changes since the order in which handlers are executed is undefined.
This method can also throw an exception and will, in such a case, prevent the transaction from being committed (where a call to <literal>afterRollback</literal> will follow).
If <literal>beforeCommit</literal> is successfully executed the transaction will be committed and the <literal>afterCommit</literal> method will be called with the same transaction data as well as the object returned from <literal>beforeCommit</literal>.
This assumes that all other handlers (if more were registered) also executed <literal>beforeCommit</literal> successfully.</simpara>
</section>
</chapter>
<chapter id="import">
<title>Data Import</title>
<simpara>For importing data into Neo4j, see <ulink url="http://www.neo4j.org/develop/import">http://www.neo4j.org/develop/import</ulink>.</simpara>
<simpara>For high-performance data import, see <xref linkend="batchinsert"/>.</simpara>
</chapter>
<chapter id="graph-algo">
<title>Graph Algorithms</title>
<simpara>Neo4j graph algorithms is a component that contains Neo4j implementations of some common algorithms for graphs.
It includes algorithms like:</simpara>
<itemizedlist>
<listitem>
<simpara>
Shortest paths,
</simpara>
</listitem>
<listitem>
<simpara>
all paths,
</simpara>
</listitem>
<listitem>
<simpara>
all simple paths,
</simpara>
</listitem>
<listitem>
<simpara>
Dijkstra and
</simpara>
</listitem>
<listitem>
<simpara>
A*.
</simpara>
</listitem>
</itemizedlist>
<section id="graph-algo-introduction">
<title>Introduction</title>
<simpara>The graph algorithms are found in the <literal>neo4j-graph-algo</literal> component, which is included in the standard Neo4j download.</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphalgo/package-summary.html">Javadocs</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-graph-algo%22">Download</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/neo4j/neo4j/tree/master/community/graph-algo">Source code</ulink>
</simpara>
</listitem>
</itemizedlist>
<simpara>For examples, see <xref linkend="rest-api-graph-algos"/> (REST API) and <xref linkend="tutorials-java-embedded-graph-algo"/> (embedded database).</simpara>
<simpara>For information on how to use neo4j-graph-algo as a dependency with Maven and other dependency management tools, see <literal><ulink url="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-graph-algo%22">org.neo4j:neo4j-graph-algo</ulink></literal>
Note that it should be used with the same version of <literal><ulink url="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-kernel%22">org.neo4j:neo4j-kernel</ulink></literal>.
Different versions of the graph-algo and kernel components are not compatible in the general case.
Both components are included transitively by the <literal><ulink url="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.neo4j%22%20AND%20a%3A%22neo4j%22">org.neo4j:neo4j</ulink></literal> artifact which makes it simple to keep the versions in sync.</simpara>
<simpara>The starting point to find and use graph algorithms is <literal><ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphalgo/GraphAlgoFactory.html">GraphAlgoFactory</ulink></literal> when using the Java Core API.</simpara>
</section>
</chapter>
<chapter id="rest-api">
<title>REST API</title>
<simpara>The Neo4j REST API is designed with discoverability in mind, so that you can start with a <literal>GET</literal> on the <xref linkend="rest-api-service-root"/> and from there discover URIs to perform other requests.
The examples below uses URIs in the examples; they are subject to change in the future, so for future-proofness <emphasis>discover URIs where possible</emphasis>, instead of relying on the current layout.
The default representation is <ulink url="http://www.json.org/">json</ulink>, both for responses and for data sent with <literal>POST</literal>/<literal>PUT</literal> requests.</simpara>
<simpara>Below follows a listing of ways to interact with the REST API. For language bindings to the REST API, see <xref linkend="languages"/>.</simpara>
<simpara>To interact with the JSON interface you must explicitly set the request header <literal>Accept:application/json</literal> for those requests that responds with data.
You should also set the header <literal>Content-Type:application/json</literal> if your request sends data, for example when you&#8217;re creating a relationship.
The examples include the relevant request and response headers.</simpara>
<simpara>The server supports streaming results, with better performance and lower memory overhead.
See <xref linkend="rest-api-streaming"/> for more information.</simpara>
<section id="rest-api-transactional">
<title>Transactional HTTP endpoint</title>
<simpara>The Neo4j transactional HTTP endpoint allows you to execute a series of Cypher statements within the scope of a
transaction. The transaction may be kept open across multiple HTTP requests, until the client chooses to commit or roll
back. Each HTTP request can include a list of statements, and for convenience you can include statements along with a
request to begin or commit a transaction.</simpara>
<simpara>The server guards against orphaned transactions by using a timeout. If there are no requests for a given transaction
within the timeout period, the server will roll it back. You can configure the timeout in the server configuration, by
setting <emphasis>org.neo4j.server.transaction.timeout</emphasis> to the number of seconds before timeout. The default timeout is 60
seconds.</simpara>
<simpara>The key difference between the transactional HTTP endpoint and the Cypher endpoint (see <xref linkend="rest-api-cypher"/>) is the ability to
use the same transaction across multiple HTTP requests. The cypher endpoint always attempts to commit a transaction at
the end of each HTTP request.</simpara>
<note><simpara>The serialization format for cypher results is mostly the same as the <link linkend="rest-api-cypher">cypher endpoint</link>.
However, the format for raw entities is slightly less verbose and does not include hypermedia links.</simpara></note>
<note><simpara>Open transactions are not shared among members of an HA cluster. Therefore, if you use this endpoint in an HA cluster,
you must ensure that all requests for a given transaction are sent to the same Neo4j instance.</simpara></note>
<tip><simpara>In order to speed up queries in repeated scenarios, try not to use literals but replace them with parameters wherever
possible in order to let the server cache query plans.</simpara></tip>
<section id="rest-api-begin-a-transaction">
<title>Begin a transaction</title>
<simpara>You begin a new transaction by posting zero or more Cypher statements
to the transaction endpoint. The server will respond with the result of
your statements, as well as the location of your open transaction.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/transaction</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "statements" : [ {
    "statement" : "CREATE (n {props}) RETURN n",
    "parameters" : {
      "props" : {
        "name" : "My Node"
      }
    }
  } ]
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/transaction/7</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "commit" : "http://localhost:7474/db/data/transaction/7/commit",
  "results" : [ {
    "columns" : [ "n" ],
    "data" : [ {
      "row" : [ {
        "name" : "My Node"
      } ]
    } ]
  } ],
  "transaction" : {
    "expires" : "Wed, 29 Jan 2014 10:10:17 +0000"
  },
  "errors" : [ ]
}</programlisting>
</section>
<section id="rest-api-execute-statements-in-an-open-transaction">
<title>Execute statements in an open transaction</title>
<simpara>Given that you have an open transaction, you can make a number of requests, each of which executes additional
statements, and keeps the transaction open by resetting the transaction timeout.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/transaction/9</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "statements" : [ {
    "statement" : "CREATE n RETURN n"
  } ]
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "commit" : "http://localhost:7474/db/data/transaction/9/commit",
  "results" : [ {
    "columns" : [ "n" ],
    "data" : [ {
      "row" : [ {
      } ]
    } ]
  } ],
  "transaction" : {
    "expires" : "Wed, 29 Jan 2014 10:10:17 +0000"
  },
  "errors" : [ ]
}</programlisting>
</section>
<section id="rest-api-execute-statements-in-an-open-transaction-in-rest-format-for-the-return">
<title>Execute statements in an open transaction in REST format for the return</title>
<simpara>Given that you have an open transaction, you can make a number of requests, each of which executes additional
statements, and keeps the transaction open by resetting the transaction timeout. Specifying the <literal>REST</literal> format will
give back full Neo4j Rest API representations of the Neo4j Nodes, Relationships and Paths, if returned.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/transaction/1</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "statements" : [ {
    "statement" : "CREATE n RETURN n",
    "resultDataContents" : [ "REST" ]
  } ]
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "commit" : "http://localhost:7474/db/data/transaction/1/commit",
  "results" : [ {
    "columns" : [ "n" ],
    "data" : [ {
      "rest" : [ {
        "paged_traverse" : "http://localhost:7474/db/data/node/12/paged/traverse/{returnType}{?pageSize,leaseTime}",
        "labels" : "http://localhost:7474/db/data/node/12/labels",
        "outgoing_relationships" : "http://localhost:7474/db/data/node/12/relationships/out",
        "traverse" : "http://localhost:7474/db/data/node/12/traverse/{returnType}",
        "all_typed_relationships" : "http://localhost:7474/db/data/node/12/relationships/all/{-list|&amp;|types}",
        "property" : "http://localhost:7474/db/data/node/12/properties/{key}",
        "all_relationships" : "http://localhost:7474/db/data/node/12/relationships/all",
        "self" : "http://localhost:7474/db/data/node/12",
        "properties" : "http://localhost:7474/db/data/node/12/properties",
        "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/12/relationships/out/{-list|&amp;|types}",
        "incoming_relationships" : "http://localhost:7474/db/data/node/12/relationships/in",
        "incoming_typed_relationships" : "http://localhost:7474/db/data/node/12/relationships/in/{-list|&amp;|types}",
        "create_relationship" : "http://localhost:7474/db/data/node/12/relationships",
        "data" : {
        }
      } ]
    } ]
  } ],
  "transaction" : {
    "expires" : "Wed, 29 Jan 2014 10:10:13 +0000"
  },
  "errors" : [ ]
}</programlisting>
</section>
<section id="rest-api-reset-transaction-timeout-of-an-open-transaction">
<title>Reset transaction timeout of an open transaction</title>
<simpara>Every orphaned transaction is automatically expired after a period of inactivity.  This may be prevented
by resetting the transaction timeout.</simpara>
<simpara>The timeout may be reset by sending a keep-alive request to the server that executes an empty list of statements.
This request will reset the transaction timeout and return the new time at which the transaction will
expire as an RFC1123 formatted timestamp value in the &#8220;transaction&#8221; section of the response.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/transaction/2</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "statements" : [ ]
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "commit" : "http://localhost:7474/db/data/transaction/2/commit",
  "results" : [ ],
  "transaction" : {
    "expires" : "Wed, 29 Jan 2014 10:10:16 +0000"
  },
  "errors" : [ ]
}</programlisting>
</section>
<section id="rest-api-commit-an-open-transaction">
<title>Commit an open transaction</title>
<simpara>Given you have an open transaction, you can send a commit request. Optionally, you submit additional statements
along with the request that will be executed before committing the transaction.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/transaction/4/commit</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "statements" : [ {
    "statement" : "CREATE n RETURN id(n)"
  } ]
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "results" : [ {
    "columns" : [ "id(n)" ],
    "data" : [ {
      "row" : [ 14 ]
    } ]
  } ],
  "errors" : [ ]
}</programlisting>
</section>
<section id="rest-api-rollback-an-open-transaction">
<title>Rollback an open transaction</title>
<simpara>Given that you have an open transaction, you can send a roll back request. The server will roll back the
transaction.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/transaction/3</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "results" : [ ],
  "errors" : [ ]
}</programlisting>
</section>
<section id="rest-api-begin-and-commit-a-transaction-in-one-request">
<title>Begin and commit a transaction in one request</title>
<simpara>If there is no need to keep a transaction open across multiple HTTP requests, you can begin a transaction,
execute statements, and commit with just a single HTTP request.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/transaction/commit</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "statements" : [ {
    "statement" : "CREATE n RETURN id(n)"
  } ]
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "results" : [ {
    "columns" : [ "id(n)" ],
    "data" : [ {
      "row" : [ 15 ]
    } ]
  } ],
  "errors" : [ ]
}</programlisting>
</section>
<section id="rest-api-return-results-in-graph-format">
<title>Return results in graph format</title>
<simpara>If you want to understand the graph structure of nodes and relationships returned by your query,
you can specify the "graph" results data format. For example, this is useful when you want to visualise the
graph structure. The format collates all the nodes and relationships from all columns of the result,
and also flattens collections of nodes and relationships, including paths.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/transaction/commit</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "statements" : [ {
    "statement" : "CREATE ( bike:Bike { weight: 10 } )CREATE ( frontWheel:Wheel { spokes: 3 } )CREATE ( backWheel:Wheel { spokes: 32 } )CREATE p1 = bike -[:HAS { position: 1 } ]-&gt; frontWheel CREATE p2 = bike -[:HAS { position: 2 } ]-&gt; backWheel RETURN bike, p1, p2",
    "resultDataContents" : [ "row", "graph" ]
  } ]
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "results" : [ {
    "columns" : [ "bike", "p1", "p2" ],
    "data" : [ {
      "row" : [ {
        "weight" : 10
      }, [ {
        "weight" : 10
      }, {
        "position" : 1
      }, {
        "spokes" : 3
      } ], [ {
        "weight" : 10
      }, {
        "position" : 2
      }, {
        "spokes" : 32
      } ] ],
      "graph" : {
        "nodes" : [ {
          "id" : "17",
          "labels" : [ "Wheel" ],
          "properties" : {
            "spokes" : 3
          }
        }, {
          "id" : "16",
          "labels" : [ "Bike" ],
          "properties" : {
            "weight" : 10
          }
        }, {
          "id" : "18",
          "labels" : [ "Wheel" ],
          "properties" : {
            "spokes" : 32
          }
        } ],
        "relationships" : [ {
          "id" : "9",
          "type" : "HAS",
          "startNode" : "16",
          "endNode" : "17",
          "properties" : {
            "position" : 1
          }
        }, {
          "id" : "10",
          "type" : "HAS",
          "startNode" : "16",
          "endNode" : "18",
          "properties" : {
            "position" : 2
          }
        } ]
      }
    } ]
  } ],
  "errors" : [ ]
}</programlisting>
</section>
<section id="rest-api-handling-errors">
<title>Handling errors</title>
<simpara>The result of any request against the transaction endpoint is streamed back to the client.
Therefore the server does not know whether the request will be successful or not when it sends the HTTP status
code.</simpara>
<simpara>Because of this, all requests against the transactional endpoint will return 200 or 201 status code, regardless
of whether statements were successfully executed. At the end of the response payload, the server includes a list
of errors that occurred while executing statements. If this list is empty, the request completed successfully.</simpara>
<simpara>If any errors occur while executing statements, the server will roll back the transaction.</simpara>
<simpara>In this example, we send the server an invalid statement to demonstrate error handling.</simpara>
<simpara>For more information on the status codes, see <xref linkend="status-codes"/>.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/transaction/8/commit</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "statements" : [ {
    "statement" : "This is not a valid Cypher Statement."
  } ]
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "results" : [ ],
  "errors" : [ {
    "code" : "Neo.ClientError.Statement.InvalidSyntax",
    "message" : "Invalid input 'T': expected &lt;init&gt; (line 1, column 1)\n\"This is not a valid Cypher Statement.\"\n ^"
  } ]
}</programlisting>
</section>
</section>
<section id="status-codes">
<title>Neo4j Status Codes</title>
<simpara>The transactional endpoint may in any response include zero or more status codes, indicating issues or information for
the client. Each status code follows the same format: "Neo.[Classification].[Category].[Title]". The fact
that a status code is returned by the server does always mean there is a fatal error. Status codes can also indicate
transient problems that may go away if you retry the request.</simpara>
<simpara>What the effect of the status code is can be determined by its classification.</simpara>
<note><simpara>This is not the same thing as HTTP status codes. Neo4j Status Codes are returned in the response body, at the very end
of the response.</simpara></note>
<section id="_classifications">
<title>Classifications</title>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="60*"/>
<colspec colname="col_3" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Classification </entry>
<entry align="left" valign="top">Description </entry>
<entry align="left" valign="top">Effect on transaction</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ClientError</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Client sent a bad request - changing the request might yield a successful outcome.</simpara></entry>
<entry align="left" valign="top"><simpara>None</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DatabaseError</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The database failed to service the request.</simpara></entry>
<entry align="left" valign="top"><simpara>Rollback</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>TransientError</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The database cannot service the request right now, retrying later might yield a successful outcome.</simpara></entry>
<entry align="left" valign="top"><simpara>None</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_status_codes">
<title>Status codes</title>
<simpara>This is a complete list of all status codes Neo4j may return, and what they mean.</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Status Code </entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.General.ReadOnly</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is a read only database, writing or modifying the database is not allowed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Request.Invalid</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The client provided an invalid request.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Request.InvalidFormat</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The client provided a request that was missing required fields, or had values that are not allowed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Schema.ConstraintAlreadyExists</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Unable to perform operation because it would clash with a pre-existing constraint.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Schema.ConstraintVerificationFailure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Unable to create constraint because data that exists in the database violates it.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Schema.ConstraintViolation</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A constraint imposed by the database was violated.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Schema.IllegalTokenName</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A token name, such as a label, relationship type or property key, used is not valid. Tokens cannot be empty strings and cannot be null.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Schema.IndexAlreadyExists</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Unable to perform operation because it would clash with a pre-existing index.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Schema.IndexBelongsToConstraint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A requested operation can not be performed on the specified index because the index is part of a constraint. If you want to drop the index, for instance, you must drop the constraint.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Schema.LabelLimitReached</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum number of labels supported has been reached, no more labels can be created.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Schema.NoSuchConstraint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The request (directly or indirectly) referred to a constraint that does not exist.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Schema.NoSuchIndex</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The request (directly or indirectly) referred to an index that does not exist.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Statement.ArithmeticError</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Invalid use of arithmetic, such as dividing by zero.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Statement.ConstraintViolation</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A constraint imposed by the statement is violated by the data in the database.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Statement.EntityNotFound</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The statement is directly referring to an entity that does not exist.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Statement.InvalidSemantics</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The statement is syntactically valid, but expresses something that the database cannot do.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Statement.InvalidSyntax</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The statement contains invalid or unsupported syntax.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Statement.InvalidType</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The statement is attempting to perform operations on values with types that are not supported by the operation.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Statement.NoSuchProperty</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The statement is referring to a property that does not exist.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Statement.ParameterMissing</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The statement is referring to a parameter that was not provided in the request.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Transaction.ConcurrentRequest</literal></simpara></entry>
<entry align="left" valign="top"><simpara>There were concurrent requests accessing the same transaction, which is not allowed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Transaction.InvalidType</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The transaction is of the wrong type to service the request. For instance, a transaction that has had schema modifications performed in it cannot be used to subsequently perform data operations, and vice versa.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.ClientError.Transaction.UnknownId</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The request referred to a transaction that does not exist.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.General.CorruptSchemaRule</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A malformed schema rule was encountered. Please contact your support representative.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.General.FailedIndex</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The request (directly or indirectly) referred to an index that is in a failed state. The index needs to be dropped and recreated manually.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.General.UnknownFailure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An unknown failure occurred.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Schema.ConstraintCreationFailure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Creating a requested constraint failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Schema.ConstraintDropFailure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The database failed to drop a requested constraint.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Schema.IndexCreationFailure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to create an index.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Schema.IndexDropFailure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The database failed to drop a requested index.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Schema.NoSuchLabel</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The request accessed a label that did not exist.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Schema.NoSuchPropertyKey</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The request accessed a property that does not exist.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Schema.NoSuchRelationshipType</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The request accessed a relationship type that does not exist.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Schema.NoSuchSchemaRule</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The request referred to a schema rule that does not exist.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Statement.ExecutionFailure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The database was unable to execute the statement.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Transaction.CouldNotBegin</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The database was unable to start the transaction.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Transaction.CouldNotCommit</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The database was unable to commit the transaction.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Transaction.CouldNotRollback</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The database was unable to roll back the transaction.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.DatabaseError.Transaction.ReleaseLocksFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The transaction was unable to release one or more of its locks.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Neo.TransientError.Network.UnknownFailure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An unknown network failure occurred, a retry may resolve the issue.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section id="rest-api-service-root">
<title>Service root</title>
<section id="rest-api-get-service-root">
<title>Get service root</title>
<simpara>The service root is your starting point to discover the REST API. It
contains the basic starting points for the database, and some version and
extension information.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Get-service-root.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Get-service-root.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Get-service-root.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "node" : "http://localhost:7474/db/data/node",
  "node_index" : "http://localhost:7474/db/data/index/node",
  "relationship_index" : "http://localhost:7474/db/data/index/relationship",
  "extensions_info" : "http://localhost:7474/db/data/ext",
  "relationship_types" : "http://localhost:7474/db/data/relationship/types",
  "batch" : "http://localhost:7474/db/data/batch",
  "cypher" : "http://localhost:7474/db/data/cypher",
  "indexes" : "http://localhost:7474/db/data/schema/index",
  "constraints" : "http://localhost:7474/db/data/schema/constraint",
  "transaction" : "http://localhost:7474/db/data/transaction",
  "node_labels" : "http://localhost:7474/db/data/labels",
  "neo4j_version" : "2.0-SNAPSHOT"
}</programlisting>
</section>
</section>
<section id="rest-api-streaming">
<title>Streaming</title>
<simpara>All responses from the REST API can be transmitted as JSON streams, resulting in
better performance and lower memory overhead on the server side. To use
streaming, supply the header <literal>X-Stream: true</literal> with each request.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-streaming.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-streaming.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-streaming.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>X-Stream:</literal></emphasis> <literal>true</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8; stream=true</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "node" : "http://localhost:7474/db/data/node",
  "node_index" : "http://localhost:7474/db/data/index/node",
  "relationship_index" : "http://localhost:7474/db/data/index/relationship",
  "extensions_info" : "http://localhost:7474/db/data/ext",
  "relationship_types" : "http://localhost:7474/db/data/relationship/types",
  "batch" : "http://localhost:7474/db/data/batch",
  "cypher" : "http://localhost:7474/db/data/cypher",
  "indexes" : "http://localhost:7474/db/data/schema/index",
  "constraints" : "http://localhost:7474/db/data/schema/constraint",
  "transaction" : "http://localhost:7474/db/data/transaction",
  "node_labels" : "http://localhost:7474/db/data/labels",
  "neo4j_version" : "2.0-SNAPSHOT"
}</programlisting>
</section>
<section id="rest-api-cypher">
<title>Cypher queries via REST</title>
<simpara>The Neo4j REST API allows querying with Cypher, see <xref linkend="cypher-query-lang"/>.
The results are returned as a list of string headers (<literal>columns</literal>), and a <literal>data</literal> part,
consisting of a list of all rows, every row consisting of a list of REST representations
of the field value&#8201;&#8212;&#8201;<literal>Node</literal>, <literal>Relationship</literal>, <literal>Path</literal> or any simple value like <literal>String</literal>.</simpara>
<tip><simpara>In order to speed up queries in repeated scenarios, try not to use literals but replace them with parameters wherever possible in order to let the server cache query plans, see <xref linkend="rest-api-use-parameters"/> for details.
Also see <xref linkend="cypher-parameters"/> for where parameters can be used.</simpara></tip>
<section id="rest-api-use-parameters">
<title>Use parameters</title>
<simpara>Cypher supports queries with parameters
which are submitted as JSON.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (x { name: { startName }})-[r]-(friend)
WHERE friend.name = { name }
RETURN TYPE(r)</programlisting>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Use-parameters.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Use-parameters.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Use-parameters.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/cypher</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "query" : "MATCH (x {name: {startName}})-[r]-(friend) WHERE friend.name = {name} RETURN TYPE(r)",
  "params" : {
    "startName" : "I",
    "name" : "you"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "columns" : [ "TYPE(r)" ],
  "data" : [ [ "know" ] ]
}</programlisting>
</section>
<section id="rest-api-create-a-node">
<title>Create a node</title>
<simpara>Create a node with a label and a property using Cypher.
See the request for the parameter sent with the query.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (n:Person { name : { name }})
RETURN n</programlisting>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Create-a-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Create-a-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Create-a-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/cypher</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "query" : "CREATE (n:Person { name : {name} }) RETURN n",
  "params" : {
    "name" : "Andres"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "columns" : [ "n" ],
  "data" : [ [ {
    "labels" : "http://localhost:7474/db/data/node/47/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/47/relationships/out",
    "data" : {
      "name" : "Andres"
    },
    "traverse" : "http://localhost:7474/db/data/node/47/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/47/relationships/all/{-list|&amp;|types}",
    "property" : "http://localhost:7474/db/data/node/47/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/47",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/47/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/47/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/47/relationships/in",
    "extensions" : {
    },
    "create_relationship" : "http://localhost:7474/db/data/node/47/relationships",
    "paged_traverse" : "http://localhost:7474/db/data/node/47/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "all_relationships" : "http://localhost:7474/db/data/node/47/relationships/all",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/47/relationships/in/{-list|&amp;|types}"
  } ] ]
}</programlisting>
</section>
<section id="rest-api-create-a-node-with-multiple-properties">
<title>Create a node with multiple properties</title>
<simpara>Create a node with a label and multiple properties using Cypher.
See the request for the parameter sent with the query.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (n:Person { props })
RETURN n</programlisting>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Create-a-node-with-multiple-properties.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Create-a-node-with-multiple-properties.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Create-a-node-with-multiple-properties.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/cypher</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "query" : "CREATE (n:Person { props } ) RETURN n",
  "params" : {
    "props" : {
      "position" : "Developer",
      "name" : "Michael",
      "awesome" : true,
      "children" : 3
    }
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "columns" : [ "n" ],
  "data" : [ [ {
    "labels" : "http://localhost:7474/db/data/node/44/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/44/relationships/out",
    "data" : {
      "position" : "Developer",
      "awesome" : true,
      "name" : "Michael",
      "children" : 3
    },
    "traverse" : "http://localhost:7474/db/data/node/44/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/44/relationships/all/{-list|&amp;|types}",
    "property" : "http://localhost:7474/db/data/node/44/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/44",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/44/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/44/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/44/relationships/in",
    "extensions" : {
    },
    "create_relationship" : "http://localhost:7474/db/data/node/44/relationships",
    "paged_traverse" : "http://localhost:7474/db/data/node/44/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "all_relationships" : "http://localhost:7474/db/data/node/44/relationships/all",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/44/relationships/in/{-list|&amp;|types}"
  } ] ]
}</programlisting>
</section>
<section id="rest-api-create-mutiple-nodes-with-properties">
<title>Create mutiple nodes with properties</title>
<simpara>Create multiple nodes with properties using Cypher. See the request for
the parameter sent with the query.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (n:Person { props })
RETURN n</programlisting>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Create-mutiple-nodes-with-properties.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Create-mutiple-nodes-with-properties.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Create-mutiple-nodes-with-properties.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/cypher</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "query" : "CREATE (n:Person { props } ) RETURN n",
  "params" : {
    "props" : [ {
      "name" : "Andres",
      "position" : "Developer"
    }, {
      "name" : "Michael",
      "position" : "Developer"
    } ]
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "columns" : [ "n" ],
  "data" : [ [ {
    "labels" : "http://localhost:7474/db/data/node/48/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/48/relationships/out",
    "data" : {
      "position" : "Developer",
      "name" : "Andres"
    },
    "traverse" : "http://localhost:7474/db/data/node/48/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/48/relationships/all/{-list|&amp;|types}",
    "property" : "http://localhost:7474/db/data/node/48/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/48",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/48/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/48/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/48/relationships/in",
    "extensions" : {
    },
    "create_relationship" : "http://localhost:7474/db/data/node/48/relationships",
    "paged_traverse" : "http://localhost:7474/db/data/node/48/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "all_relationships" : "http://localhost:7474/db/data/node/48/relationships/all",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/48/relationships/in/{-list|&amp;|types}"
  } ], [ {
    "labels" : "http://localhost:7474/db/data/node/49/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/49/relationships/out",
    "data" : {
      "position" : "Developer",
      "name" : "Michael"
    },
    "traverse" : "http://localhost:7474/db/data/node/49/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/49/relationships/all/{-list|&amp;|types}",
    "property" : "http://localhost:7474/db/data/node/49/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/49",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/49/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/49/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/49/relationships/in",
    "extensions" : {
    },
    "create_relationship" : "http://localhost:7474/db/data/node/49/relationships",
    "paged_traverse" : "http://localhost:7474/db/data/node/49/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "all_relationships" : "http://localhost:7474/db/data/node/49/relationships/all",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/49/relationships/in/{-list|&amp;|types}"
  } ] ]
}</programlisting>
</section>
<section id="rest-api-set-all-properties-on-a-node-using-cypher">
<title>Set all properties on a node using Cypher</title>
<simpara>Set all properties on a node.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">CREATE (n:Person { name: 'this property is to be deleted' })
SET n = { props }
RETURN n</programlisting>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Set-all-properties-on-a-node-using-Cypher.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Set-all-properties-on-a-node-using-Cypher.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Set-all-properties-on-a-node-using-Cypher.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/cypher</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "query" : "CREATE (n:Person { name: 'this property is to be deleted' } ) SET n = { props } RETURN n",
  "params" : {
    "props" : {
      "position" : "Developer",
      "firstName" : "Michael",
      "awesome" : true,
      "children" : 3
    }
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "columns" : [ "n" ],
  "data" : [ [ {
    "labels" : "http://localhost:7474/db/data/node/75/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/75/relationships/out",
    "data" : {
      "position" : "Developer",
      "awesome" : true,
      "children" : 3,
      "firstName" : "Michael"
    },
    "traverse" : "http://localhost:7474/db/data/node/75/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/75/relationships/all/{-list|&amp;|types}",
    "property" : "http://localhost:7474/db/data/node/75/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/75",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/75/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/75/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/75/relationships/in",
    "extensions" : {
    },
    "create_relationship" : "http://localhost:7474/db/data/node/75/relationships",
    "paged_traverse" : "http://localhost:7474/db/data/node/75/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "all_relationships" : "http://localhost:7474/db/data/node/75/relationships/all",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/75/relationships/in/{-list|&amp;|types}"
  } ] ]
}</programlisting>
</section>
<section id="rest-api-send-a-query">
<title>Send a query</title>
<simpara>A simple query returning all nodes connected to some node, returning the
node and the name property, if it exists, otherwise <literal>NULL</literal>:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (x { name: 'I' })-[r]-&gt;(n)
RETURN type(r), n.name, n.age</programlisting>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Send-a-query.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Send-a-query.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Send-a-query.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/cypher</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "query" : "MATCH (x {name: 'I'})-[r]-&gt;(n) RETURN type(r), n.name, n.age",
  "params" : {
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "columns" : [ "type(r)", "n.name", "n.age" ],
  "data" : [ [ "know", "him", 25 ], [ "know", "you", null ] ]
}</programlisting>
</section>
<section id="rest-api-return-paths">
<title>Return paths</title>
<simpara>Paths can be returned just like other return types.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH path =(x { name: 'I' })--(friend)
RETURN path, friend.name</programlisting>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Return-paths.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Return-paths.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Return-paths.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/cypher</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "query" : "MATCH path = (x {name: 'I'})--(friend) RETURN path, friend.name",
  "params" : {
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "columns" : [ "path", "friend.name" ],
  "data" : [ [ {
    "start" : "http://localhost:7474/db/data/node/74",
    "nodes" : [ "http://localhost:7474/db/data/node/74", "http://localhost:7474/db/data/node/73" ],
    "length" : 1,
    "relationships" : [ "http://localhost:7474/db/data/relationship/20" ],
    "end" : "http://localhost:7474/db/data/node/73"
  }, "you" ] ]
}</programlisting>
</section>
<section id="rest-api-nested-results">
<title>Nested results</title>
<simpara>When sending queries that
return nested results like list and maps,
these will get serialized into nested JSON representations
according to their types.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n)
WHERE n.name IN ['I', 'you']
RETURN collect(n.name)</programlisting>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-nested-results.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-nested-results.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-nested-results.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/cypher</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "query" : "MATCH (n) WHERE n.name in ['I', 'you'] RETURN collect(n.name)",
  "params" : {
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "columns" : [ "collect(n.name)" ],
  "data" : [ [ [ "you", "I" ] ] ]
}</programlisting>
</section>
<section id="rest-api-retrieve-query-metadata">
<title>Retrieve query metadata</title>
<simpara>By passing in an additional GET parameter when you execute Cypher queries, metadata about the query will
be returned, such as how many labels were added or removed by the query.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (n { name: 'I' })
SET n:Actor
REMOVE n:Director
RETURN labels(n)</programlisting>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Retrieve-query-metadata.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Retrieve-query-metadata.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Retrieve-query-metadata.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/cypher?includeStats=true</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "query" : "MATCH (n {name: 'I'}) SET n:Actor REMOVE n:Director RETURN labels(n)",
  "params" : {
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "columns" : [ "labels(n)" ],
  "data" : [ [ [ "Actor" ] ] ],
  "stats" : {
    "relationships_created" : 0,
    "nodes_deleted" : 0,
    "relationship_deleted" : 0,
    "indexes_added" : 0,
    "properties_set" : 0,
    "constraints_removed" : 0,
    "indexes_removed" : 0,
    "labels_removed" : 1,
    "constraints_added" : 0,
    "labels_added" : 1,
    "nodes_created" : 0,
    "contains_updates" : true
  }
}</programlisting>
</section>
<section id="rest-api-errors">
<title>Errors</title>
<simpara>Errors on the server will be reported as a JSON-formatted message,
exception name and stacktrace.</simpara>
<programlisting language="cypher" linenumbering="unnumbered">MATCH (x { name: 'I' })
RETURN x.dummy/0</programlisting>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Errors.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Errors.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Errors.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/cypher</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "query" : "MATCH (x {name: 'I'}) RETURN x.dummy/0",
  "params" : {
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>400:</literal></emphasis> <literal>Bad Request</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "message": "/ by zero",
  "exception": "ArithmeticException",
  "fullname": "org.neo4j.cypher.ArithmeticException",
  "stacktrace": [
    "org.neo4j.cypher.internal.compiler.v2_0.commands.expressions.Divide.apply(Divide.scala:36)",
    "org.neo4j.cypher.internal.compiler.v2_0.pipes.ExtractPipe$$anonfun$3$$anonfun$apply$2.apply(ExtractPipe.scala:63)",
    "org.neo4j.cypher.internal.compiler.v2_0.pipes.ExtractPipe$$anonfun$3$$anonfun$apply$2.apply(ExtractPipe.scala:61)",
    "scala.collection.immutable.Map$Map1.foreach(Map.scala:109)",
    "org.neo4j.cypher.internal.compiler.v2_0.pipes.ExtractPipe$$anonfun$3.apply(ExtractPipe.scala:61)",
    "org.neo4j.cypher.internal.compiler.v2_0.pipes.ExtractPipe$$anonfun$3.apply(ExtractPipe.scala:60)",
    "org.neo4j.cypher.internal.compiler.v2_0.pipes.ExtractPipe$$anonfun$internalCreateResults$1.apply(ExtractPipe.scala:83)",
    "org.neo4j.cypher.internal.compiler.v2_0.pipes.ExtractPipe$$anonfun$internalCreateResults$1.apply(ExtractPipe.scala:83)",
    "scala.collection.Iterator$$anon$11.next(Iterator.scala:328)",
    "scala.collection.Iterator$$anon$11.next(Iterator.scala:328)",
    "org.neo4j.cypher.internal.compiler.v2_0.ClosingIterator$$anonfun$next$1.apply(ClosingIterator.scala:46)",
    "org.neo4j.cypher.internal.compiler.v2_0.ClosingIterator$$anonfun$next$1.apply(ClosingIterator.scala:45)",
    "org.neo4j.cypher.internal.compiler.v2_0.ClosingIterator.failIfThrows(ClosingIterator.scala:91)",
    "org.neo4j.cypher.internal.compiler.v2_0.ClosingIterator.next(ClosingIterator.scala:45)",
    "org.neo4j.cypher.internal.compiler.v2_0.PipeExecutionResult.next(PipeExecutionResult.scala:168)",
    "org.neo4j.cypher.internal.compiler.v2_0.PipeExecutionResult.next(PipeExecutionResult.scala:34)",
    "scala.collection.Iterator$$anon$11.next(Iterator.scala:328)",
    "scala.collection.convert.Wrappers$IteratorWrapper.next(Wrappers.scala:30)",
    "org.neo4j.cypher.internal.compiler.v2_0.PipeExecutionResult$$anon$1.next(PipeExecutionResult.scala:76)",
    "org.neo4j.helpers.collection.ExceptionHandlingIterable$1.next(ExceptionHandlingIterable.java:53)",
    "org.neo4j.helpers.collection.IteratorWrapper.next(IteratorWrapper.java:47)",
    "org.neo4j.server.rest.repr.ListRepresentation.serialize(ListRepresentation.java:64)",
    "org.neo4j.server.rest.repr.Serializer.serialize(Serializer.java:75)",
    "org.neo4j.server.rest.repr.MappingSerializer.putList(MappingSerializer.java:61)",
    "org.neo4j.server.rest.repr.CypherResultRepresentation.serialize(CypherResultRepresentation.java:83)",
    "org.neo4j.server.rest.repr.MappingRepresentation.serialize(MappingRepresentation.java:41)",
    "org.neo4j.server.rest.repr.OutputFormat.assemble(OutputFormat.java:215)",
    "org.neo4j.server.rest.repr.OutputFormat.formatRepresentation(OutputFormat.java:147)",
    "org.neo4j.server.rest.repr.OutputFormat.response(OutputFormat.java:130)",
    "org.neo4j.server.rest.repr.OutputFormat.ok(OutputFormat.java:67)",
    "org.neo4j.server.rest.web.CypherService.cypher(CypherService.java:101)",
    "java.lang.reflect.Method.invoke(Method.java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:139)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112)",
    "java.lang.Thread.run(Thread.java:724)"
  ]
}</programlisting>
</section>
</section>
<section id="rest-api-property-values">
<title>Property values</title>
<simpara>The REST API allows setting properties on nodes and relationships through direct RESTful operations.
However, there are restrictions as to what types of values can be used as property values.
Allowed value types are as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>
Numbers: Both integer values, with capacity as Java&#8217;s Long type, and floating points, with capacity as Java&#8217;s Double.
</simpara>
</listitem>
<listitem>
<simpara>
Booleans.
</simpara>
</listitem>
<listitem>
<simpara>
Strings.
</simpara>
</listitem>
<listitem>
<simpara>
Arrays of the basic types above.
</simpara>
</listitem>
</itemizedlist>
<section id="_arrays">
<title>Arrays</title>
<simpara>There are two important points to be made about array values.
First, all values in the array must be of the same type.
That means either all integers, all floats, all booleans or all strings.
Mixing types is not currently supported.</simpara>
<simpara>Second, storing empty arrays is only possible given certain preconditions.
Because the JSON transfer format does not contain type information for arrays, type is inferred from the values in the array.
If the array is empty, the Neo4j Server cannot determine the type.
In these cases, it will check if an array is already stored for the given property, and will use the stored array&#8217;s type when storing the empty array.
If no array exists already, the server will reject the request.</simpara>
</section>
<section id="_property_keys">
<title>Property keys</title>
<simpara>You can list all property keys ever used in the database. This includes and property keys you have used, but deleted.</simpara>
<simpara>There is currently no way to tell which ones are in use and which ones are not, short of walking the entire set of properties in the database.</simpara>
</section>
<section id="rest-api-list-all-property-keys">
<title>List all property keys</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/propertykeys</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ "awesome", "name1", "since", "kvkey2", "array1", "name2", "key", "kvkey1", "age", "value", "foo", "some-key", "prop", "例子öäüÖÄÜß", "non-existent", "firstName", "ID", "Name", "children", "cost", "position", "array2", "names", "happy", "array", "sequence", "name", "a" ]</programlisting>
</section>
</section>
<section id="rest-api-nodes">
<title>Nodes</title>
<section id="rest-api-create-node">
<title>Create node</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-create-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-create-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-create-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/node/8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "paged_traverse" : "http://localhost:7474/db/data/node/8/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "labels" : "http://localhost:7474/db/data/node/8/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/8/relationships/out",
  "traverse" : "http://localhost:7474/db/data/node/8/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/8/relationships/all/{-list|&amp;|types}",
  "all_relationships" : "http://localhost:7474/db/data/node/8/relationships/all",
  "property" : "http://localhost:7474/db/data/node/8/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/8",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/8/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/8/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/8/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/8/relationships/in/{-list|&amp;|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/8/relationships",
  "data" : {
  }
}</programlisting>
</section>
<section id="rest-api-create-node-with-properties">
<title>Create node with properties</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-create-node-with-properties.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-create-node-with-properties.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-create-node-with-properties.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "foo" : "bar"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Length:</literal></emphasis> <literal>1156</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/node/4</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "paged_traverse" : "http://localhost:7474/db/data/node/4/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "labels" : "http://localhost:7474/db/data/node/4/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/4/relationships/out",
  "traverse" : "http://localhost:7474/db/data/node/4/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/4/relationships/all/{-list|&amp;|types}",
  "all_relationships" : "http://localhost:7474/db/data/node/4/relationships/all",
  "property" : "http://localhost:7474/db/data/node/4/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/4",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/4/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/4/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/4/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/4/relationships/in/{-list|&amp;|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/4/relationships",
  "data" : {
    "foo" : "bar"
  }
}</programlisting>
</section>
<section id="rest-api-get-node">
<title>Get node</title>
<simpara>Note that the response contains URI/templates for the available
operations for getting properties and relationships.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Get-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Get-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Get-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/node/30</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "paged_traverse" : "http://localhost:7474/db/data/node/30/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "labels" : "http://localhost:7474/db/data/node/30/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/30/relationships/out",
  "traverse" : "http://localhost:7474/db/data/node/30/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/30/relationships/all/{-list|&amp;|types}",
  "all_relationships" : "http://localhost:7474/db/data/node/30/relationships/all",
  "property" : "http://localhost:7474/db/data/node/30/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/30",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/30/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/30/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/30/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/30/relationships/in/{-list|&amp;|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/30/relationships",
  "data" : {
  }
}</programlisting>
</section>
<section id="rest-api-get-non-existent-node">
<title>Get non-existent node</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Get-non-existent-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Get-non-existent-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Get-non-existent-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/node/3400000</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>404:</literal></emphasis> <literal>Not Found</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "message": "Cannot find node with id [3400000] in database.",
  "exception": "NodeNotFoundException",
  "fullname": "org.neo4j.server.rest.web.NodeNotFoundException",
  "stacktrace": [
    "org.neo4j.server.rest.web.DatabaseActions.node(DatabaseActions.java:183)",
    "org.neo4j.server.rest.web.DatabaseActions.getNode(DatabaseActions.java:228)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.getNode(RestfulGraphDatabase.java:265)",
    "java.lang.reflect.Method.invoke(Method.java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:139)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112)",
    "java.lang.Thread.run(Thread.java:724)"
  ]
}</programlisting>
</section>
<section id="rest-api-delete-node">
<title>Delete node</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Delete-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Delete-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Delete-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/node/5</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-nodes-with-relationships-cannot-be-deleted">
<title>Nodes with relationships cannot be deleted</title>
<simpara>The relationships on a node has to be deleted before the node can be
deleted.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Nodes-with-relationships-cannot-be-deleted.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Nodes-with-relationships-cannot-be-deleted.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Nodes-with-relationships-cannot-be-deleted.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/node/12</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>409:</literal></emphasis> <literal>Conflict</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "message": "The node with id 12 cannot be deleted. Check that the node is orphaned before deletion.",
  "exception": "OperationFailureException",
  "fullname": "org.neo4j.server.rest.web.OperationFailureException",
  "stacktrace": [
    "org.neo4j.server.rest.web.DatabaseActions.deleteNode(DatabaseActions.java:237)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.deleteNode(RestfulGraphDatabase.java:279)",
    "java.lang.reflect.Method.invoke(Method.java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:139)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112)",
    "java.lang.Thread.run(Thread.java:724)"
  ]
}</programlisting>
</section>
</section>
<section id="rest-api-relationships">
<title>Relationships</title>
<simpara>Relationships are a first class citizen in the Neo4j REST API. They can be accessed either
stand-alone or through the nodes they are attached to.</simpara>
<simpara>The general pattern to get relationships from a node is:</simpara>
<programlisting language="plain" linenumbering="unnumbered">GET http://localhost:7474/db/data/node/123/relationships/{dir}/{-list|&amp;|types}</programlisting>
<simpara>Where <literal>dir</literal> is one of <literal>all</literal>, <literal>in</literal>, <literal>out</literal> and <literal>types</literal> is an ampersand-separated list of types.
See the examples below for more information.</simpara>
<section id="rest-api-get-relationship-by-id">
<title>Get Relationship by ID</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-get-Relationship-by-ID.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-get-Relationship-by-ID.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-get-Relationship-by-ID.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/30</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "start" : "http://localhost:7474/db/data/node/138",
  "property" : "http://localhost:7474/db/data/relationship/30/properties/{key}",
  "self" : "http://localhost:7474/db/data/relationship/30",
  "properties" : "http://localhost:7474/db/data/relationship/30/properties",
  "type" : "know",
  "end" : "http://localhost:7474/db/data/node/137",
  "data" : {
  }
}</programlisting>
</section>
<section id="rest-api-create-relationship">
<title>Create relationship</title>
<simpara>Upon successful creation of a relationship, the new relationship is
returned.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Create-relationship.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Create-relationship.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Create-relationship.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/1/relationships</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "to" : "http://localhost:7474/db/data/node/0",
  "type" : "LOVES"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/relationship/1</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "start" : "http://localhost:7474/db/data/node/1",
  "property" : "http://localhost:7474/db/data/relationship/1/properties/{key}",
  "self" : "http://localhost:7474/db/data/relationship/1",
  "properties" : "http://localhost:7474/db/data/relationship/1/properties",
  "type" : "LOVES",
  "end" : "http://localhost:7474/db/data/node/0",
  "data" : {
  }
}</programlisting>
</section>
<section id="rest-api-create-a-relationship-with-properties">
<title>Create a relationship with properties</title>
<simpara>Upon successful creation of a relationship, the new relationship is
returned.</simpara>
<figure><title>Starting Graph</title>
<ulink url="images/Starting-Graph-Add-relationship-with-properties-before.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Starting-Graph-Add-relationship-with-properties-before.svg"/>
  </imageobject>
  <textobject><phrase>Starting-Graph-Add-relationship-with-properties-before.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Create-a-relationship-with-properties.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Create-a-relationship-with-properties.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Create-a-relationship-with-properties.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/11/relationships</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "to" : "http://localhost:7474/db/data/node/10",
  "type" : "LOVES",
  "data" : {
    "foo" : "bar"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/relationship/8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "start" : "http://localhost:7474/db/data/node/11",
  "property" : "http://localhost:7474/db/data/relationship/8/properties/{key}",
  "self" : "http://localhost:7474/db/data/relationship/8",
  "properties" : "http://localhost:7474/db/data/relationship/8/properties",
  "type" : "LOVES",
  "end" : "http://localhost:7474/db/data/node/10",
  "data" : {
    "foo" : "bar"
  }
}</programlisting>
</section>
<section id="rest-api-delete-relationship">
<title>Delete relationship</title>
<figure><title>Starting Graph</title>
<ulink url="images/Starting-Graph-Delete-relationship1.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Starting-Graph-Delete-relationship1.svg"/>
  </imageobject>
  <textobject><phrase>Starting-Graph-Delete-relationship1.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Delete-relationship.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Delete-relationship.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Delete-relationship.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/23</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-get-all-properties-on-a-relationship">
<title>Get all properties on a relationship</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-get-all-properties-on-a-relationship.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-get-all-properties-on-a-relationship.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-get-all-properties-on-a-relationship.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/26/properties</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "cost" : "high",
  "since" : "1day"
}</programlisting>
</section>
<section id="rest-api-set-all-properties-on-a-relationship">
<title>Set all properties on a relationship</title>
<figure><title>Starting Graph</title>
<ulink url="images/Starting-Graph-Set-relationship-property1.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Starting-Graph-Set-relationship-property1.svg"/>
  </imageobject>
  <textobject><phrase>Starting-Graph-Set-relationship-property1.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-set-all-properties-on-a-relationship.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-set-all-properties-on-a-relationship.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-set-all-properties-on-a-relationship.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>PUT</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/31/properties</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "happy" : false
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-get-single-property-on-a-relationship">
<title>Get single property on a relationship</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-get-single-property-on-a-relationship.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-get-single-property-on-a-relationship.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-get-single-property-on-a-relationship.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/27/properties/cost</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">"high"</programlisting>
</section>
<section id="rest-api-set-single-property-on-a-relationship">
<title>Set single property on a relationship</title>
<figure><title>Starting Graph</title>
<ulink url="images/Starting-Graph-Set-relationship-property1.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Starting-Graph-Set-relationship-property1.svg"/>
  </imageobject>
  <textobject><phrase>Starting-Graph-Set-relationship-property1.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-set-single-property-on-a-relationship.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-set-single-property-on-a-relationship.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-set-single-property-on-a-relationship.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>PUT</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/25/properties/cost</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">"deadly"</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-get-all-relationships">
<title>Get all relationships</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Get-all-relationships.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Get-all-relationships.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Get-all-relationships.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/node/298/relationships/all</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "start" : "http://localhost:7474/db/data/node/298",
  "data" : {
  },
  "self" : "http://localhost:7474/db/data/relationship/204",
  "property" : "http://localhost:7474/db/data/relationship/204/properties/{key}",
  "properties" : "http://localhost:7474/db/data/relationship/204/properties",
  "type" : "LIKES",
  "extensions" : {
  },
  "end" : "http://localhost:7474/db/data/node/299"
}, {
  "start" : "http://localhost:7474/db/data/node/300",
  "data" : {
  },
  "self" : "http://localhost:7474/db/data/relationship/205",
  "property" : "http://localhost:7474/db/data/relationship/205/properties/{key}",
  "properties" : "http://localhost:7474/db/data/relationship/205/properties",
  "type" : "LIKES",
  "extensions" : {
  },
  "end" : "http://localhost:7474/db/data/node/298"
}, {
  "start" : "http://localhost:7474/db/data/node/298",
  "data" : {
  },
  "self" : "http://localhost:7474/db/data/relationship/206",
  "property" : "http://localhost:7474/db/data/relationship/206/properties/{key}",
  "properties" : "http://localhost:7474/db/data/relationship/206/properties",
  "type" : "HATES",
  "extensions" : {
  },
  "end" : "http://localhost:7474/db/data/node/301"
} ]</programlisting>
</section>
<section id="rest-api-get-incoming-relationships">
<title>Get incoming relationships</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Get-incoming-relationships.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Get-incoming-relationships.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Get-incoming-relationships.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/node/317/relationships/in</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "start" : "http://localhost:7474/db/data/node/319",
  "data" : {
  },
  "self" : "http://localhost:7474/db/data/relationship/216",
  "property" : "http://localhost:7474/db/data/relationship/216/properties/{key}",
  "properties" : "http://localhost:7474/db/data/relationship/216/properties",
  "type" : "LIKES",
  "extensions" : {
  },
  "end" : "http://localhost:7474/db/data/node/317"
} ]</programlisting>
</section>
<section id="rest-api-get-outgoing-relationships">
<title>Get outgoing relationships</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Get-outgoing-relationships.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Get-outgoing-relationships.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Get-outgoing-relationships.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/node/342/relationships/out</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "start" : "http://localhost:7474/db/data/node/342",
  "data" : {
  },
  "self" : "http://localhost:7474/db/data/relationship/230",
  "property" : "http://localhost:7474/db/data/relationship/230/properties/{key}",
  "properties" : "http://localhost:7474/db/data/relationship/230/properties",
  "type" : "LIKES",
  "extensions" : {
  },
  "end" : "http://localhost:7474/db/data/node/343"
}, {
  "start" : "http://localhost:7474/db/data/node/342",
  "data" : {
  },
  "self" : "http://localhost:7474/db/data/relationship/232",
  "property" : "http://localhost:7474/db/data/relationship/232/properties/{key}",
  "properties" : "http://localhost:7474/db/data/relationship/232/properties",
  "type" : "HATES",
  "extensions" : {
  },
  "end" : "http://localhost:7474/db/data/node/345"
} ]</programlisting>
</section>
<section id="rest-api-get-typed-relationships">
<title>Get typed relationships</title>
<simpara>Note that the "<literal>&amp;</literal>" needs to be encoded like "<literal>%26</literal>" for example when
using <ulink url="http://curl.haxx.se/">cURL</ulink> from the terminal.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Get-typed-relationships.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Get-typed-relationships.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Get-typed-relationships.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/node/273/relationships/all/LIKES&amp;HATES</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "start" : "http://localhost:7474/db/data/node/273",
  "data" : {
  },
  "self" : "http://localhost:7474/db/data/relationship/189",
  "property" : "http://localhost:7474/db/data/relationship/189/properties/{key}",
  "properties" : "http://localhost:7474/db/data/relationship/189/properties",
  "type" : "LIKES",
  "extensions" : {
  },
  "end" : "http://localhost:7474/db/data/node/274"
}, {
  "start" : "http://localhost:7474/db/data/node/275",
  "data" : {
  },
  "self" : "http://localhost:7474/db/data/relationship/190",
  "property" : "http://localhost:7474/db/data/relationship/190/properties/{key}",
  "properties" : "http://localhost:7474/db/data/relationship/190/properties",
  "type" : "LIKES",
  "extensions" : {
  },
  "end" : "http://localhost:7474/db/data/node/273"
}, {
  "start" : "http://localhost:7474/db/data/node/273",
  "data" : {
  },
  "self" : "http://localhost:7474/db/data/relationship/191",
  "property" : "http://localhost:7474/db/data/relationship/191/properties/{key}",
  "properties" : "http://localhost:7474/db/data/relationship/191/properties",
  "type" : "HATES",
  "extensions" : {
  },
  "end" : "http://localhost:7474/db/data/node/276"
} ]</programlisting>
</section>
<section id="rest-api-get-relationships-on-a-node-without-relationships">
<title>Get relationships on a node without relationships</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Get-relationships-on-a-node-without-relationships.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Get-relationships-on-a-node-without-relationships.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Get-relationships-on-a-node-without-relationships.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/node/331/relationships/all</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ ]</programlisting>
</section>
</section>
<section id="rest-api-relationship-types">
<title>Relationship types</title>
<section id="rest-api-get-relationship-types">
<title>Get relationship types</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/types</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ "know", "KNOWS", "LOVES" ]</programlisting>
</section>
</section>
<section id="rest-api-node-properties">
<title>Node properties</title>
<section id="rest-api-set-property-on-node">
<title>Set property on node</title>
<simpara>Setting different properties will retain the existing ones for this node.
Note that a single value are submitted not as a map but just as a value
(which is valid JSON) like in the example
below.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Set-property-on-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Set-property-on-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Set-property-on-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>PUT</literal></emphasis>  <literal>http://localhost:7474/db/data/node/11/properties/foo</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">"bar"</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-update-node-properties">
<title>Update node properties</title>
<simpara>This will replace all existing properties on the node with the new set
of attributes.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Update-node-properties.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Update-node-properties.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Update-node-properties.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>PUT</literal></emphasis>  <literal>http://localhost:7474/db/data/node/9/properties</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "age" : "18"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-get-properties-for-node">
<title>Get properties for node</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Get-properties-for-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Get-properties-for-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Get-properties-for-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/node/36/properties</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "foo" : "bar"
}</programlisting>
</section>
<section id="rest-api-property-values-can-not-be-null">
<title>Property values can not be null</title>
<simpara>This example shows the response you get when trying to set a property to
<literal>null</literal>.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "foo" : null
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>400:</literal></emphasis> <literal>Bad Request</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "message": "Could not set property \"foo\", unsupported type: null",
  "exception": "PropertyValueException",
  "fullname": "org.neo4j.server.rest.web.PropertyValueException",
  "stacktrace": [
    "org.neo4j.server.rest.domain.PropertySettingStrategy.setProperty(PropertySettingStrategy.java:141)",
    "org.neo4j.server.rest.domain.PropertySettingStrategy.setProperties(PropertySettingStrategy.java:88)",
    "org.neo4j.server.rest.web.DatabaseActions.createNode(DatabaseActions.java:214)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.createNode(RestfulGraphDatabase.java:238)",
    "java.lang.reflect.Method.invoke(Method.java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:139)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112)",
    "java.lang.Thread.run(Thread.java:724)"
  ]
}</programlisting>
</section>
<section id="rest-api-property-values-can-not-be-nested">
<title>Property values can not be nested</title>
<simpara>Nesting properties is not supported. You could for example store the
nested JSON as a string instead.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "foo" : {
    "bar" : "baz"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>400:</literal></emphasis> <literal>Bad Request</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "message": "Could not set property \"foo\", unsupported type: {bar\u003dbaz}",
  "exception": "PropertyValueException",
  "fullname": "org.neo4j.server.rest.web.PropertyValueException",
  "stacktrace": [
    "org.neo4j.server.rest.domain.PropertySettingStrategy.setProperty(PropertySettingStrategy.java:141)",
    "org.neo4j.server.rest.domain.PropertySettingStrategy.setProperties(PropertySettingStrategy.java:88)",
    "org.neo4j.server.rest.web.DatabaseActions.createNode(DatabaseActions.java:214)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.createNode(RestfulGraphDatabase.java:238)",
    "java.lang.reflect.Method.invoke(Method.java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:139)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112)",
    "java.lang.Thread.run(Thread.java:724)"
  ]
}</programlisting>
</section>
<section id="rest-api-delete-all-properties-from-node">
<title>Delete all properties from node</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Delete-all-properties-from-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Delete-all-properties-from-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Delete-all-properties-from-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/node/250/properties</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-delete-a-named-property-from-a-node">
<title>Delete a named property from a node</title>
<simpara>To delete a single property
from a node, see the example below.</simpara>
<figure><title>Starting Graph</title>
<ulink url="images/Starting-Graph-delete-named-property-start.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Starting-Graph-delete-named-property-start.svg"/>
  </imageobject>
  <textobject><phrase>Starting-Graph-delete-named-property-start.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-delete-a-named-property-from-a-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-delete-a-named-property-from-a-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-delete-a-named-property-from-a-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/node/249/properties/name</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
</section>
<section id="rest-api-relationship-properties">
<title>Relationship properties</title>
<section id="rest-api-update-relationship-properties">
<title>Update relationship properties</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Update-relationship-properties.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Update-relationship-properties.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Update-relationship-properties.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>PUT</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/9/properties</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "jim" : "tobias"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-remove-properties-from-a-relationship">
<title>Remove properties from a relationship</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Remove-properties-from-a-relationship.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Remove-properties-from-a-relationship.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Remove-properties-from-a-relationship.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/21/properties</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-remove-property-from-a-relationship">
<title>Remove property from a relationship</title>
<simpara>See the example request below.</simpara>
<figure><title>Starting Graph</title>
<ulink url="images/Starting-Graph-Remove-property-from-a-relationship1.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Starting-Graph-Remove-property-from-a-relationship1.svg"/>
  </imageobject>
  <textobject><phrase>Starting-Graph-Remove-property-from-a-relationship1.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Remove-property-from-a-relationship.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Remove-property-from-a-relationship.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Remove-property-from-a-relationship.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/24/properties/cost</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-remove-non-existent-property-from-a-relationship">
<title>Remove non-existent property from a relationship</title>
<simpara>Attempting to remove a property that doesn&#8217;t exist results in
an error.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Remove-non-existent-property-from-a-relationship.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Remove-non-existent-property-from-a-relationship.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Remove-non-existent-property-from-a-relationship.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/22/properties/non-existent</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>404:</literal></emphasis> <literal>Not Found</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "message": "Relationship[22] does not have a property \"non-existent\"",
  "exception": "NoSuchPropertyException",
  "fullname": "org.neo4j.server.rest.web.NoSuchPropertyException",
  "stacktrace": [
    "org.neo4j.server.rest.web.DatabaseActions.removeRelationshipProperty(DatabaseActions.java:657)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.deleteRelationshipProperty(RestfulGraphDatabase.java:797)",
    "java.lang.reflect.Method.invoke(Method.java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:139)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112)",
    "java.lang.Thread.run(Thread.java:724)"
  ]
}</programlisting>
</section>
<section id="rest-api-remove-properties-from-a-non-existing-relationship">
<title>Remove properties from a non-existing relationship</title>
<simpara>Attempting to remove all properties from a relationship which doesn&#8217;t
exist results in an error.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Remove-properties-from-a-non-existing-relationship.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Remove-properties-from-a-non-existing-relationship.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Remove-properties-from-a-non-existing-relationship.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/1234/properties</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>404:</literal></emphasis> <literal>Not Found</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "exception": "RelationshipNotFoundException",
  "fullname": "org.neo4j.server.rest.web.RelationshipNotFoundException",
  "stacktrace": [
    "org.neo4j.server.rest.web.DatabaseActions.relationship(DatabaseActions.java:197)",
    "org.neo4j.server.rest.web.DatabaseActions.removeAllRelationshipProperties(DatabaseActions.java:647)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.deleteAllRelationshipProperties(RestfulGraphDatabase.java:776)",
    "java.lang.reflect.Method.invoke(Method.java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:139)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112)",
    "java.lang.Thread.run(Thread.java:724)"
  ]
}</programlisting>
</section>
<section id="rest-api-remove-property-from-a-non-existing-relationship">
<title>Remove property from a non-existing relationship</title>
<simpara>Attempting to remove a property from a relationship which doesn&#8217;t exist
results in an error.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Remove-property-from-a-non-existing-relationship.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Remove-property-from-a-non-existing-relationship.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Remove-property-from-a-non-existing-relationship.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/relationship/1234/properties/cost</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>404:</literal></emphasis> <literal>Not Found</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "exception": "RelationshipNotFoundException",
  "fullname": "org.neo4j.server.rest.web.RelationshipNotFoundException",
  "stacktrace": [
    "org.neo4j.server.rest.web.DatabaseActions.relationship(DatabaseActions.java:197)",
    "org.neo4j.server.rest.web.DatabaseActions.removeRelationshipProperty(DatabaseActions.java:653)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.deleteRelationshipProperty(RestfulGraphDatabase.java:797)",
    "java.lang.reflect.Method.invoke(Method.java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:139)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112)",
    "java.lang.Thread.run(Thread.java:724)"
  ]
}</programlisting>
</section>
</section>
<section id="rest-api-node-labels">
<title>Node labels</title>
<section id="rest-api-adding-a-label-to-a-node">
<title>Adding a label to a node</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Adding-a-label-to-a-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Adding-a-label-to-a-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Adding-a-label-to-a-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/100/labels</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">"Person"</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-adding-multiple-labels-to-a-node">
<title>Adding multiple labels to a node</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Adding-multiple-labels-to-a-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Adding-multiple-labels-to-a-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Adding-multiple-labels-to-a-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/111/labels</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ "Person", "Actor" ]</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-adding-a-label-with-an-invalid-name">
<title>Adding a label with an invalid name</title>
<simpara>Labels with empty names are not allowed, however, all other valid strings are accepted as label names.
Adding an invalid label to a node will lead to a HTTP 400 response.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Adding-a-label-with-an-invalid-name.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Adding-a-label-with-an-invalid-name.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Adding-a-label-with-an-invalid-name.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/118/labels</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">""</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>400:</literal></emphasis> <literal>Bad Request</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "message": "Unable to add label, see nested exception.",
  "exception": "BadInputException",
  "fullname": "org.neo4j.server.rest.repr.BadInputException",
  "stacktrace": [
    "org.neo4j.server.rest.web.DatabaseActions.addLabelToNode(DatabaseActions.java:328)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.addNodeLabel(RestfulGraphDatabase.java:447)",
    "java.lang.reflect.Method.invoke(Method.java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:139)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112)",
    "java.lang.Thread.run(Thread.java:724)"
  ],
  "cause": {
    "message": "Invalid label name \u0027\u0027.",
    "cause": {
      "message": "\u0027\u0027 is not a valid token name. Only non-null, non-empty strings are allowed.",
      "exception": "IllegalTokenNameException",
      "stacktrace": [
        "org.neo4j.kernel.impl.api.DataIntegrityValidatingStatementOperations.checkValidTokenName(DataIntegrityValidatingStatementOperations.java:171)",
        "org.neo4j.kernel.impl.api.DataIntegrityValidatingStatementOperations.labelGetOrCreateForName(DataIntegrityValidatingStatementOperations.java:82)",
        "org.neo4j.kernel.impl.api.OperationsFacade.labelGetOrCreateForName(OperationsFacade.java:390)",
        "org.neo4j.kernel.impl.core.NodeProxy.addLabel(NodeProxy.java:472)",
        "org.neo4j.server.rest.web.DatabaseActions.addLabelToNode(DatabaseActions.java:323)",
        "org.neo4j.server.rest.web.RestfulGraphDatabase.addNodeLabel(RestfulGraphDatabase.java:447)",
        "java.lang.reflect.Method.invoke(Method.java:606)",
        "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:139)",
        "org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112)",
        "java.lang.Thread.run(Thread.java:724)"
      ],
      "fullname": "org.neo4j.kernel.api.exceptions.schema.IllegalTokenNameException"
    },
    "exception": "ConstraintViolationException",
    "stacktrace": [
      "org.neo4j.kernel.impl.core.NodeProxy.addLabel(NodeProxy.java:481)",
      "org.neo4j.server.rest.web.DatabaseActions.addLabelToNode(DatabaseActions.java:323)",
      "org.neo4j.server.rest.web.RestfulGraphDatabase.addNodeLabel(RestfulGraphDatabase.java:447)",
      "java.lang.reflect.Method.invoke(Method.java:606)",
      "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:139)",
      "org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112)",
      "java.lang.Thread.run(Thread.java:724)"
    ],
    "fullname": "org.neo4j.graphdb.ConstraintViolationException"
  }
}</programlisting>
</section>
<section id="rest-api-replacing-labels-on-a-node">
<title>Replacing labels on a node</title>
<simpara>This removes any labels currently on a node, and replaces them with the labels passed in as the
request body.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Replacing-labels-on-a-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Replacing-labels-on-a-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Replacing-labels-on-a-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>PUT</literal></emphasis>  <literal>http://localhost:7474/db/data/node/101/labels</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ "Actor", "Director" ]</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-removing-a-label-from-a-node">
<title>Removing a label from a node</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Removing-a-label-from-a-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Removing-a-label-from-a-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Removing-a-label-from-a-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/node/102/labels/Person</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-listing-labels-for-a-node">
<title>Listing labels for a node</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Listing-labels-for-a-node.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Listing-labels-for-a-node.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Listing-labels-for-a-node.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/node/107/labels</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ "Director", "Actor" ]</programlisting>
</section>
<section id="rest-api-get-all-nodes-with-a-label">
<title>Get all nodes with a label</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Get-all-nodes-with-a-label.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Get-all-nodes-with-a-label.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Get-all-nodes-with-a-label.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/label/Actor/nodes</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "labels" : "http://localhost:7474/db/data/node/113/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/113/relationships/out",
  "data" : {
    "name" : "Clint Eastwood"
  },
  "traverse" : "http://localhost:7474/db/data/node/113/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/113/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/113/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/113",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/113/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/113/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/113/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/113/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/113/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/113/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/113/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/114/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/114/relationships/out",
  "data" : {
    "name" : "Donald Sutherland"
  },
  "traverse" : "http://localhost:7474/db/data/node/114/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/114/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/114/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/114",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/114/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/114/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/114/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/114/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/114/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/114/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/114/relationships/in/{-list|&amp;|types}"
} ]</programlisting>
</section>
<section id="rest-api-get-nodes-by-label-and-property">
<title>Get nodes by label and property</title>
<simpara>You can retrieve all nodes with a given label and property by passing one property as a query parameter.
Notice that the property value is JSON-encoded and then URL-encoded.</simpara>
<simpara>If there is an index available on the label/property combination you send, that index will be used. If no
index is available, all nodes with the given label will be filtered through to find matching nodes.</simpara>
<simpara>Currently, it is not possible to search using multiple properties.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Get-nodes-by-label-and-property.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Get-nodes-by-label-and-property.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Get-nodes-by-label-and-property.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/label/Person/nodes?name=%22Clint+Eastwood%22</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "labels" : "http://localhost:7474/db/data/node/116/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/116/relationships/out",
  "data" : {
    "name" : "Clint Eastwood"
  },
  "traverse" : "http://localhost:7474/db/data/node/116/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/116/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/116/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/116",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/116/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/116/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/116/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/116/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/116/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/116/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/116/relationships/in/{-list|&amp;|types}"
} ]</programlisting>
</section>
<section id="rest-api-list-all-labels">
<title>List all labels</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-List-all-labels.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-List-all-labels.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-List-all-labels.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/labels</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ "mylabel", "Person", "Actor", "Director", "novice", "chef", "expert", "person", "user", "prog", "SomeLabel", "coder" ]</programlisting>
</section>
</section>
<section id="rest-api-schema-indexes">
<title>Indexing</title>
<note><simpara>This documents schema based indexes, a feature that was introduced in Neo4j 2.0, see <xref linkend="rest-api-indexes"/> for legacy indexing.</simpara></note>
<simpara>For more details about indexes and the optional schema in Neo4j, see <xref linkend="graphdb-neo4j-schema"/>.</simpara>
<section id="rest-api-create-index">
<title>Create index</title>
<simpara>This will start a background job in the database that will create and populate the index.
You can check the status of your index by listing all the indexes for the relevant label.
The created index will show up, but have a state of <literal>POPULATING</literal> until the index is ready,
where it is marked as <literal>ONLINE</literal>.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/schema/index/person</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "property_keys" : [ "name" ]
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "label" : "person",
  "property_keys" : [ "name" ]
}</programlisting>
</section>
<section id="rest-api-list-indexes-for-a-label">
<title>List indexes for a label</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/schema/index/user</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "property_keys" : [ "name" ],
  "label" : "user"
} ]</programlisting>
</section>
<section id="rest-api-drop-index">
<title>Drop index</title>
<simpara>Drop index</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/schema/index/SomeLabel/name</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
</section>
<section id="rest-api-schema-constraints">
<title>Constraints</title>
<section id="rest-api-create-uniqueness-constraint">
<title>Create uniqueness constraint</title>
<simpara>Create a uniqueness constraint on a property.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/schema/constraint/Person/uniqueness/</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "property_keys" : [ "name" ]
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "label" : "Person",
  "type" : "UNIQUENESS",
  "property_keys" : [ "name" ]
}</programlisting>
</section>
<section id="rest-api-get-a-specific-uniqueness-constraint">
<title>Get a specific uniqueness constraint</title>
<simpara>Get a specific uniqueness constraint for a label and a property.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/schema/constraint/User/uniqueness/name</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "property_keys" : [ "name" ],
  "label" : "User",
  "type" : "UNIQUENESS"
} ]</programlisting>
</section>
<section id="rest-api-get-all-uniqueness-constraints-for-a-label">
<title>Get all uniqueness constraints for a label</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/schema/constraint/User/uniqueness/</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "property_keys" : [ "name2" ],
  "label" : "User",
  "type" : "UNIQUENESS"
}, {
  "property_keys" : [ "name1" ],
  "label" : "User",
  "type" : "UNIQUENESS"
} ]</programlisting>
</section>
<section id="rest-api-get-all-constraints-for-a-label">
<title>Get all constraints for a label</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/schema/constraint/User</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "property_keys" : [ "name2" ],
  "label" : "User",
  "type" : "UNIQUENESS"
}, {
  "property_keys" : [ "name1" ],
  "label" : "User",
  "type" : "UNIQUENESS"
} ]</programlisting>
</section>
<section id="rest-api-get-all-constraints">
<title>Get all constraints</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/schema/constraint</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "property_keys" : [ "name2" ],
  "label" : "Prog",
  "type" : "UNIQUENESS"
}, {
  "property_keys" : [ "name1" ],
  "label" : "User",
  "type" : "UNIQUENESS"
} ]</programlisting>
</section>
<section id="rest-api-drop-constraint">
<title>Drop constraint</title>
<simpara>Drop uniqueness constraint for a label and a property.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/schema/constraint/SomeLabel/uniqueness/name</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
</section>
<section id="rest-api-traverse">
<title>Traversals</title>
<warning><simpara>The Traversal REST Endpoint executes arbitrary Javascript code under the hood as part of the evaluators definitions. In hosted and open environments, this can constitute a security risk.
In these case, consider using declarative approaches like <xref linkend="cypher-query-lang"/> or write your own server side plugin executing the
interesting traversals with the Java API ( see <xref linkend="server-plugins"/> ) or secure your server, see <xref linkend="operations-security"/>.</simpara></warning>
<simpara>Traversals are performed from a start node.
The traversal is controlled by the URI and the body sent with the request.</simpara>
<variablelist>
<varlistentry>
<term>
returnType
</term>
<listitem>
<simpara>
The kind of objects in the response is determined by <emphasis>traverse/{returnType}</emphasis> in the URL.
 <literal>returnType</literal> can have one of these values:
</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>node</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>relationship</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>path</literal>: contains full representations of start and end node, the rest are URIs.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>fullpath</literal>: contains full representations of all nodes and relationships.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<simpara>To decide how the graph should be traversed you can use these parameters in the request body:</simpara>
<variablelist>
<varlistentry>
<term>
order
</term>
<listitem>
<simpara>
Decides in which order to visit nodes. Possible values:
</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>breadth_first</literal>: see <ulink url="http://en.wikipedia.org/wiki/Breadth-first_search">Breadth-first search</ulink>.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>depth_first</literal>: see <ulink url="http://en.wikipedia.org/wiki/Depth-first_search">Depth-first search</ulink>
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
relationships
</term>
<listitem>
<simpara>
Decides which relationship types and directions should be followed.
 The direction can be one of:
</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>all</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>in</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>out</literal>
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
uniqueness
</term>
<listitem>
<simpara>
Decides how uniqueness should be calculated.
 For details on different uniqueness values see the <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/kernel/Uniqueness.html">Java API on Uniqueness</ulink>.
 Possible values:
</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>node_global</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>none</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>relationship_global</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>node_path</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>relationship_path</literal>
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
prune_evaluator
</term>
<listitem>
<simpara>
Decides whether the traverser should continue down that path or if it should be pruned so that the traverser won&#8217;t continue down that path.
 You can write your own prune evaluator as (see <xref linkend="rest-api-traversal-using-a-return-filter"/> or use the <literal>built-in</literal> <literal>none</literal> prune evaluator.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
return_filter
</term>
<listitem>
<simpara>
Decides whether the current position should be included in the result.
 You can provide your own code for this (see <xref linkend="rest-api-traversal-using-a-return-filter"/>), or use one of the built-in filters:
</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>all</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>all_but_start_node</literal>
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
max_depth
</term>
<listitem>
<simpara>
Is a short-hand way of specifying a prune evaluator which prunes after a certain depth.
 If not specified a max depth of 1 is used and if a <literal>prune_evaluator</literal> is specified instead of a <literal>max_depth</literal>, no max depth limit is set.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The <literal>position</literal> object in the body of the <literal>return_filter</literal> and <literal>prune_evaluator</literal> is a
<literal><ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/Path.html">Path</ulink></literal>
object representing the path from the start node to the current traversal position.</simpara>
<simpara>Out of the box, the REST API supports JavaScript code in filters and evaluators.
The script body will be executed in a Java context which has access to the full Neo4j <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/">Java API</ulink>.
See the examples for the exact syntax of the request.</simpara>
<section id="rest-api-traversal-using-a-return-filter">
<title>Traversal using a return filter</title>
<simpara>In this example, the <literal>none</literal> prune evaluator is used and a return filter
is supplied in order to return all names containing "t".
The result is to be returned as nodes and the max depth is
set to 3.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Traversal-using-a-return-filter.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Traversal-using-a-return-filter.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Traversal-using-a-return-filter.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/374/traverse/node</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "order" : "breadth_first",
  "return_filter" : {
    "body" : "position.endNode().getProperty('name').toLowerCase().contains('t')",
    "language" : "javascript"
  },
  "prune_evaluator" : {
    "body" : "position.length() &gt; 10",
    "language" : "javascript"
  },
  "uniqueness" : "node_global",
  "relationships" : [ {
    "direction" : "all",
    "type" : "knows"
  }, {
    "direction" : "all",
    "type" : "loves"
  } ],
  "max_depth" : 3
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "labels" : "http://localhost:7474/db/data/node/374/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/374/relationships/out",
  "data" : {
    "name" : "Root"
  },
  "traverse" : "http://localhost:7474/db/data/node/374/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/374/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/374/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/374",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/374/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/374/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/374/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/374/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/374/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/374/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/374/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/377/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/377/relationships/out",
  "data" : {
    "name" : "Mattias"
  },
  "traverse" : "http://localhost:7474/db/data/node/377/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/377/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/377/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/377",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/377/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/377/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/377/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/377/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/377/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/377/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/377/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/376/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/376/relationships/out",
  "data" : {
    "name" : "Peter"
  },
  "traverse" : "http://localhost:7474/db/data/node/376/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/376/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/376/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/376",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/376/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/376/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/376/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/376/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/376/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/376/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/376/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/375/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/375/relationships/out",
  "data" : {
    "name" : "Tobias"
  },
  "traverse" : "http://localhost:7474/db/data/node/375/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/375/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/375/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/375",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/375/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/375/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/375/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/375/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/375/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/375/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/375/relationships/in/{-list|&amp;|types}"
} ]</programlisting>
</section>
<section id="rest-api-return-relationships-from-a-traversal">
<title>Return relationships from a traversal</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-return-relationships-from-a-traversal.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-return-relationships-from-a-traversal.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-return-relationships-from-a-traversal.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/368/traverse/relationship</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "order" : "breadth_first",
  "uniqueness" : "none",
  "return_filter" : {
    "language" : "builtin",
    "name" : "all"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "start" : "http://localhost:7474/db/data/node/368",
  "data" : {
  },
  "self" : "http://localhost:7474/db/data/relationship/249",
  "property" : "http://localhost:7474/db/data/relationship/249/properties/{key}",
  "properties" : "http://localhost:7474/db/data/relationship/249/properties",
  "type" : "know",
  "extensions" : {
  },
  "end" : "http://localhost:7474/db/data/node/367"
}, {
  "start" : "http://localhost:7474/db/data/node/368",
  "data" : {
  },
  "self" : "http://localhost:7474/db/data/relationship/250",
  "property" : "http://localhost:7474/db/data/relationship/250/properties/{key}",
  "properties" : "http://localhost:7474/db/data/relationship/250/properties",
  "type" : "own",
  "extensions" : {
  },
  "end" : "http://localhost:7474/db/data/node/366"
} ]</programlisting>
</section>
<section id="rest-api-return-paths-from-a-traversal">
<title>Return paths from a traversal</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-return-paths-from-a-traversal.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-return-paths-from-a-traversal.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-return-paths-from-a-traversal.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/358/traverse/path</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "order" : "breadth_first",
  "uniqueness" : "none",
  "return_filter" : {
    "language" : "builtin",
    "name" : "all"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "start" : "http://localhost:7474/db/data/node/358",
  "nodes" : [ "http://localhost:7474/db/data/node/358" ],
  "length" : 0,
  "relationships" : [ ],
  "end" : "http://localhost:7474/db/data/node/358"
}, {
  "start" : "http://localhost:7474/db/data/node/358",
  "nodes" : [ "http://localhost:7474/db/data/node/358", "http://localhost:7474/db/data/node/357" ],
  "length" : 1,
  "relationships" : [ "http://localhost:7474/db/data/relationship/241" ],
  "end" : "http://localhost:7474/db/data/node/357"
}, {
  "start" : "http://localhost:7474/db/data/node/358",
  "nodes" : [ "http://localhost:7474/db/data/node/358", "http://localhost:7474/db/data/node/356" ],
  "length" : 1,
  "relationships" : [ "http://localhost:7474/db/data/relationship/242" ],
  "end" : "http://localhost:7474/db/data/node/356"
} ]</programlisting>
</section>
<section id="rest-api-traversal-returning-nodes-below-a-certain-depth">
<title>Traversal returning nodes below a certain depth</title>
<simpara>Here, all nodes at a traversal depth below 3 are returned.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Traversal-returning-nodes-below-a-certain-depth.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Traversal-returning-nodes-below-a-certain-depth.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Traversal-returning-nodes-below-a-certain-depth.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/362/traverse/node</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "return_filter" : {
    "body" : "position.length()&lt;3;",
    "language" : "javascript"
  },
  "prune_evaluator" : {
    "name" : "none",
    "language" : "builtin"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "labels" : "http://localhost:7474/db/data/node/362/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/362/relationships/out",
  "data" : {
    "name" : "Root"
  },
  "traverse" : "http://localhost:7474/db/data/node/362/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/362/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/362/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/362",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/362/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/362/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/362/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/362/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/362/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/362/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/362/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/365/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/365/relationships/out",
  "data" : {
    "name" : "Mattias"
  },
  "traverse" : "http://localhost:7474/db/data/node/365/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/365/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/365/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/365",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/365/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/365/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/365/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/365/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/365/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/365/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/365/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/360/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/360/relationships/out",
  "data" : {
    "name" : "Johan"
  },
  "traverse" : "http://localhost:7474/db/data/node/360/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/360/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/360/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/360",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/360/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/360/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/360/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/360/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/360/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/360/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/360/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/361/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/361/relationships/out",
  "data" : {
    "name" : "Emil"
  },
  "traverse" : "http://localhost:7474/db/data/node/361/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/361/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/361/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/361",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/361/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/361/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/361/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/361/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/361/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/361/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/361/relationships/in/{-list|&amp;|types}"
} ]</programlisting>
</section>
<section id="rest-api-creating-a-paged-traverser">
<title>Creating a paged traverser</title>
<simpara>Paged traversers are created by <literal>POST</literal>-ing a
traversal description to the link identified by the <literal>paged_traverser</literal> key
in a node representation. When creating a paged traverser, the same
options apply as for a regular traverser, meaning that <literal>node</literal>, <literal>path</literal>,
or <literal>fullpath</literal>, can be targeted.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/297/paged/traverse/node</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "prune_evaluator" : {
    "language" : "builtin",
    "name" : "none"
  },
  "return_filter" : {
    "language" : "javascript",
    "body" : "position.endNode().getProperty('name').contains('1');"
  },
  "order" : "depth_first",
  "relationships" : {
    "type" : "NEXT",
    "direction" : "out"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/node/297/paged/traverse/node/d5fbcbff946b4abaa5825198999ba4ca</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "labels" : "http://localhost:7474/db/data/node/298/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/298/relationships/out",
  "data" : {
    "name" : "1"
  },
  "traverse" : "http://localhost:7474/db/data/node/298/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/298/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/298/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/298",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/298/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/298/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/298/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/298/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/298/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/298/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/298/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/307/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/307/relationships/out",
  "data" : {
    "name" : "10"
  },
  "traverse" : "http://localhost:7474/db/data/node/307/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/307/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/307/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/307",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/307/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/307/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/307/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/307/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/307/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/307/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/307/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/308/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/308/relationships/out",
  "data" : {
    "name" : "11"
  },
  "traverse" : "http://localhost:7474/db/data/node/308/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/308/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/308/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/308",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/308/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/308/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/308/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/308/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/308/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/308/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/308/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/309/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/309/relationships/out",
  "data" : {
    "name" : "12"
  },
  "traverse" : "http://localhost:7474/db/data/node/309/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/309/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/309/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/309",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/309/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/309/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/309/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/309/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/309/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/309/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/309/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/310/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/310/relationships/out",
  "data" : {
    "name" : "13"
  },
  "traverse" : "http://localhost:7474/db/data/node/310/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/310/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/310/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/310",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/310/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/310/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/310/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/310/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/310/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/310/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/310/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/311/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/311/relationships/out",
  "data" : {
    "name" : "14"
  },
  "traverse" : "http://localhost:7474/db/data/node/311/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/311/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/311/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/311",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/311/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/311/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/311/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/311/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/311/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/311/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/311/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/312/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/312/relationships/out",
  "data" : {
    "name" : "15"
  },
  "traverse" : "http://localhost:7474/db/data/node/312/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/312/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/312/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/312",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/312/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/312/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/312/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/312/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/312/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/312/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/312/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/313/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/313/relationships/out",
  "data" : {
    "name" : "16"
  },
  "traverse" : "http://localhost:7474/db/data/node/313/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/313/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/313/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/313",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/313/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/313/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/313/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/313/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/313/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/313/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/313/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/314/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/314/relationships/out",
  "data" : {
    "name" : "17"
  },
  "traverse" : "http://localhost:7474/db/data/node/314/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/314/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/314/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/314",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/314/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/314/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/314/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/314/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/314/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/314/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/314/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/315/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/315/relationships/out",
  "data" : {
    "name" : "18"
  },
  "traverse" : "http://localhost:7474/db/data/node/315/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/315/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/315/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/315",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/315/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/315/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/315/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/315/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/315/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/315/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/315/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/316/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/316/relationships/out",
  "data" : {
    "name" : "19"
  },
  "traverse" : "http://localhost:7474/db/data/node/316/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/316/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/316/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/316",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/316/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/316/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/316/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/316/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/316/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/316/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/316/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/318/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/318/relationships/out",
  "data" : {
    "name" : "21"
  },
  "traverse" : "http://localhost:7474/db/data/node/318/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/318/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/318/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/318",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/318/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/318/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/318/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/318/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/318/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/318/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/318/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/328/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/328/relationships/out",
  "data" : {
    "name" : "31"
  },
  "traverse" : "http://localhost:7474/db/data/node/328/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/328/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/328/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/328",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/328/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/328/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/328/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/328/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/328/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/328/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/328/relationships/in/{-list|&amp;|types}"
} ]</programlisting>
</section>
<section id="rest-api-paging-through-the-results-of-a-paged-traverser">
<title>Paging through the results of a paged traverser</title>
<simpara>Paged traversers hold
state on the server, and allow clients to page through the results of a
traversal. To progress to the next page of traversal results, the client
issues a HTTP GET request on the paged traversal URI which causes the
traversal to fill the next page (or partially fill it if insufficient
results are available).</simpara>
<simpara>Note that if a traverser expires through inactivity it will cause a 404
response on the next <literal>GET</literal> request. Traversers' leases are renewed on
every successful access for the same amount of time as originally
specified.</simpara>
<simpara>When the paged traverser reaches the end of its results, the client can
expect a 404 response as the traverser is disposed by the server.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/node/330/paged/traverse/node/4abcdb1d75de4f0e8d108070aacc3b93</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "labels" : "http://localhost:7474/db/data/node/661/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/661/relationships/out",
  "data" : {
    "name" : "331"
  },
  "traverse" : "http://localhost:7474/db/data/node/661/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/661/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/661/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/661",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/661/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/661/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/661/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/661/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/661/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/661/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/661/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/671/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/671/relationships/out",
  "data" : {
    "name" : "341"
  },
  "traverse" : "http://localhost:7474/db/data/node/671/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/671/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/671/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/671",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/671/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/671/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/671/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/671/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/671/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/671/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/671/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/681/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/681/relationships/out",
  "data" : {
    "name" : "351"
  },
  "traverse" : "http://localhost:7474/db/data/node/681/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/681/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/681/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/681",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/681/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/681/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/681/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/681/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/681/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/681/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/681/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/691/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/691/relationships/out",
  "data" : {
    "name" : "361"
  },
  "traverse" : "http://localhost:7474/db/data/node/691/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/691/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/691/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/691",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/691/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/691/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/691/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/691/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/691/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/691/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/691/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/701/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/701/relationships/out",
  "data" : {
    "name" : "371"
  },
  "traverse" : "http://localhost:7474/db/data/node/701/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/701/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/701/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/701",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/701/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/701/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/701/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/701/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/701/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/701/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/701/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/711/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/711/relationships/out",
  "data" : {
    "name" : "381"
  },
  "traverse" : "http://localhost:7474/db/data/node/711/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/711/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/711/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/711",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/711/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/711/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/711/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/711/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/711/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/711/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/711/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/721/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/721/relationships/out",
  "data" : {
    "name" : "391"
  },
  "traverse" : "http://localhost:7474/db/data/node/721/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/721/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/721/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/721",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/721/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/721/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/721/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/721/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/721/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/721/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/721/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/731/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/731/relationships/out",
  "data" : {
    "name" : "401"
  },
  "traverse" : "http://localhost:7474/db/data/node/731/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/731/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/731/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/731",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/731/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/731/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/731/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/731/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/731/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/731/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/731/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/740/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/740/relationships/out",
  "data" : {
    "name" : "410"
  },
  "traverse" : "http://localhost:7474/db/data/node/740/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/740/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/740/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/740",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/740/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/740/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/740/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/740/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/740/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/740/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/740/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/741/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/741/relationships/out",
  "data" : {
    "name" : "411"
  },
  "traverse" : "http://localhost:7474/db/data/node/741/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/741/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/741/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/741",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/741/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/741/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/741/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/741/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/741/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/741/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/741/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/742/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/742/relationships/out",
  "data" : {
    "name" : "412"
  },
  "traverse" : "http://localhost:7474/db/data/node/742/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/742/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/742/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/742",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/742/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/742/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/742/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/742/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/742/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/742/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/742/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/743/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/743/relationships/out",
  "data" : {
    "name" : "413"
  },
  "traverse" : "http://localhost:7474/db/data/node/743/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/743/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/743/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/743",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/743/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/743/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/743/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/743/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/743/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/743/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/743/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/744/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/744/relationships/out",
  "data" : {
    "name" : "414"
  },
  "traverse" : "http://localhost:7474/db/data/node/744/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/744/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/744/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/744",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/744/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/744/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/744/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/744/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/744/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/744/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/744/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/745/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/745/relationships/out",
  "data" : {
    "name" : "415"
  },
  "traverse" : "http://localhost:7474/db/data/node/745/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/745/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/745/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/745",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/745/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/745/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/745/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/745/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/745/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/745/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/745/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/746/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/746/relationships/out",
  "data" : {
    "name" : "416"
  },
  "traverse" : "http://localhost:7474/db/data/node/746/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/746/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/746/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/746",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/746/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/746/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/746/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/746/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/746/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/746/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/746/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/747/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/747/relationships/out",
  "data" : {
    "name" : "417"
  },
  "traverse" : "http://localhost:7474/db/data/node/747/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/747/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/747/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/747",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/747/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/747/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/747/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/747/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/747/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/747/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/747/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/748/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/748/relationships/out",
  "data" : {
    "name" : "418"
  },
  "traverse" : "http://localhost:7474/db/data/node/748/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/748/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/748/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/748",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/748/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/748/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/748/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/748/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/748/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/748/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/748/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/749/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/749/relationships/out",
  "data" : {
    "name" : "419"
  },
  "traverse" : "http://localhost:7474/db/data/node/749/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/749/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/749/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/749",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/749/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/749/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/749/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/749/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/749/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/749/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/749/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/751/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/751/relationships/out",
  "data" : {
    "name" : "421"
  },
  "traverse" : "http://localhost:7474/db/data/node/751/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/751/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/751/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/751",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/751/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/751/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/751/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/751/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/751/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/751/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/751/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/761/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/761/relationships/out",
  "data" : {
    "name" : "431"
  },
  "traverse" : "http://localhost:7474/db/data/node/761/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/761/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/761/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/761",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/761/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/761/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/761/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/761/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/761/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/761/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/761/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/771/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/771/relationships/out",
  "data" : {
    "name" : "441"
  },
  "traverse" : "http://localhost:7474/db/data/node/771/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/771/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/771/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/771",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/771/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/771/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/771/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/771/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/771/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/771/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/771/relationships/in/{-list|&amp;|types}"
} ]</programlisting>
</section>
<section id="rest-api-paged-traverser-page-size">
<title>Paged traverser page size</title>
<simpara>The default page size is 50 items, but
depending on the application larger or smaller pages sizes might be
appropriate. This can be set by adding a <literal>pageSize</literal> query parameter.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/33/paged/traverse/node?pageSize=1</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "prune_evaluator" : {
    "language" : "builtin",
    "name" : "none"
  },
  "return_filter" : {
    "language" : "javascript",
    "body" : "position.endNode().getProperty('name').contains('1');"
  },
  "order" : "depth_first",
  "relationships" : {
    "type" : "NEXT",
    "direction" : "out"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/node/33/paged/traverse/node/df12b766cb774d958fc4593f13e83992</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "labels" : "http://localhost:7474/db/data/node/34/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/34/relationships/out",
  "data" : {
    "name" : "1"
  },
  "traverse" : "http://localhost:7474/db/data/node/34/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/34/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/34/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/34",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/34/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/34/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/34/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/34/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/34/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/34/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/34/relationships/in/{-list|&amp;|types}"
} ]</programlisting>
</section>
<section id="rest-api-paged-traverser-timeout">
<title>Paged traverser timeout</title>
<simpara>The default timeout for a paged traverser is 60
seconds, but depending on the application larger or smaller timeouts
might be appropriate. This can be set by adding a <literal>leaseTime</literal> query
parameter with the number of seconds the paged traverser should last.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/807/paged/traverse/node?leaseTime=10</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "prune_evaluator" : {
    "language" : "builtin",
    "name" : "none"
  },
  "return_filter" : {
    "language" : "javascript",
    "body" : "position.endNode().getProperty('name').contains('1');"
  },
  "order" : "depth_first",
  "relationships" : {
    "type" : "NEXT",
    "direction" : "out"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/node/807/paged/traverse/node/284bfa5522484ff39f8bac6eabc0e51e</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "labels" : "http://localhost:7474/db/data/node/808/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/808/relationships/out",
  "data" : {
    "name" : "1"
  },
  "traverse" : "http://localhost:7474/db/data/node/808/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/808/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/808/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/808",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/808/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/808/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/808/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/808/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/808/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/808/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/808/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/817/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/817/relationships/out",
  "data" : {
    "name" : "10"
  },
  "traverse" : "http://localhost:7474/db/data/node/817/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/817/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/817/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/817",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/817/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/817/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/817/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/817/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/817/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/817/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/817/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/818/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/818/relationships/out",
  "data" : {
    "name" : "11"
  },
  "traverse" : "http://localhost:7474/db/data/node/818/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/818/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/818/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/818",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/818/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/818/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/818/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/818/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/818/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/818/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/818/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/819/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/819/relationships/out",
  "data" : {
    "name" : "12"
  },
  "traverse" : "http://localhost:7474/db/data/node/819/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/819/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/819/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/819",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/819/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/819/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/819/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/819/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/819/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/819/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/819/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/820/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/820/relationships/out",
  "data" : {
    "name" : "13"
  },
  "traverse" : "http://localhost:7474/db/data/node/820/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/820/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/820/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/820",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/820/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/820/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/820/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/820/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/820/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/820/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/820/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/821/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/821/relationships/out",
  "data" : {
    "name" : "14"
  },
  "traverse" : "http://localhost:7474/db/data/node/821/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/821/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/821/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/821",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/821/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/821/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/821/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/821/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/821/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/821/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/821/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/822/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/822/relationships/out",
  "data" : {
    "name" : "15"
  },
  "traverse" : "http://localhost:7474/db/data/node/822/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/822/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/822/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/822",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/822/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/822/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/822/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/822/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/822/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/822/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/822/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/823/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/823/relationships/out",
  "data" : {
    "name" : "16"
  },
  "traverse" : "http://localhost:7474/db/data/node/823/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/823/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/823/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/823",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/823/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/823/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/823/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/823/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/823/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/823/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/823/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/824/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/824/relationships/out",
  "data" : {
    "name" : "17"
  },
  "traverse" : "http://localhost:7474/db/data/node/824/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/824/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/824/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/824",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/824/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/824/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/824/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/824/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/824/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/824/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/824/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/825/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/825/relationships/out",
  "data" : {
    "name" : "18"
  },
  "traverse" : "http://localhost:7474/db/data/node/825/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/825/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/825/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/825",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/825/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/825/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/825/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/825/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/825/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/825/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/825/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/826/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/826/relationships/out",
  "data" : {
    "name" : "19"
  },
  "traverse" : "http://localhost:7474/db/data/node/826/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/826/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/826/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/826",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/826/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/826/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/826/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/826/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/826/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/826/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/826/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/828/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/828/relationships/out",
  "data" : {
    "name" : "21"
  },
  "traverse" : "http://localhost:7474/db/data/node/828/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/828/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/828/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/828",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/828/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/828/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/828/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/828/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/828/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/828/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/828/relationships/in/{-list|&amp;|types}"
}, {
  "labels" : "http://localhost:7474/db/data/node/838/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/838/relationships/out",
  "data" : {
    "name" : "31"
  },
  "traverse" : "http://localhost:7474/db/data/node/838/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/838/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/838/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/838",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/838/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/838/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/838/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/838/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/838/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/838/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/838/relationships/in/{-list|&amp;|types}"
} ]</programlisting>
</section>
</section>
<section id="rest-api-graph-algos">
<title>Graph Algorithms</title>
<simpara>Neo4j comes with a number of built-in graph algorithms.
They are performed from a start node.
The traversal is controlled by the URI and the body sent with the request.
These are the parameters that can be used:</simpara>
<variablelist>
<varlistentry>
<term>
algorithm
</term>
<listitem>
<simpara>
The algorithm to choose. If not set, default is <literal>shortestPath</literal>.
 <literal>algorithm</literal> can have one of these values:
</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>shortestPath</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>allSimplePaths</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>allPaths</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>dijkstra</literal> (optionally with <literal>cost_property</literal> and <literal>default_cost</literal> parameters)
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
max_depth
</term>
<listitem>
<simpara>
The maximum depth as an integer for the algorithms like <literal>shortestPath</literal>, where applicable.
Default is <literal>1</literal>.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<section id="rest-api-find-all-shortest-paths">
<title>Find all shortest paths</title>
<simpara>The <literal>shortestPath</literal> algorithm can find multiple paths between the same
nodes, like in this example.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Find-all-shortest-paths.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Find-all-shortest-paths.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Find-all-shortest-paths.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/201/paths</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "to" : "http://localhost:7474/db/data/node/196",
  "max_depth" : 3,
  "relationships" : {
    "type" : "to",
    "direction" : "out"
  },
  "algorithm" : "shortestPath"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "start" : "http://localhost:7474/db/data/node/201",
  "nodes" : [ "http://localhost:7474/db/data/node/201", "http://localhost:7474/db/data/node/200", "http://localhost:7474/db/data/node/196" ],
  "length" : 2,
  "relationships" : [ "http://localhost:7474/db/data/relationship/138", "http://localhost:7474/db/data/relationship/147" ],
  "end" : "http://localhost:7474/db/data/node/196"
}, {
  "start" : "http://localhost:7474/db/data/node/201",
  "nodes" : [ "http://localhost:7474/db/data/node/201", "http://localhost:7474/db/data/node/197", "http://localhost:7474/db/data/node/196" ],
  "length" : 2,
  "relationships" : [ "http://localhost:7474/db/data/relationship/139", "http://localhost:7474/db/data/relationship/145" ],
  "end" : "http://localhost:7474/db/data/node/196"
} ]</programlisting>
</section>
<section id="rest-api-find-one-of-the-shortest-paths">
<title>Find one of the shortest paths</title>
<simpara>If no path algorithm is specified, a <literal>shortestPath</literal> algorithm with a max
depth of 1 will be chosen. In this example, the <literal>max_depth</literal> is set to <literal>3</literal>
in order to find the shortest path between a maximum of 3 linked nodes.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Find-one-of-the-shortest-paths.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Find-one-of-the-shortest-paths.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Find-one-of-the-shortest-paths.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/194/path</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "to" : "http://localhost:7474/db/data/node/189",
  "max_depth" : 3,
  "relationships" : {
    "type" : "to",
    "direction" : "out"
  },
  "algorithm" : "shortestPath"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "start" : "http://localhost:7474/db/data/node/194",
  "nodes" : [ "http://localhost:7474/db/data/node/194", "http://localhost:7474/db/data/node/190", "http://localhost:7474/db/data/node/189" ],
  "length" : 2,
  "relationships" : [ "http://localhost:7474/db/data/relationship/129", "http://localhost:7474/db/data/relationship/135" ],
  "end" : "http://localhost:7474/db/data/node/189"
}</programlisting>
</section>
<section id="rest-api-execute-a-dijkstra-algorithm-and-get-a-single-path">
<title>Execute a Dijkstra algorithm and get a single path</title>
<simpara>This example is running a Dijkstra algorithm over a graph with different
cost properties on different relationships. Note that the request URI
ends with <literal>/path</literal> which means a single path is what we want here.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Execute-a-Dijkstra-algorithm-and-get-a-single-path.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Execute-a-Dijkstra-algorithm-and-get-a-single-path.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Execute-a-Dijkstra-algorithm-and-get-a-single-path.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/207/path</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "to" : "http://localhost:7474/db/data/node/204",
  "cost_property" : "cost",
  "relationships" : {
    "type" : "to",
    "direction" : "out"
  },
  "algorithm" : "dijkstra"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "weight" : 1.5,
  "start" : "http://localhost:7474/db/data/node/207",
  "nodes" : [ "http://localhost:7474/db/data/node/207", "http://localhost:7474/db/data/node/206", "http://localhost:7474/db/data/node/203", "http://localhost:7474/db/data/node/204" ],
  "length" : 3,
  "relationships" : [ "http://localhost:7474/db/data/relationship/149", "http://localhost:7474/db/data/relationship/151", "http://localhost:7474/db/data/relationship/152" ],
  "end" : "http://localhost:7474/db/data/node/204"
}</programlisting>
</section>
<section id="rest-api-execute-a-dijkstra-algorithm-with-equal-weights-on-relationships">
<title>Execute a Dijkstra algorithm with equal weights on relationships</title>
<simpara>The following is executing a Dijkstra search on a graph with equal
weights on all relationships. This example is included to show the
difference when the same graph structure is used, but the path weight is
equal to the number of hops.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Execute-a-Dijkstra-algorithm-with-equal-weights-on-relationships.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Execute-a-Dijkstra-algorithm-with-equal-weights-on-relationships.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Execute-a-Dijkstra-algorithm-with-equal-weights-on-relationships.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/213/path</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "to" : "http://localhost:7474/db/data/node/210",
  "cost_property" : "cost",
  "relationships" : {
    "type" : "to",
    "direction" : "out"
  },
  "algorithm" : "dijkstra"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "weight" : 2.0,
  "start" : "http://localhost:7474/db/data/node/213",
  "nodes" : [ "http://localhost:7474/db/data/node/213", "http://localhost:7474/db/data/node/211", "http://localhost:7474/db/data/node/210" ],
  "length" : 2,
  "relationships" : [ "http://localhost:7474/db/data/relationship/155", "http://localhost:7474/db/data/relationship/160" ],
  "end" : "http://localhost:7474/db/data/node/210"
}</programlisting>
</section>
<section id="rest-api-execute-a-dijkstra-algorithm-and-get-multiple-paths">
<title>Execute a Dijkstra algorithm and get multiple paths</title>
<simpara>This example is running a Dijkstra algorithm over a graph with different
cost properties on different relationships. Note that the request URI
ends with <literal>/paths</literal> which means we want multiple paths returned, in case
they exist.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Execute-a-Dijkstra-algorithm-and-get-multiple-paths.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Execute-a-Dijkstra-algorithm-and-get-multiple-paths.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Execute-a-Dijkstra-algorithm-and-get-multiple-paths.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node/187/paths</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "to" : "http://localhost:7474/db/data/node/184",
  "cost_property" : "cost",
  "relationships" : {
    "type" : "to",
    "direction" : "out"
  },
  "algorithm" : "dijkstra"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "weight" : 1.5,
  "start" : "http://localhost:7474/db/data/node/187",
  "nodes" : [ "http://localhost:7474/db/data/node/187", "http://localhost:7474/db/data/node/186", "http://localhost:7474/db/data/node/183", "http://localhost:7474/db/data/node/184" ],
  "length" : 3,
  "relationships" : [ "http://localhost:7474/db/data/relationship/122", "http://localhost:7474/db/data/relationship/124", "http://localhost:7474/db/data/relationship/125" ],
  "end" : "http://localhost:7474/db/data/node/184"
}, {
  "weight" : 1.5,
  "start" : "http://localhost:7474/db/data/node/187",
  "nodes" : [ "http://localhost:7474/db/data/node/187", "http://localhost:7474/db/data/node/182", "http://localhost:7474/db/data/node/184" ],
  "length" : 2,
  "relationships" : [ "http://localhost:7474/db/data/relationship/123", "http://localhost:7474/db/data/relationship/127" ],
  "end" : "http://localhost:7474/db/data/node/184"
} ]</programlisting>
</section>
</section>
<section id="rest-api-batch-ops">
<title>Batch operations</title>
<section id="rest-api-execute-multiple-operations-in-batch">
<title>Execute multiple operations in batch</title>
<simpara>This lets you execute multiple API calls through a single HTTP call,
significantly improving performance for large insert and update
operations.</simpara>
<simpara>The batch service expects an array of job descriptions as input, each job
description describing an action to be performed via the normal server
API.</simpara>
<simpara>This service is transactional. If any of the operations performed fails
(returns a non-2xx HTTP status code), the transaction will be rolled back
and all changes will be undone.</simpara>
<simpara>Each job description should contain a <literal>to</literal> attribute, with a value
relative to the data API root (so <ulink url="http://localhost:7474/db/data/node">http://localhost:7474/db/data/node</ulink> becomes
just /node), and a <literal>method</literal> attribute containing HTTP verb to use.</simpara>
<simpara>Optionally you may provide a <literal>body</literal> attribute, and an <literal>id</literal> attribute to
help you keep track of responses, although responses are guaranteed to be
returned in the same order the job descriptions are received.</simpara>
<simpara>The following figure outlines the different parts of the job
descriptions:</simpara>
<informalfigure>
<ulink url="images/batch-request-api.png">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/batch-request-api.png"/>
  </imageobject>
  <textobject><phrase>batch-request-api.png</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Execute-multiple-operations-in-batch.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Execute-multiple-operations-in-batch.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Execute-multiple-operations-in-batch.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/batch</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "method" : "PUT",
  "to" : "/node/31/properties",
  "body" : {
    "age" : 1
  },
  "id" : 0
}, {
  "method" : "GET",
  "to" : "/node/31",
  "id" : 1
}, {
  "method" : "POST",
  "to" : "/node",
  "body" : {
    "age" : 1
  },
  "id" : 2
}, {
  "method" : "POST",
  "to" : "/node",
  "body" : {
    "age" : 1
  },
  "id" : 3
} ]</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "id" : 0,
  "from" : "/node/31/properties"
}, {
  "id" : 1,
  "body" : {
    "extensions" : {
    },
    "paged_traverse" : "http://localhost:7474/db/data/node/31/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "labels" : "http://localhost:7474/db/data/node/31/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/31/relationships/out",
    "traverse" : "http://localhost:7474/db/data/node/31/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/31/relationships/all/{-list|&amp;|types}",
    "all_relationships" : "http://localhost:7474/db/data/node/31/relationships/all",
    "property" : "http://localhost:7474/db/data/node/31/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/31",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/31/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/31/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/31/relationships/in",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/31/relationships/in/{-list|&amp;|types}",
    "create_relationship" : "http://localhost:7474/db/data/node/31/relationships",
    "data" : {
      "age" : 1
    }
  },
  "from" : "/node/31"
}, {
  "id" : 2,
  "location" : "http://localhost:7474/db/data/node/32",
  "body" : {
    "extensions" : {
    },
    "paged_traverse" : "http://localhost:7474/db/data/node/32/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "labels" : "http://localhost:7474/db/data/node/32/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/32/relationships/out",
    "traverse" : "http://localhost:7474/db/data/node/32/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/32/relationships/all/{-list|&amp;|types}",
    "all_relationships" : "http://localhost:7474/db/data/node/32/relationships/all",
    "property" : "http://localhost:7474/db/data/node/32/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/32",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/32/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/32/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/32/relationships/in",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/32/relationships/in/{-list|&amp;|types}",
    "create_relationship" : "http://localhost:7474/db/data/node/32/relationships",
    "data" : {
      "age" : 1
    }
  },
  "from" : "/node"
}, {
  "id" : 3,
  "location" : "http://localhost:7474/db/data/node/33",
  "body" : {
    "extensions" : {
    },
    "paged_traverse" : "http://localhost:7474/db/data/node/33/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "labels" : "http://localhost:7474/db/data/node/33/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/33/relationships/out",
    "traverse" : "http://localhost:7474/db/data/node/33/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/33/relationships/all/{-list|&amp;|types}",
    "all_relationships" : "http://localhost:7474/db/data/node/33/relationships/all",
    "property" : "http://localhost:7474/db/data/node/33/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/33",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/33/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/33/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/33/relationships/in",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/33/relationships/in/{-list|&amp;|types}",
    "create_relationship" : "http://localhost:7474/db/data/node/33/relationships",
    "data" : {
      "age" : 1
    }
  },
  "from" : "/node"
} ]</programlisting>
</section>
<section id="rest-api-refer-to-items-created-earlier-in-the-same-batch-job">
<title>Refer to items created earlier in the same batch job</title>
<simpara>The batch operation API allows you to refer to the URI returned from a
created resource in subsequent job descriptions, within the same batch
call.</simpara>
<simpara>Use the <literal>{[JOB ID]}</literal> special syntax to inject URIs from created resources
into JSON strings in subsequent job descriptions.</simpara>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-Refer-to-items-created-earlier-in-the-same-batch-job.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-Refer-to-items-created-earlier-in-the-same-batch-job.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-Refer-to-items-created-earlier-in-the-same-batch-job.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/batch</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "method" : "POST",
  "to" : "/node",
  "id" : 0,
  "body" : {
    "name" : "bob"
  }
}, {
  "method" : "POST",
  "to" : "/node",
  "id" : 1,
  "body" : {
    "age" : 12
  }
}, {
  "method" : "POST",
  "to" : "{0}/relationships",
  "id" : 3,
  "body" : {
    "to" : "{1}",
    "data" : {
      "since" : "2010"
    },
    "type" : "KNOWS"
  }
}, {
  "method" : "POST",
  "to" : "/index/relationship/my_rels",
  "id" : 4,
  "body" : {
    "key" : "since",
    "value" : "2010",
    "uri" : "{3}"
  }
} ]</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "id" : 0,
  "location" : "http://localhost:7474/db/data/node/23",
  "body" : {
    "extensions" : {
    },
    "paged_traverse" : "http://localhost:7474/db/data/node/23/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "labels" : "http://localhost:7474/db/data/node/23/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/23/relationships/out",
    "traverse" : "http://localhost:7474/db/data/node/23/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/23/relationships/all/{-list|&amp;|types}",
    "all_relationships" : "http://localhost:7474/db/data/node/23/relationships/all",
    "property" : "http://localhost:7474/db/data/node/23/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/23",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/23/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/23/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/23/relationships/in",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/23/relationships/in/{-list|&amp;|types}",
    "create_relationship" : "http://localhost:7474/db/data/node/23/relationships",
    "data" : {
      "name" : "bob"
    }
  },
  "from" : "/node"
}, {
  "id" : 1,
  "location" : "http://localhost:7474/db/data/node/24",
  "body" : {
    "extensions" : {
    },
    "paged_traverse" : "http://localhost:7474/db/data/node/24/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "labels" : "http://localhost:7474/db/data/node/24/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/24/relationships/out",
    "traverse" : "http://localhost:7474/db/data/node/24/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/24/relationships/all/{-list|&amp;|types}",
    "all_relationships" : "http://localhost:7474/db/data/node/24/relationships/all",
    "property" : "http://localhost:7474/db/data/node/24/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/24",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/24/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/24/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/24/relationships/in",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/24/relationships/in/{-list|&amp;|types}",
    "create_relationship" : "http://localhost:7474/db/data/node/24/relationships",
    "data" : {
      "age" : 12
    }
  },
  "from" : "/node"
}, {
  "id" : 3,
  "location" : "http://localhost:7474/db/data/relationship/3",
  "body" : {
    "extensions" : {
    },
    "start" : "http://localhost:7474/db/data/node/23",
    "property" : "http://localhost:7474/db/data/relationship/3/properties/{key}",
    "self" : "http://localhost:7474/db/data/relationship/3",
    "properties" : "http://localhost:7474/db/data/relationship/3/properties",
    "type" : "KNOWS",
    "end" : "http://localhost:7474/db/data/node/24",
    "data" : {
      "since" : "2010"
    }
  },
  "from" : "http://localhost:7474/db/data/node/23/relationships"
}, {
  "id" : 4,
  "location" : "http://localhost:7474/db/data/index/relationship/my_rels/since/2010/3",
  "body" : {
    "extensions" : {
    },
    "start" : "http://localhost:7474/db/data/node/23",
    "property" : "http://localhost:7474/db/data/relationship/3/properties/{key}",
    "self" : "http://localhost:7474/db/data/relationship/3",
    "properties" : "http://localhost:7474/db/data/relationship/3/properties",
    "type" : "KNOWS",
    "end" : "http://localhost:7474/db/data/node/24",
    "data" : {
      "since" : "2010"
    },
    "indexed" : "http://localhost:7474/db/data/index/relationship/my_rels/since/2010/3"
  },
  "from" : "/index/relationship/my_rels"
} ]</programlisting>
</section>
<section id="rest-api-execute-multiple-operations-in-batch-streaming">
<title>Execute multiple operations in batch streaming</title>
<figure><title>Final Graph</title>
<ulink url="images/Final-Graph-execute-multiple-operations-in-batch-streaming.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Final-Graph-execute-multiple-operations-in-batch-streaming.svg"/>
  </imageobject>
  <textobject><phrase>Final-Graph-execute-multiple-operations-in-batch-streaming.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/batch</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>X-Stream:</literal></emphasis> <literal>true</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "method" : "PUT",
  "to" : "/node/100/properties",
  "body" : {
    "age" : 1
  },
  "id" : 0
}, {
  "method" : "GET",
  "to" : "/node/100",
  "id" : 1
}, {
  "method" : "POST",
  "to" : "/node",
  "body" : {
    "age" : 1
  },
  "id" : 2
}, {
  "method" : "POST",
  "to" : "/node",
  "body" : {
    "age" : 1
  },
  "id" : 3
} ]</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "id" : 0,
  "from" : "/node/100/properties",
  "body" : null,
  "status" : 204
}, {
  "id" : 1,
  "from" : "/node/100",
  "body" : {
    "extensions" : {
    },
    "paged_traverse" : "http://localhost:7474/db/data/node/100/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "labels" : "http://localhost:7474/db/data/node/100/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/100/relationships/out",
    "traverse" : "http://localhost:7474/db/data/node/100/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/100/relationships/all/{-list|&amp;|types}",
    "all_relationships" : "http://localhost:7474/db/data/node/100/relationships/all",
    "property" : "http://localhost:7474/db/data/node/100/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/100",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/100/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/100/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/100/relationships/in",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/100/relationships/in/{-list|&amp;|types}",
    "create_relationship" : "http://localhost:7474/db/data/node/100/relationships",
    "data" : {
      "age" : 1
    }
  },
  "status" : 200
}, {
  "id" : 2,
  "from" : "/node",
  "body" : {
    "extensions" : {
    },
    "paged_traverse" : "http://localhost:7474/db/data/node/101/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "labels" : "http://localhost:7474/db/data/node/101/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/101/relationships/out",
    "traverse" : "http://localhost:7474/db/data/node/101/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/101/relationships/all/{-list|&amp;|types}",
    "all_relationships" : "http://localhost:7474/db/data/node/101/relationships/all",
    "property" : "http://localhost:7474/db/data/node/101/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/101",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/101/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/101/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/101/relationships/in",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/101/relationships/in/{-list|&amp;|types}",
    "create_relationship" : "http://localhost:7474/db/data/node/101/relationships",
    "data" : {
      "age" : 1
    }
  },
  "location" : "http://localhost:7474/db/data/node/101",
  "status" : 201
}, {
  "id" : 3,
  "from" : "/node",
  "body" : {
    "extensions" : {
    },
    "paged_traverse" : "http://localhost:7474/db/data/node/102/paged/traverse/{returnType}{?pageSize,leaseTime}",
    "labels" : "http://localhost:7474/db/data/node/102/labels",
    "outgoing_relationships" : "http://localhost:7474/db/data/node/102/relationships/out",
    "traverse" : "http://localhost:7474/db/data/node/102/traverse/{returnType}",
    "all_typed_relationships" : "http://localhost:7474/db/data/node/102/relationships/all/{-list|&amp;|types}",
    "all_relationships" : "http://localhost:7474/db/data/node/102/relationships/all",
    "property" : "http://localhost:7474/db/data/node/102/properties/{key}",
    "self" : "http://localhost:7474/db/data/node/102",
    "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/102/relationships/out/{-list|&amp;|types}",
    "properties" : "http://localhost:7474/db/data/node/102/properties",
    "incoming_relationships" : "http://localhost:7474/db/data/node/102/relationships/in",
    "incoming_typed_relationships" : "http://localhost:7474/db/data/node/102/relationships/in/{-list|&amp;|types}",
    "create_relationship" : "http://localhost:7474/db/data/node/102/relationships",
    "data" : {
      "age" : 1
    }
  },
  "location" : "http://localhost:7474/db/data/node/102",
  "status" : 201
} ]</programlisting>
</section>
</section>
<section id="rest-api-indexes">
<title>Legacy indexing</title>
<note><simpara>This documents the legacy indexing in Neo4j, which is no longer the preferred way to handle indexes. Consider looking at <xref linkend="rest-api-schema-indexes"/>.</simpara></note>
<simpara>An index can contain either nodes or relationships.</simpara>
<note><simpara>To create an index with default configuration, simply start using it by adding nodes/relationships to it. It will then be automatically created for you.</simpara></note>
<simpara>What default configuration means depends on how you have configured your database.
If you haven&#8217;t changed any indexing configuration, it means the indexes will be using a Lucene-based backend.</simpara>
<simpara>All the examples below show you how to do operations on node indexes, but all of them are just as applicable
to relationship indexes. Simple change the "node" part of the URL to "relationship".</simpara>
<simpara>If you want to customize the index settings, see <xref linkend="rest-api-create-node-index-with-configuration"/>.</simpara>
<section id="rest-api-create-node-index">
<title>Create node index</title>
<note><simpara>Instead of creating the index this way, you can simply start to use
it, and it will be created automatically with default configuration.</simpara></note>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "name" : "favorites"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/index/node/favorites/</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "template" : "http://localhost:7474/db/data/index/node/favorites/{key}/{value}"
}</programlisting>
</section>
<section id="rest-api-create-node-index-with-configuration">
<title>Create node index with configuration</title>
<simpara>This request is only necessary if
you want to customize the index settings. If you are happy with the
defaults, you can just start indexing nodes/relationships, as
non-existent indexes will automatically be created as you do. See
<xref linkend="indexing-create-advanced"/> for more information on index configuration.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "name" : "fulltext",
  "config" : {
    "type" : "fulltext",
    "provider" : "lucene"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/index/node/fulltext/</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "template" : "http://localhost:7474/db/data/index/node/fulltext/{key}/{value}",
  "type" : "fulltext",
  "provider" : "lucene"
}</programlisting>
</section>
<section id="rest-api-delete-node-index">
<title>Delete node index</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/kvnode</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-list-node-indexes">
<title>List node indexes</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "node_auto_index" : {
    "template" : "http://localhost:7474/db/data/index/node/node_auto_index/{key}/{value}",
    "provider" : "lucene",
    "type" : "exact"
  },
  "favorites" : {
    "template" : "http://localhost:7474/db/data/index/node/favorites/{key}/{value}",
    "provider" : "lucene",
    "type" : "exact"
  }
}</programlisting>
</section>
<section id="rest-api-add-node-to-index">
<title>Add node to index</title>
<simpara>Associates a node with the given key/value pair in the given index.</simpara>
<note><simpara>Spaces in the URI have to be encoded as <literal>%20</literal>.</simpara></note>
<caution><simpara>This does <emphasis role="strong">not</emphasis> overwrite previous entries. If you index the
same key/value/item combination twice, two index entries are created. To
do update-type operations, you need to delete the old entry before adding
a new one.</simpara></caution>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/favorites</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "value" : "some value",
  "uri" : "http://localhost:7474/db/data/node/83",
  "key" : "some-key"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/index/node/favorites/some-key/some%20value/83</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "paged_traverse" : "http://localhost:7474/db/data/node/83/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "labels" : "http://localhost:7474/db/data/node/83/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/83/relationships/out",
  "traverse" : "http://localhost:7474/db/data/node/83/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/83/relationships/all/{-list|&amp;|types}",
  "all_relationships" : "http://localhost:7474/db/data/node/83/relationships/all",
  "property" : "http://localhost:7474/db/data/node/83/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/83",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/83/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/83/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/83/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/83/relationships/in/{-list|&amp;|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/83/relationships",
  "data" : {
  },
  "indexed" : "http://localhost:7474/db/data/index/node/favorites/some-key/some%20value/83"
}</programlisting>
</section>
<section id="rest-api-remove-all-entries-with-a-given-node-from-an-index">
<title>Remove all entries with a given node from an index</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/kvnode/88</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-remove-all-entries-with-a-given-node-and-key-from-an-index">
<title>Remove all entries with a given node and key from an index</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/kvnode/kvkey2/91</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-remove-all-entries-with-a-given-node" xreflabel="-key-and-value-from-an-index">
<title>Remove all entries with a given node, key and value from an index</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/kvnode/kvkey1/value1/84</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-find-node-by-exact-match">
<title>Find node by exact match</title>
<note><simpara>Spaces in the URI have to be encoded as <literal>%20</literal>.</simpara></note>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/favorites/key/the%2520value</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "indexed" : "http://localhost:7474/db/data/index/node/favorites/key/the%2520value/99",
  "labels" : "http://localhost:7474/db/data/node/99/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/99/relationships/out",
  "data" : {
  },
  "traverse" : "http://localhost:7474/db/data/node/99/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/99/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/99/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/99",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/99/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/99/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/99/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/99/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/99/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/99/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/99/relationships/in/{-list|&amp;|types}"
} ]</programlisting>
</section>
<section id="rest-api-find-node-by-query">
<title>Find node by query</title>
<simpara>The query language used here depends on what type of index you are
querying. The default index type is Lucene, in which case you should use
the Lucene query language here. Below an example of a fuzzy search over
multiple keys.</simpara>
<simpara>See: <ulink url="http://lucene.apache.org/core/3_6_2/queryparsersyntax.html">http://lucene.apache.org/core/3_6_2/queryparsersyntax.html</ulink></simpara>
<simpara>Getting the results with a predefined ordering requires adding the
parameter</simpara>
<simpara><literal>order=ordering</literal></simpara>
<simpara>where ordering is one of index, relevance or score. In this case an
additional field will be added to each result, named score, that holds
the float value that is the score reported by the query result.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/bobTheIndex?query=Name:Build~0.1%20AND%20Gender:Male</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "labels" : "http://localhost:7474/db/data/node/98/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/98/relationships/out",
  "data" : {
    "Name" : "Builder"
  },
  "traverse" : "http://localhost:7474/db/data/node/98/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/98/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/98/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/98",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/98/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/98/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/98/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/98/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/98/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/98/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/98/relationships/in/{-list|&amp;|types}"
} ]</programlisting>
</section>
</section>
<section id="rest-api-unique-indexes">
<title>Unique Indexing</title>
<note><simpara>As of Neo4j 2.0, unique constraints have been added.
These make Neo4j enforce the uniqueness, guaranteeing that uniqueness is maintained.
See <xref linkend="graphdb-neo4j-schema-constraints"/> for details about this.
For most cases, the unique constraints should be used rather than the features described below.</simpara></note>
<simpara>For uniqueness enforcements, there are two modes:</simpara>
<itemizedlist>
<listitem>
<simpara>
URL Parameter <literal>uniqueness=get_or_create</literal>: Create a new node/relationship and index it if no existing one can be found. If an existing node/relationship is found, discard the sent data and return the existing node/relationship.
</simpara>
</listitem>
<listitem>
<simpara>
URL Parameter <literal>uniqueness=create_or_fail</literal>: Create a new node/relationship if no existing one can be found in the index. If an existing node/relationship is found, return a conflict error.
</simpara>
</listitem>
</itemizedlist>
<simpara>For more information, see <xref linkend="transactions-unique-nodes"/>.</simpara>
<section id="rest-api-get-or-create-unique-node-create">
<title>Get or create unique node (create)</title>
<simpara>The node is created if it doesn&#8217;t exist in the unique index already.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/people?uniqueness=get_or_create</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "key" : "name",
  "value" : "Tobias",
  "properties" : {
    "name" : "Tobias",
    "sequence" : 1
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/index/node/people/name/Tobias/97</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "paged_traverse" : "http://localhost:7474/db/data/node/97/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "labels" : "http://localhost:7474/db/data/node/97/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/97/relationships/out",
  "traverse" : "http://localhost:7474/db/data/node/97/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/97/relationships/all/{-list|&amp;|types}",
  "all_relationships" : "http://localhost:7474/db/data/node/97/relationships/all",
  "property" : "http://localhost:7474/db/data/node/97/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/97",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/97/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/97/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/97/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/97/relationships/in/{-list|&amp;|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/97/relationships",
  "data" : {
    "sequence" : 1,
    "name" : "Tobias"
  },
  "indexed" : "http://localhost:7474/db/data/index/node/people/name/Tobias/97"
}</programlisting>
</section>
<section id="rest-api-get-or-create-unique-node-existing">
<title>Get or create unique node (existing)</title>
<simpara>Here,
a node is not created but the existing unique node returned, since another node
is indexed with the same data already. The node data returned is then that of the
already existing node.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/people?uniqueness=get_or_create</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "key" : "name",
  "value" : "Peter",
  "properties" : {
    "name" : "Peter",
    "sequence" : 2
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/index/node/people/name/Peter/87</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "paged_traverse" : "http://localhost:7474/db/data/node/87/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "labels" : "http://localhost:7474/db/data/node/87/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/87/relationships/out",
  "traverse" : "http://localhost:7474/db/data/node/87/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/87/relationships/all/{-list|&amp;|types}",
  "all_relationships" : "http://localhost:7474/db/data/node/87/relationships/all",
  "property" : "http://localhost:7474/db/data/node/87/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/87",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/87/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/87/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/87/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/87/relationships/in/{-list|&amp;|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/87/relationships",
  "data" : {
    "sequence" : 1,
    "name" : "Peter"
  },
  "indexed" : "http://localhost:7474/db/data/index/node/people/name/Peter/87"
}</programlisting>
</section>
<section id="rest-api-create-a-unique-node-or-return-fail-create">
<title>Create a unique node or return fail (create)</title>
<simpara>Here, in case
of an already existing node, an error should be returned. In this
example, no existing indexed node is found and a new node is created.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/people?uniqueness=create_or_fail</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "key" : "name",
  "value" : "Tobias",
  "properties" : {
    "name" : "Tobias",
    "sequence" : 1
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/index/node/people/name/Tobias/96</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "paged_traverse" : "http://localhost:7474/db/data/node/96/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "labels" : "http://localhost:7474/db/data/node/96/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/96/relationships/out",
  "traverse" : "http://localhost:7474/db/data/node/96/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/96/relationships/all/{-list|&amp;|types}",
  "all_relationships" : "http://localhost:7474/db/data/node/96/relationships/all",
  "property" : "http://localhost:7474/db/data/node/96/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/96",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/96/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/96/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/96/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/96/relationships/in/{-list|&amp;|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/96/relationships",
  "data" : {
    "sequence" : 1,
    "name" : "Tobias"
  },
  "indexed" : "http://localhost:7474/db/data/index/node/people/name/Tobias/96"
}</programlisting>
</section>
<section id="rest-api-create-a-unique-node-or-return-fail-fail">
<title>Create a unique node or return fail (fail)</title>
<simpara>Here, in case
of an already existing node, an error should be returned. In this
example, an existing node indexed with the same data
is found and an error is returned.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/people?uniqueness=create_or_fail</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "key" : "name",
  "value" : "Peter",
  "properties" : {
    "name" : "Peter",
    "sequence" : 2
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>409:</literal></emphasis> <literal>Conflict</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "paged_traverse" : "http://localhost:7474/db/data/node/81/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "labels" : "http://localhost:7474/db/data/node/81/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/81/relationships/out",
  "traverse" : "http://localhost:7474/db/data/node/81/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/81/relationships/all/{-list|&amp;|types}",
  "all_relationships" : "http://localhost:7474/db/data/node/81/relationships/all",
  "property" : "http://localhost:7474/db/data/node/81/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/81",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/81/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/81/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/81/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/81/relationships/in/{-list|&amp;|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/81/relationships",
  "data" : {
    "sequence" : 1,
    "name" : "Peter"
  },
  "indexed" : "http://localhost:7474/db/data/index/node/people/name/Peter/81"
}</programlisting>
</section>
<section id="rest-api-add-an-existing-node-to-unique-index-not-indexed">
<title>Add an existing node to unique index (not indexed)</title>
<simpara>Associates a node with the given key/value pair in the given unique
index.</simpara>
<simpara>In this example, we are using <literal>create_or_fail</literal> uniqueness.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/favorites?uniqueness=create_or_fail</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "value" : "some value",
  "uri" : "http://localhost:7474/db/data/node/92",
  "key" : "some-key"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/index/node/favorites/some-key/some%20value/92</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "paged_traverse" : "http://localhost:7474/db/data/node/92/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "labels" : "http://localhost:7474/db/data/node/92/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/92/relationships/out",
  "traverse" : "http://localhost:7474/db/data/node/92/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/92/relationships/all/{-list|&amp;|types}",
  "all_relationships" : "http://localhost:7474/db/data/node/92/relationships/all",
  "property" : "http://localhost:7474/db/data/node/92/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/92",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/92/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/92/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/92/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/92/relationships/in/{-list|&amp;|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/92/relationships",
  "data" : {
  },
  "indexed" : "http://localhost:7474/db/data/index/node/favorites/some-key/some%20value/92"
}</programlisting>
</section>
<section id="rest-api-add-an-existing-node-to-unique-index-already-indexed">
<title>Add an existing node to unique index (already indexed)</title>
<simpara>In this case, the node already exists in the index, and thus we get a <literal>HTTP 409</literal> status response,
as we have set the uniqueness to <literal>create_or_fail</literal>.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/favorites?uniqueness=create_or_fail</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "value" : "some value",
  "uri" : "http://localhost:7474/db/data/node/95",
  "key" : "some-key"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>409:</literal></emphasis> <literal>Conflict</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "paged_traverse" : "http://localhost:7474/db/data/node/94/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "labels" : "http://localhost:7474/db/data/node/94/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/94/relationships/out",
  "traverse" : "http://localhost:7474/db/data/node/94/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/94/relationships/all/{-list|&amp;|types}",
  "all_relationships" : "http://localhost:7474/db/data/node/94/relationships/all",
  "property" : "http://localhost:7474/db/data/node/94/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/94",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/94/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/94/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/94/relationships/in",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/94/relationships/in/{-list|&amp;|types}",
  "create_relationship" : "http://localhost:7474/db/data/node/94/relationships",
  "data" : {
    "some-key" : "some value"
  },
  "indexed" : "http://localhost:7474/db/data/index/node/favorites/some-key/some%20value/94"
}</programlisting>
</section>
<section id="rest-api-get-or-create-unique-relationship-create">
<title>Get or create unique relationship (create)</title>
<simpara>Create a unique relationship in an index.
If a relationship matching the given key and value already exists in the index, it will be returned.
If not, a new relationship will be created.</simpara>
<note><simpara>The type and direction of the relationship is not regarded when determining uniqueness.</simpara></note>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/relationship/MyIndex/?uniqueness=get_or_create</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "key" : "name",
  "value" : "Tobias",
  "start" : "http://localhost:7474/db/data/node/230",
  "end" : "http://localhost:7474/db/data/node/231",
  "type" : "knowledge"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/index/relationship/MyIndex/name/Tobias/169</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "start" : "http://localhost:7474/db/data/node/230",
  "property" : "http://localhost:7474/db/data/relationship/169/properties/{key}",
  "self" : "http://localhost:7474/db/data/relationship/169",
  "properties" : "http://localhost:7474/db/data/relationship/169/properties",
  "type" : "knowledge",
  "end" : "http://localhost:7474/db/data/node/231",
  "data" : {
    "name" : "Tobias"
  },
  "indexed" : "http://localhost:7474/db/data/index/relationship/MyIndex/name/Tobias/169"
}</programlisting>
</section>
<section id="rest-api-get-or-create-unique-relationship-existing">
<title>Get or create unique relationship (existing)</title>
<simpara>Here, in case
of an already existing relationship, the sent data is ignored and the
existing relationship returned.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/relationship/rels?uniqueness=get_or_create</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "key" : "name",
  "value" : "Peter",
  "start" : "http://localhost:7474/db/data/node/234",
  "end" : "http://localhost:7474/db/data/node/235",
  "type" : "KNOWS"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "start" : "http://localhost:7474/db/data/node/232",
  "property" : "http://localhost:7474/db/data/relationship/170/properties/{key}",
  "self" : "http://localhost:7474/db/data/relationship/170",
  "properties" : "http://localhost:7474/db/data/relationship/170/properties",
  "type" : "KNOWS",
  "end" : "http://localhost:7474/db/data/node/233",
  "data" : {
  },
  "indexed" : "http://localhost:7474/db/data/index/relationship/rels/name/Peter/170"
}</programlisting>
</section>
<section id="rest-api-create-a-unique-relationship-or-return-fail-create">
<title>Create a unique relationship or return fail (create)</title>
<simpara>Here, in case
of an already existing relationship, an error should be returned. In this
example, no existing relationship is found and a new relationship is created.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/relationship/rels?uniqueness=create_or_fail</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "key" : "name",
  "value" : "Tobias",
  "start" : "http://localhost:7474/db/data/node/242",
  "end" : "http://localhost:7474/db/data/node/243",
  "type" : "KNOWS"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/index/relationship/rels/name/Tobias/173</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "start" : "http://localhost:7474/db/data/node/242",
  "property" : "http://localhost:7474/db/data/relationship/173/properties/{key}",
  "self" : "http://localhost:7474/db/data/relationship/173",
  "properties" : "http://localhost:7474/db/data/relationship/173/properties",
  "type" : "KNOWS",
  "end" : "http://localhost:7474/db/data/node/243",
  "data" : {
    "name" : "Tobias"
  },
  "indexed" : "http://localhost:7474/db/data/index/relationship/rels/name/Tobias/173"
}</programlisting>
</section>
<section id="rest-api-create-a-unique-relationship-or-return-fail-fail">
<title>Create a unique relationship or return fail (fail)</title>
<simpara>Here, in case
of an already existing relationship, an error should be returned. In this
example, an existing relationship is found and an error is returned.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/relationship/rels?uniqueness=create_or_fail</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "key" : "name",
  "value" : "Peter",
  "start" : "http://localhost:7474/db/data/node/222",
  "end" : "http://localhost:7474/db/data/node/223",
  "type" : "KNOWS"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>409:</literal></emphasis> <literal>Conflict</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "start" : "http://localhost:7474/db/data/node/220",
  "property" : "http://localhost:7474/db/data/relationship/165/properties/{key}",
  "self" : "http://localhost:7474/db/data/relationship/165",
  "properties" : "http://localhost:7474/db/data/relationship/165/properties",
  "type" : "KNOWS",
  "end" : "http://localhost:7474/db/data/node/221",
  "data" : {
  },
  "indexed" : "http://localhost:7474/db/data/index/relationship/rels/name/Peter/165"
}</programlisting>
</section>
<section id="rest-api-add-an-existing-relationship-to-a-unique-index-not-indexed">
<title>Add an existing relationship to a unique index (not indexed)</title>
<simpara>If a relationship matching the given key and value already exists in the index, it will be returned.
If not, an <literal>HTTP 409</literal> (conflict) status will be returned in this case, as we are using <literal>create_or_fail</literal>.</simpara>
<simpara>It&#8217;s possible to use <literal>get_or_create</literal> uniqueness as well.</simpara>
<note><simpara>The type and direction of the relationship is not regarded when determining uniqueness.</simpara></note>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/relationship/rels?uniqueness=create_or_fail</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "key" : "name",
  "value" : "Peter",
  "uri" : "http://localhost:7474/db/data/relationship/164"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/index/relationship/rels/name/Peter/164</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "start" : "http://localhost:7474/db/data/node/218",
  "property" : "http://localhost:7474/db/data/relationship/164/properties/{key}",
  "self" : "http://localhost:7474/db/data/relationship/164",
  "properties" : "http://localhost:7474/db/data/relationship/164/properties",
  "type" : "KNOWS",
  "end" : "http://localhost:7474/db/data/node/219",
  "data" : {
  },
  "indexed" : "http://localhost:7474/db/data/index/relationship/rels/name/Peter/164"
}</programlisting>
</section>
<section id="rest-api-add-an-existing-relationship-to-a-unique-index-already-indexed">
<title>Add an existing relationship to a unique index (already indexed)</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/relationship/rels?uniqueness=create_or_fail</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "key" : "name",
  "value" : "Peter",
  "uri" : "http://localhost:7474/db/data/relationship/167"
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>409:</literal></emphasis> <literal>Conflict</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extensions" : {
  },
  "start" : "http://localhost:7474/db/data/node/224",
  "property" : "http://localhost:7474/db/data/relationship/166/properties/{key}",
  "self" : "http://localhost:7474/db/data/relationship/166",
  "properties" : "http://localhost:7474/db/data/relationship/166/properties",
  "type" : "KNOWS",
  "end" : "http://localhost:7474/db/data/node/225",
  "data" : {
  },
  "indexed" : "http://localhost:7474/db/data/index/relationship/rels/name/Peter/166"
}</programlisting>
</section>
</section>
<section id="rest-api-auto-indexes">
<title>Legacy Automatic Indexes</title>
<simpara>To enable automatic indexes, set up the database for that, see <xref linkend="auto-indexing-config"/>. With this feature enabled, you can then index and query nodes in these indexes.</simpara>
<section id="rest-api-find-node-by-exact-match-from-an-automatic-index">
<title>Find node by exact match from an automatic index</title>
<simpara>Automatic index nodes can be found via exact lookups with normal Index
REST syntax.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/index/auto/node/name/I</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "labels" : "http://localhost:7474/db/data/node/9/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/9/relationships/out",
  "data" : {
    "name" : "I"
  },
  "traverse" : "http://localhost:7474/db/data/node/9/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/9/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/9/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/9",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/9/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/9/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/9/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/9/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/9/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/9/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/9/relationships/in/{-list|&amp;|types}"
} ]</programlisting>
</section>
<section id="rest-api-find-node-by-query-from-an-automatic-index">
<title>Find node by query from an automatic index</title>
<simpara>See Find node by query for the actual query syntax.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/index/auto/node/?query=name:I</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ {
  "labels" : "http://localhost:7474/db/data/node/0/labels",
  "outgoing_relationships" : "http://localhost:7474/db/data/node/0/relationships/out",
  "data" : {
    "name" : "I"
  },
  "traverse" : "http://localhost:7474/db/data/node/0/traverse/{returnType}",
  "all_typed_relationships" : "http://localhost:7474/db/data/node/0/relationships/all/{-list|&amp;|types}",
  "property" : "http://localhost:7474/db/data/node/0/properties/{key}",
  "self" : "http://localhost:7474/db/data/node/0",
  "outgoing_typed_relationships" : "http://localhost:7474/db/data/node/0/relationships/out/{-list|&amp;|types}",
  "properties" : "http://localhost:7474/db/data/node/0/properties",
  "incoming_relationships" : "http://localhost:7474/db/data/node/0/relationships/in",
  "extensions" : {
  },
  "create_relationship" : "http://localhost:7474/db/data/node/0/relationships",
  "paged_traverse" : "http://localhost:7474/db/data/node/0/paged/traverse/{returnType}{?pageSize,leaseTime}",
  "all_relationships" : "http://localhost:7474/db/data/node/0/relationships/all",
  "incoming_typed_relationships" : "http://localhost:7474/db/data/node/0/relationships/in/{-list|&amp;|types}"
} ]</programlisting>
</section>
</section>
<section id="rest-api-configurable-auto-indexes">
<title>Configurable Legacy Automatic Indexing</title>
<simpara>Out of the box auto-indexing supports exact matches since they are created with the default configuration (see <xref linkend="auto-indexing"/>) the first time you access them. However it is possible to intervene in the lifecycle of the server before any auto indexes are created to change their configuration.</simpara>
<warning><simpara>This approach <emphasis>cannot</emphasis> be used on databases that already have auto-indexes established. To change the auto-index configuration existing indexes would have to be deleted first, so be careful!</simpara></warning>
<caution><simpara>This technique works, but it is not particularly pleasant. Future versions of Neo4j may remove this loophole in favour of a better structured feature for managing auto-indexing configurations.</simpara></caution>
<simpara>Auto-indexing must be enabled through configuration before we can create or configure them. Firstly ensure that you&#8217;ve added some config like this into your server&#8217;s <literal>neo4j.properties</literal> file:</simpara>
<programlisting language="plain" linenumbering="unnumbered">node_auto_indexing=true
relationship_auto_indexing=true
node_keys_indexable=name,phone
relationship_keys_indexable=since</programlisting>
<simpara>The <literal>node_auto_indexing</literal> and <literal>relationship_auto_indexing</literal> settings turn auto-indexing on for nodes and relationships respectively. The <literal>node_keys_indexable</literal> key allows you to specify a comma-separated list of node property keys to be indexed. The <literal>relationship_keys_indexable</literal> does the same for relationship property keys.</simpara>
<simpara>Next start the server as usual by invoking the start script as described in <xref linkend="server-installation"/>.</simpara>
<simpara>Next we have to pre-empt the creation of an auto-index, by telling the server to create an apparently manual index which has the same name as the node (or relationship) auto-index. For example, in this case we&#8217;ll create a node auto index whose name is <literal>node_auto_index</literal>, like so:</simpara>
<section id="rest-api-create-an-auto-index-for-nodes-with-specific-configuration">
<title>Create an auto index for nodes with specific configuration</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/node/</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "name" : "node_auto_index",
  "config" : {
    "type" : "fulltext",
    "provider" : "lucene"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/index/node/node_auto_index/</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "template" : "http://localhost:7474/db/data/index/node/node_auto_index/{key}/{value}",
  "type" : "fulltext",
  "provider" : "lucene"
}</programlisting>
<simpara>If you require configured auto-indexes for relationships, the approach is similar:</simpara>
</section>
<section id="rest-api-create-an-auto-index-for-relationships-with-specific-configuration">
<title>Create an auto index for relationships with specific configuration</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/relationship/</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "name" : "relationship_auto_index",
  "config" : {
    "type" : "fulltext",
    "provider" : "lucene"
  }
}</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>201:</literal></emphasis> <literal>Created</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Location:</literal></emphasis> <literal>http://localhost:7474/db/data/index/relationship/relationship_auto_index/</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">{
  "template" : "http://localhost:7474/db/data/index/relationship/relationship_auto_index/{key}/{value}",
  "type" : "fulltext",
  "provider" : "lucene"
}</programlisting>
<simpara>In case you&#8217;re curious how this works, on the server side it triggers the creation of an index which happens to have the same name as the auto index that the database would create for itself. Now when we interact with the database, the index thinks the index is already created so the state machine skips over that step and just gets on with normal day-to-day auto-indexing.</simpara>
<caution><simpara>You have to do this early in your server lifecycle, before any normal auto indexes are created.</simpara></caution>
<simpara>There are a few REST calls providing a REST interface to the <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/AutoIndexer.html">AutoIndexer</ulink> component. The following REST calls work both, for <literal>node</literal> and <literal>relationship</literal> by simply changing the respective part of the URL.</simpara>
</section>
<section id="rest-api-get-current-status-for-autoindexing-on-nodes">
<title>Get current status for autoindexing on nodes</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/index/auto/node/status</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">false</programlisting>
</section>
<section id="rest-api-enable-node-autoindexing">
<title>Enable node autoindexing</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>PUT</literal></emphasis>  <literal>http://localhost:7474/db/data/index/auto/node/status</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">true</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-lookup-list-of-properties-being-autoindexed">
<title>Lookup list of properties being autoindexed</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/db/data/index/auto/node/properties</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>200:</literal></emphasis> <literal>OK</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">[ "some-property" ]</programlisting>
</section>
<section id="rest-api-add-a-property-for-autoindexing-on-nodes">
<title>Add a property for autoindexing on nodes</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/index/auto/node/properties</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Content-Type:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered">myProperty1</programlisting>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="rest-api-remove-a-property-for-autoindexing-on-nodes">
<title>Remove a property for autoindexing on nodes</title>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>DELETE</literal></emphasis>  <literal>http://localhost:7474/db/data/index/auto/node/properties/myProperty1</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>204:</literal></emphasis> <literal>No Content</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
</section>
<section id="rest-api-wadl-support">
<title>WADL Support</title>
<simpara>The Neo4j REST API is a truly RESTful interface relying on hypermedia controls (links) to advertise permissible
actions to users. Hypermedia is a dynamic interface style where declarative constructs (semantic markup) are used
to inform clients of their next legal choices just in time.</simpara>
<caution><simpara>RESTful APIs cannot be modeled by static interface description languages like WSDL or WADL.</simpara></caution>
<simpara>However for some use cases, developers may wish to expose WADL descriptions of the Neo4j REST API, particularly when
using tooling that expects such.</simpara>
<simpara>In those cases WADL generation may be enabled by adding to your server&#8217;s <literal>neo4j.properties</literal> file:</simpara>
<programlisting language="plain" linenumbering="unnumbered">unsupported_wadl_generation_enabled=true</programlisting>
<caution><simpara>WADL is not an officially supported part of the Neo4j server API because WADL is insufficiently expressive to capture
the set of potential interactions a client can drive with Neo4j server. Expect the WADL description to be incomplete,
and in some cases contradictory to the real API. In any cases where the WADL description disagrees with the REST API,
the REST API should be considered authoritative. WADL generation may be withdrawn at any point in the Neo4j release
cycle.</simpara></caution>
</section>
</chapter>
<chapter id="deprecations">
<title>Deprecations</title>
<simpara>This section outlines deprecations in Neo4j 2.0 or earlier in order to help you find a smoother transition path to future releases.</simpara>
<variablelist>
<varlistentry>
<term>
Graph Matching
</term>
<listitem>
<simpara>
The graph-matching component will be removed in future releases.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</chapter>
</part>
<part id="operations">
<title>Operations</title>
<partintro>
<simpara>This part describes how to install and maintain a Neo4j installation.
This includes topics such as backing up the database and monitoring the health of the database as well as diagnosing issues.</simpara>
</partintro>
<chapter id="deployment">
<title>Installation &amp; Deployment</title>
<simpara>Neo4j is accessed as a standalone server, either directly through a REST interface or through a language-specific driver.</simpara>
<simpara>Neo4j can be installed as a server, running either as a headless application or system service.
For information on installing The Neo4j Server, see <xref linkend="server-installation"/>.</simpara>
<simpara>For running Neo4j in high availability mode, see <xref linkend="ha"/>.</simpara>
<section id="deployment-requirements">
<title>System Requirements</title>
<simpara>Memory constrains graph size, disk I/O constrains read/write performance, as always.</simpara>
<section id="_cpu">
<title>CPU</title>
<simpara>Performance is generally memory or I/O bound for large graphs, and compute bound for graphs which fit in memory.</simpara>
<variablelist>
<varlistentry>
<term>
Minimum
</term>
<listitem>
<simpara>
Intel Core i3
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Recommended
</term>
<listitem>
<simpara>
Intel Core i7
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_memory">
<title>Memory</title>
<simpara>More memory allows even larger graphs, but runs the risk of inducing larger Garbage Collection operations.</simpara>
<variablelist>
<varlistentry>
<term>
Minimum
</term>
<listitem>
<simpara>
2GB
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Recommended
</term>
<listitem>
<simpara>
16&#8212;32GB or more
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_disk">
<title>Disk</title>
<simpara>Aside from capacity, the performance characteristics of the disk are the most important when selecting storage.</simpara>
<variablelist>
<varlistentry>
<term>
Minimum
</term>
<listitem>
<simpara>
10GB SATA
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Recommended
</term>
<listitem>
<simpara>
SSD w/ SATA
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_filesystem">
<title>Filesystem</title>
<simpara>For proper ACID behavior, the filesystem must support flush (fsync, fdatasync).</simpara>
<variablelist>
<varlistentry>
<term>
Minimum
</term>
<listitem>
<simpara>
ext4 (or similar)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Recommended
</term>
<listitem>
<simpara>
ext4, ZFS
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_software">
<title>Software</title>
<simpara>Neo4j is Java-based.</simpara>
<variablelist>
<varlistentry>
<term>
Java
</term>
<listitem>
<simpara>
<ulink url="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle Java 7</ulink>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Operating Systems
</term>
<listitem>
<simpara>
Linux, HP UX, Windows 2008 for production; additionally Windows XP, Mac OS X for development.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="server-installation">
<title>Server Installation</title>
<section id="_deployment_scenarios">
<title>Deployment Scenarios</title>
<simpara>As a developer, you may wish to download Neo4j and run it locally on your desktop computer.
We recommend this as an easy way to discover Neo4j.</simpara>
<itemizedlist>
<listitem>
<simpara>
For Windows, see <xref linkend="windows-install"/>.
</simpara>
</listitem>
<listitem>
<simpara>
For Unix/Linux, see <xref linkend="linux-install"/>.
</simpara>
</listitem>
<listitem>
<simpara>
For OSX, see <xref linkend="osx-install"/>.
</simpara>
</listitem>
</itemizedlist>
<simpara>As a systems administrator, you may wish to install Neo4j using a packaging system so you can ensure that a cluster of machines have identical installs.
See <xref linkend="linux-packages"/> for more information on this.</simpara>
<simpara>For information on High Availability, please refer to <xref linkend="ha"/>.</simpara>
</section>
<section id="_prerequisites">
<title>Prerequisites</title>
<simpara>With the exception of our Windows Installer, you&#8217;ll need a Java Virtual Machine installed on your computer.
We recommend that you install the Java JDK 7 from the <ulink url="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle Website</ulink>.</simpara>
</section>
<section id="windows-install">
<title>Windows</title>
<section id="windows-installer">
<title>Windows Installer</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Download the version that you want from <ulink url="http://www.neo4j.org/download">http://www.neo4j.org/download</ulink>.
</simpara>
<itemizedlist>
<listitem>
<simpara>
Select the appropriate version and architecture for your platform.
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Double-click the downloaded installer file.
</simpara>
</listitem>
<listitem>
<simpara>
Follow the prompts.
</simpara>
</listitem>
</orderedlist>
<note><simpara>The installer will prompt to be granted Administrator privileges.
Newer versions of Windows come with a SmartScreen feature that may prevent the installer from running&#8201;&#8212;&#8201;you can make it run anyway by clicking "More info" on the "Windows protected your PC" screen.</simpara></note>
</section>
<section id="windows-console">
<title>Windows Console Application</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Download the latest release from <ulink url="http://www.neo4j.org/download">http://www.neo4j.org/download</ulink>.
</simpara>
<itemizedlist>
<listitem>
<simpara>
Select the appropriate Zip distribution.
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Right-click the downloaded file, click Extract All.
</simpara>
<itemizedlist>
<listitem>
<simpara>
Refer to the top-level extracted directory as: <literal>NEO4J_HOME</literal>
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Double-click on <emphasis>%NEO4J_HOME%\bin\Neo4j.bat</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
Stop the server by typing Ctrl-C in the console that got opened.
</simpara>
</listitem>
</orderedlist>
</section>
<section id="_as_a_windows_service">
<title>As a Windows service</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Download the latest release from <ulink url="http://www.neo4j.org/download">http://www.neo4j.org/download</ulink>.
</simpara>
<itemizedlist>
<listitem>
<simpara>
Select the appropriate Zip distribution.
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Right-click the downloaded file, click Extract All.
</simpara>
<itemizedlist>
<listitem>
<simpara>
Refer to the top-level extracted directory as: <literal>NEO4J_HOME</literal>
</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>With administrative rights, Neo4j can be installed as a Windows service.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Click Start &#8594; All Programs &#8594; Accessories.
</simpara>
</listitem>
<listitem>
<simpara>
Right click Command Prompt &#8594; Run as Administrator.
</simpara>
</listitem>
<listitem>
<simpara>
Provide authorization and/or the Administrator password.
</simpara>
</listitem>
<listitem>
<simpara>
Navigate to: <literal>%NEO4J_HOME%</literal>
</simpara>
</listitem>
<listitem>
<simpara>
Run: <literal>bin\Neo4jInstaller.bat install</literal>
</simpara>
</listitem>
</orderedlist>
<simpara>To uninstall, run <literal>bin\Neo4jInstaller.bat remove</literal> as Administrator.</simpara>
<simpara>To query the status of the service, run: <literal>bin\Neo4jInstaller.bat status</literal></simpara>
<simpara>To start the service from the command prompt, run: <literal>sc start Neo4j-Server</literal></simpara>
<simpara>To stop the service from the command prompt, run: <literal>sc stop Neo4j-Server</literal></simpara>
<simpara>You can also start and stop Neo4j from the Windows Service Manager.</simpara>
<note><simpara>Some users have reported problems on Windows when using the ZoneAlarm firewall.
If you are having problems getting large responses from the server, or if the web interface does not work, try disabling ZoneAlarm.
Contact ZoneAlarm support to get information on how to resolve this.</simpara></note>
</section>
</section>
<section id="linux-install">
<title>Linux</title>
<section id="linux-packages">
<title>Linux Packages</title>
<simpara>For Debian packages, see the instructions at  <ulink url="http://debian.neo4j.org">http://debian.neo4j.org</ulink>.</simpara>
</section>
<section id="unix-console">
<title>Unix Console Application</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Download the latest release from <ulink url="http://www.neo4j.org/download">http://www.neo4j.org/download</ulink>.
</simpara>
<itemizedlist>
<listitem>
<simpara>
Select the appropriate tar.gz distribution for your platform.
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Extract the contents of the archive, using: <literal>tar -cf &lt;filename&gt;</literal>
</simpara>
<itemizedlist>
<listitem>
<simpara>
Refer to the top-level extracted directory as: <literal>NEO4J_HOME</literal>
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Change directory to: <literal>$NEO4J_HOME</literal>
</simpara>
<itemizedlist>
<listitem>
<simpara>
Run: <literal>./bin/neo4j console</literal>
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Stop the server by typing Ctrl-C in the console.
</simpara>
</listitem>
</orderedlist>
</section>
<section id="_linux_service">
<title>Linux Service</title>
<simpara>Neo4j can participate in the normal system startup and shutdown process.
The following procedure should work on most popular Linux distributions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<literal>cd $NEO4J_HOME</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>sudo ./bin/neo4j-installer install</literal>
</simpara>
<simpara>If asked, enter your password to gain super-user privileges.</simpara>
</listitem>
<listitem>
<simpara>
<literal>sudo service neo4j-service status</literal>
</simpara>
<simpara>This should indicate that the server is not running.</simpara>
</listitem>
<listitem>
<simpara>
<literal>sudo service neo4j-service start</literal>
</simpara>
<simpara>This will start the server.</simpara>
</listitem>
<listitem>
<simpara>
<literal>sudo service neo4j-service stop</literal>
</simpara>
<simpara>This will stop the server.</simpara>
</listitem>
</orderedlist>
<simpara>During installation you will be given the option to select the user Neo4j will run as.
You will be asked to supply a username (defaulting to <literal>neo4j</literal>) and if that user is not present on the system it will be created as a system account and the <emphasis>$NEO4J_HOME/data</emphasis> directory will be <literal>chown</literal>'ed to that user.</simpara>
<simpara>You are encouraged to create a dedicated user for running the service and for that reason it is suggested that you unpack the distribution package under <emphasis>/opt</emphasis> or your site specific optional packages directory.</simpara>
<simpara>After installation you may have to do some platform specific configuration and performance tuning.
For that, refer to <xref linkend="linux-performance-guide"/>.</simpara>
<simpara>To remove the server from the set of startup services, the proper commands are:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<literal>cd $NEO4J_HOME</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>sudo ./bin/neo4j-installer remove</literal>
</simpara>
</listitem>
</orderedlist>
<simpara>This will stop the server, if running, and remove it.</simpara>
<simpara>Note that if you chose to create a new user account, on uninstall you will be prompted to remove it from the system.</simpara>
<note><simpara>This approach to running Neo4j as a server is deprecated.
We strongly advise you to run Neo4j from a package where feasible.</simpara></note>
<simpara>You can alternatively build your own init.d script. See for instance the Linux Standard Base specification on <ulink url="http://refspecs.linuxfoundation.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/tocsysinit.html">system initialization</ulink>, or one of the many <ulink url="https://gist.github.com/chrisvest/7673244">samples</ulink> and <ulink url="http://www.linux.com/learn/tutorials/442412-managing-linux-daemons-with-init-scripts">tutorials</ulink>.</simpara>
</section>
</section>
<section id="osx-install">
<title>Mac OSX</title>
<section id="_osx_via_homebrew">
<title>OSX via Homebrew</title>
<simpara>Using Homebrew (see <ulink url="http://brew.sh/">http://brew.sh/</ulink>), to install the latest stable version of Neo4j Server, issue the following command:</simpara>
<programlisting language="shell" linenumbering="unnumbered">brew install neo4j &amp;&amp; neo4j start</programlisting>
<simpara>This will get a Neo4j instance running on <ulink url="http://localhost:7474">http://localhost:7474</ulink>.
The installation files will reside in <literal>ls /usr/local/Cellar/neo4j/community-{NEO4J_VERSION}/libexec/</literal>&#8201;&#8212;&#8201;to tweak settings and symlink the database directory if desired.</simpara>
<simpara>After the installation, Neo4j can run either as a service or from a terminal.</simpara>
</section>
<section id="_running_neo4j_from_the_terminal">
<title>Running Neo4j from the Terminal</title>
<simpara>The server can be started in the background from the terminal with the command <literal>neo4j start</literal>, and then stopped again with <literal>neo4j stop</literal>.
The server can also be started in the foreground with <literal>neo4j console</literal>&#8201;&#8212;&#8201;then it&#8217;s log output will be printed to the terminal.</simpara>
<simpara>The <literal>neo4j-shell</literal> command can be used to interact with Neo4j from the command line using Cypher. It will automatically connect to any
server that is running on localhost with the default port, otherwise it will show a help message. You can alternatively start the
shell with an embedded Neo4j instance, by using the <literal>-path path/to/data</literal> argument&#8201;&#8212;&#8201;note that only a single instance of Neo4j
can access the database files at a time.</simpara>
</section>
<section id="_osx_service">
<title>OSX Service</title>
<simpara>Neo4j can be installed as a Mac launchd job:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<literal>cd $NEO4J_HOME</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>./bin/neo4j-installer install</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>launchctl list | grep neo</literal>
</simpara>
<simpara>This should reveal the launchd "org.neo4j.server.7474" job for running the Neo4j Server.</simpara>
</listitem>
<listitem>
<simpara>
<literal>launchctl list | grep neo4j</literal>
</simpara>
<simpara>This should indicate that the server is running.</simpara>
</listitem>
<listitem>
<simpara>
<literal>launchctl stop org.neo4j.server</literal>
</simpara>
<simpara>This should stop the server.</simpara>
</listitem>
<listitem>
<simpara>
<literal>launchctl start org.neo4j.server</literal>
</simpara>
<simpara>This should start the server again.</simpara>
</listitem>
</orderedlist>
<simpara>To remove the launchctl service, issue the following command:</simpara>
<simpara><literal>./bin/neo4j-installer remove</literal></simpara>
</section>
<section id="_a_note_on_java_on_os_x_mavericks">
<title>A note on Java on OS X Mavericks</title>
<simpara>Unlike previous versions, OS X Mavericks does not come with Java pre-installed. You might encounter that the first time you run Neo4j, where OS X will trigger a popup offering you to install Java SE 6.</simpara>
<simpara>Java SE 6 is incompatible with Neo4j 2.0, so we strongly advise you to skip installing Java SE 6 if you have no other uses for it. Instead, for Neo4j 2.0 we recommend you install Java SE 7 from Oracle (<ulink url="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</ulink>) as that is what we support for production use.</simpara>
</section>
</section>
<section id="_multiple_server_instances_on_one_machine">
<title>Multiple Server instances on one machine</title>
<simpara>Neo4j can be set up to run as several instances on one machine, providing for instance several databases for development.</simpara>
<simpara>For how to set this up, see <xref linkend="ha-local-cluster"/>.
Just use the Neo4j edition of your choice, follow the guide and remember to not set the servers to run in HA mode.</simpara>
</section>
</section>
<section id="server-installation-cloud">
<title>Server Installation in the Cloud</title>
<simpara>Neo4j can be hosted on various cloud services.
See <ulink url="http://www.neo4j.org/develop/cloud">http://www.neo4j.org/develop/cloud</ulink> for more information.</simpara>
</section>
<section id="deployment-upgrading">
<title>Upgrading</title>
<simpara>A database can be upgraded from a minor version to the next, e.g. 1.1 &#8594; 1.2, and 1.2 &#8594; 1.3,
but you can not jump directly from 1.1 &#8594; 1.3. For version 1.8 in particular, it is possible to
upgrade directly from version 1.5.3 and later, as an explicit upgrade.
The upgrade process is a one way step; databases cannot be downgraded.</simpara>
<simpara>For most upgrades, only small changes are required to the database store, and these changes proceed
automatically when you start up the database using the newer version of Neo4j.</simpara>
<simpara>However, some upgrades require more significant changes to the database store.
In these cases, Neo4j will refuse to start without explicit configuration to allow the upgrade.</simpara>
<simpara>The table below lists recent Neo4j versions, and the type of upgrade required.</simpara>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>Upgrade process for Neo4j version</title>
<?dbhtml table-width="50%"?>
<?dbfo table-width="50%"?>
<?dblatex table-width="50%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="71*"/>
<colspec colname="col_2" colwidth="71*"/>
<colspec colname="col_3" colwidth="71*"/>
<thead>
<row>
<entry align="left" valign="top">From Version</entry>
<entry align="left" valign="top">To Version</entry>
<entry align="left" valign="top">Upgrade Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1.3</simpara></entry>
<entry align="left" valign="top"><simpara>1.4</simpara></entry>
<entry align="left" valign="top"><simpara>Automatic</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1.4</simpara></entry>
<entry align="left" valign="top"><simpara>1.5</simpara></entry>
<entry align="left" valign="top"><simpara>Explicit</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1.5</simpara></entry>
<entry align="left" valign="top"><simpara>1.6</simpara></entry>
<entry align="left" valign="top"><simpara>Explicit</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1.6</simpara></entry>
<entry align="left" valign="top"><simpara>1.7</simpara></entry>
<entry align="left" valign="top"><simpara>Automatic</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1.7</simpara></entry>
<entry align="left" valign="top"><simpara>1.8</simpara></entry>
<entry align="left" valign="top"><simpara>Automatic</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1.8</simpara></entry>
<entry align="left" valign="top"><simpara>1.9</simpara></entry>
<entry align="left" valign="top"><simpara>Automatic</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1.9</simpara></entry>
<entry align="left" valign="top"><simpara>2.0</simpara></entry>
<entry align="left" valign="top"><simpara>Explicit</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note><simpara>Downgrade is supported only between versions which do not have incompatible store layouts.
That means that if you did an upgrade where you didn&#8217;t have to explicitly set the <literal>allow_store_upgrade</literal> flag to false then you can downgrade without any problems to the previous version used.
Otherwise downgrading is not supported.
In any case, downgrading currently cannot be done in a rolling fashion, even in HA deployments.
Instead, the whole cluster must be shutdown and each machine downgraded individually and then the service can be resumed.</simpara></note>
<section id="_automatic_upgrade">
<title>Automatic Upgrade</title>
<simpara>To perform a normal upgrade (for minor changes to the database store):</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Download the newer version of Neo4j.
</simpara>
</listitem>
<listitem>
<simpara>
Cleanly shut down the database to upgrade, if it is running.
</simpara>
</listitem>
<listitem>
<simpara>
Startup the database with the newer version of Neo4j.
</simpara>
</listitem>
<listitem>
<simpara>
The upgrade will happen during startup and the process is done when the database has been successfully started.
</simpara>
</listitem>
</orderedlist>
</section>
<section id="explicit-upgrade">
<title>Explicit Upgrade</title>
<simpara>To perform a special upgrade (for significant changes to the database store):</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Download the newer version of Neo4j.
</simpara>
</listitem>
<listitem>
<simpara>
Cleanly shut down the database to upgrade, if it is running.
</simpara>
</listitem>
<listitem>
<simpara>
Set the Neo4j configuration parameter <literal>allow_store_upgrade=true</literal> in your <emphasis>neo4j.properties</emphasis> or embedded configuration.
</simpara>
</listitem>
<listitem>
<simpara>
Startup the database with the newer version of Neo4j.
</simpara>
</listitem>
<listitem>
<simpara>
The upgrade will happen during startup and the process is done when the database has been successfully started.
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>allow_store_upgrade</literal> configuration parameter should be removed, set to <literal>false</literal> or commented out.
</simpara>
</listitem>
<listitem>
<simpara>
Information about the upgrade and progress indicator is printed in <emphasis>messages.log</emphasis>.
</simpara>
</listitem>
</orderedlist>
</section>
<section id="deployment-upgrading-two-zero">
<title>Upgrade 1.9 &#8594; 2.0</title>
<simpara>This edition adds a new store for labels and one for schema, an index for labels, and also the format of the node store has changed.
Note that we do not currently support rolling upgrades between 1.9.x and 2.0.</simpara>
<simpara>For Neo4j 2.0, Java 7 is required.
We recommend that you install the Java JDK 7 from the <ulink url="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle Website</ulink>.</simpara>
<simpara>When upgrading, the following will happen and will both take some time, and will require extra disk space:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
A new, empty schema store will be created.
</simpara>
</listitem>
<listitem>
<simpara>
A new, empty label store will be created.
</simpara>
</listitem>
<listitem>
<simpara>
A new, empty label scan index will be created.
</simpara>
</listitem>
<listitem>
<simpara>
The node store will be converted, we need to enlarge each record to make space for labels&#8201;&#8212;&#8201;this will take time depending on the size of your database.
</simpara>
</listitem>
</orderedlist>
<section id="_cypher_compatibility">
<title>Cypher compatibility</title>
<simpara>Unless you set the statements to still use Cypher 1.9, they have to be updated for the following changes:</simpara>
<variablelist>
<varlistentry>
<term>
Pattern syntax
</term>
<listitem>
<simpara>
Parentheses are required around node patterns when labels are used.
This means that when adding labels to a pattern like <literal>a--&gt;b</literal> you should use something like <literal>(a:Person)--&gt;(b:Company)</literal>.
It&#8217;s good practice to use parentheses in node patterns even where they are not strictly required, to enhance readability.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Optional relationships
</term>
<listitem>
<simpara>
The syntax <literal>(a)-[?]-&gt;(x)</literal> for optional relationships has been removed.
Use <literal>OPTIONAL MATCH</literal> instead (see the corresponding chapter in the Neo4j Manual).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
The <literal>!</literal> and <literal>?</literal> property operators
</term>
<listitem>
<simpara>
Expressions like <literal>node.property = "value"</literal> will not fail when a node without the property is encountered, and will instead return <literal>NULL</literal>.
This is the same behavior as <literal>node.property! = "value"</literal> in Cypher 1.9.
The <literal>!</literal> property operator has been removed in 2.0.
Support for expressions using the <literal>?</literal> property operator, such as <literal>node.property? = "value"</literal>, have also been removed.
You can use <literal>not(has(node.property)) OR node.property = "value"</literal> instead, which is compatible with both 1.9 and 2.0.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>
<literal>CREATE</literal> syntax
</term>
<listitem>
<simpara>
The <literal>CREATE a={foo:’bar’}</literal> syntax has been removed.
Instead, use <literal>CREATE (a {foo:’bar’})</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Using <literal>DELETE</literal> to remove properties
</term>
<listitem>
<simpara>
The <literal>DELETE a.prop</literal> syntax has been removed.
Instead, use <literal>REMOVE a.prop</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Using parameters for index keys
</term>
<listitem>
<simpara>
Parameters can not be used as the key in <literal>START</literal> clauses using indexes (for example <literal>START n=node:index({key}='value')</literal>).
Use the literal key names instead.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Using parameters to identify nodes in patterns
</term>
<listitem>
<simpara>
Parameters can not be used to identify nodes in a pattern (ie. <literal>MATCH ({node})--&gt;(other))</literal>).
Note that this form was only possible when mixing the embedded Java API and Cypher, and thus does not affect users of Neo4j Server.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Iteration syntax in <literal>FOREACH</literal>, <literal>EXTRACT</literal>, etc
</term>
<listitem>
<simpara>
The iterating functions use a <literal>|</literal> instead of a <literal>:</literal> to separate the components of the statement.
For example, <literal>EXTRACT(n in ns : n.prop)</literal> is replaced with <literal>EXTRACT(n in ns | n.prop)</literal>.
The iterating functions include <literal>FOREACH</literal>, <literal>EXTRACT</literal>, <literal>REDUCE</literal>, <literal>ANY</literal>, <literal>ALL</literal>, <literal>SINGLE</literal> and <literal>NONE</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Alternative <literal>WITH</literal> syntax
</term>
<listitem>
<simpara>
The alternative <literal>WITH</literal> syntax, <literal>=== &lt;identifiers&gt; ===</literal>, has been removed.
Use the <literal>WITH</literal> keyword instead.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
The Reference Node
</term>
<listitem>
<simpara>
With the introduction of Labels in Neo4j 2.0 the Reference Node has become obsolete and has been removed.
Instead, labeled nodes has become the well-known starting points in your graph.
You can use a pattern like this to access a reference node:
<literal>MATCH (ref:MyReference) RETURN ref</literal>.
Simply use one label per such starting point you want to use.
<emphasis>Note that this should be executed once during application initialization, to ensure that only a single reference node is created per label.</emphasis>
When migrating a database with an existing reference node, add a label to it during migration, and then use it as per the previous pattern.
This is how to add the label: <literal>START ref=node(0) SET ref:MyReference</literal>.
In case you have altered the database so a different node is the reference node, substitute the node id in the statement.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_embedded_java_api">
<title>Embedded Java API</title>
<variablelist>
<varlistentry>
<term>
Mandatory Transactions
</term>
<listitem>
<simpara>
Transactions are now mandatory for read operations as well.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
The Reference Node
</term>
<listitem>
<simpara>
See the Cypher section above as well as the JavaDoc on <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/class-use/Label.html">Label</ulink>.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_other_significant_changes">
<title>Other significant changes</title>
<variablelist>
<varlistentry>
<term>
Plugins
</term>
<listitem>
<simpara>
Plugins are no longer distributed with Neo4j.
Please see individual maintainers about availability.
For instance, the source for the Gremlin plugin will be available at: <ulink url="https://github.com/neo4j-contrib/gremlin-plugin">https://github.com/neo4j-contrib/gremlin-plugin</ulink>
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="deployment-upgrading-one-nine">
<title>Upgrade 1.8 &#8594; 1.9</title>
<simpara>There are no store format changes between these versions so upgrading standalone instances simply consists of starting the database with the newer version.
In the case of High Availability (HA) installations, the communication protocol and the master election algorithm have changed and a new "rolling upgrade"
feature has been added, removing the need to shut down the entire cluster. For more information, refer to the "Upgrading a Neo4j HA Cluster" chapter
of the HA section of the Neo4j manual.</simpara>
</section>
<section id="deployment-upgrading-one-eight">
<title>Upgrade 1.7 &#8594; 1.8</title>
<simpara>There are no store format changes between these versions so upgrading standalone instances simply consists of starting the database with the newer version.
In the case of High Availability (HA) installations, the communication protocol and the master election algorithm have changed and a new "rolling upgrade"
feature has been added, removing the need to shut down the entire cluster. For more information, refer to the "Upgrading a Neo4j HA Cluster" chapter
of the HA section of the Neo4j manual.</simpara>
</section>
<section id="deployment-upgrading-one-seven">
<title>Upgrade 1.6 &#8594; 1.7</title>
<simpara>There are no store format changes between these versions, which means there is no particular procedure you need to upgrade a single instance.</simpara>
<simpara>In an HA environment these steps need to be performed:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
shut down all the databases in the cluster
</simpara>
</listitem>
<listitem>
<simpara>
shut down the ZooKeeper cluster and clear the <emphasis>version-2</emphasis> directories on all the ZooKeeper instances
</simpara>
</listitem>
<listitem>
<simpara>
start the ZooKeeper cluster again
</simpara>
</listitem>
<listitem>
<simpara>
remove the databases except the master and start the master database with 1.7
</simpara>
</listitem>
<listitem>
<simpara>
start up the other databases so that they get a copy from the master
</simpara>
</listitem>
</orderedlist>
</section>
<section id="deployment-upgrading-one-six">
<title>Upgrade 1.5 &#8594; 1.6</title>
<simpara>This upgrade changes lucene version from 3.1 to 3.5. The upgrade itself is done by Lucene by loading an index.</simpara>
<simpara>In an HA environment these steps need to be performed:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
shut down all the databases in the cluster
</simpara>
</listitem>
<listitem>
<simpara>
shut down the ZooKeeper cluster and clear the <emphasis>version-2</emphasis> directories on all the ZooKeeper instances
</simpara>
</listitem>
<listitem>
<simpara>
start the ZooKeeper cluster again
</simpara>
</listitem>
<listitem>
<simpara>
start up the other databases so that they get a copy from the master
</simpara>
</listitem>
</orderedlist>
</section>
<section id="deployment-upgrading-one-five">
<title>Upgrade 1.4 &#8594; 1.5</title>
<simpara>This upgrade includes a significant change to the layout of property store files, which reduces their size on disk,
and improves IO performance.  To achieve this layout change, the upgrade process takes some time to process the
whole of the existing database.  You should budget for several minutes per gigabyte of data as part of your upgrade planning.</simpara>
<warning><simpara>The upgrade process for this upgrade temporarily requires additional disk space, for the period while the
upgrade is in progress.  Before starting the upgrade to Neo4j 1.5, you should ensure that the machine performing the
upgrade has free space equal to the current size of of the database on disk.  You can find the current space occupied
by the database by inspecting the store file directory (<emphasis>data/graph.db</emphasis> is the default location in Neo4j server).
Once the upgrade is complete, this additional space is no longer required.</simpara></warning>
</section>
</section>
<section id="server-debugging">
<title>Setup for remote debugging</title>
<simpara>In order to configure the Neo4j server for remote debugging sessions, the Java debugging
parameters need to be passed to the Java process through the configuration.
They live in the <emphasis>conf/neo4j-wrapper.properties</emphasis> file.</simpara>
<simpara>In order to specify the parameters, add a line for the additional Java arguments like this:</simpara>
<programlisting language="shell" linenumbering="unnumbered"># Java Additional Parameters
wrapper.java.additional.1=-Dorg.neo4j.server.properties=conf/neo4j-server.properties
wrapper.java.additional.2=-Dlog4j.configuration=file:conf/log4j.properties
wrapper.java.additional.3=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 \
   -Xdebug-Xnoagent-Djava.compiler=NONE\
   -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005</programlisting>
<simpara>This configuration will start a Neo4j server ready for remote debugging attachement at localhost and port <literal>5005</literal>.
Use these parameters to attach to the process from Eclipse, IntelliJ or your remote debugger of choice after starting the server.</simpara>
</section>
<section id="usage-data-collector">
<title>Usage Data Collector</title>
<simpara>The Neo4j Usage Data Collector is a sub-system that gathers usage data, reporting it to the UDC-server at udc.neo4j.org.
It is easy to disable, and does not collect any data that is confidential. For more information about what is being sent, see below.</simpara>
<simpara>The Neo4j team uses this information as a form of automatic, effortless feedback from the Neo4j community.
We want to verify that we are doing the right thing by matching download statistics with usage statistics.
After each release, we can see if there is a larger retention span of the server software.</simpara>
<simpara>The data collected is clearly stated here.
If any future versions of this system collect additional data, we will clearly announce those changes.</simpara>
<simpara>The Neo4j team is very concerned about your privacy. We do not disclose any personally identifiable information.</simpara>
<section id="_technical_information">
<title>Technical Information</title>
<simpara>To gather good statistics about Neo4j usage, UDC collects this information:</simpara>
<itemizedlist>
<listitem>
<simpara>
Kernel version: The build number, and if there are any modifications to the kernel.
</simpara>
</listitem>
<listitem>
<simpara>
Store id: A randomized globally unique id created at the same time a database is created.
</simpara>
</listitem>
<listitem>
<simpara>
Ping count: UDC holds an internal counter which is incremented for every ping, and reset for every restart of the kernel.
</simpara>
</listitem>
<listitem>
<simpara>
Source: This is either "neo4j" or "maven". If you downloaded Neo4j from the Neo4j website, it&#8217;s "neo4j", if you are using Maven to get Neo4j, it will be "maven".
</simpara>
</listitem>
<listitem>
<simpara>
Java version: The referrer string shows which version of Java is being used.
</simpara>
</listitem>
<listitem>
<simpara>
MAC address to uniquely identify instances behind firewalls.
</simpara>
</listitem>
<listitem>
<simpara>
Registration id: For registered server instances.
</simpara>
</listitem>
<listitem>
<simpara>
Tags about the execution context (e.g. test, language, web-container, app-container, spring, ejb).
</simpara>
</listitem>
<listitem>
<simpara>
Neo4j Edition (community, enterprise).
</simpara>
</listitem>
<listitem>
<simpara>
A hash of the current cluster name (if any).
</simpara>
</listitem>
<listitem>
<simpara>
Distribution information for Linux (rpm, dpkg, unknown).
</simpara>
</listitem>
<listitem>
<simpara>
User-Agent header for tracking usage of REST client drivers
</simpara>
</listitem>
</itemizedlist>
<simpara>After startup, UDC waits for ten minutes before sending the first ping. It does this for two reasons; first, we don&#8217;t want the startup to be slower because of UDC, and secondly, we want to keep pings from automatic tests to a minimum. The ping to the UDC servers is done with a HTTP GET.</simpara>
</section>
<section id="_how_to_disable_udc">
<title>How to disable UDC</title>
<simpara>We&#8217;ve tried to make it extremely easy to disable UDC. In fact, the code for UDC is not even included in the kernel jar but as a completely separate component.</simpara>
<simpara>There are three ways you can disable UDC:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
The easiest way is to just remove the neo4j-udc-*.jar file. By doing this, the kernel will not load UDC, and no pings will be sent.
</simpara>
</listitem>
<listitem>
<simpara>
If you are using Maven, and want to make sure that UDC is never installed in your system, a dependency element like this will do that:
</simpara>
<programlisting language="xml" linenumbering="unnumbered"> &lt;dependency&gt;
   &lt;groupId&gt;org.neo4j&lt;/groupId&gt;
   &lt;artifactId&gt;neo4j&lt;/artifactId&gt;
   &lt;version&gt;${neo4j-version}&lt;/version&gt;
   &lt;exclusions&gt;
     &lt;exclusion&gt;
       &lt;groupId&gt;org.neo4j&lt;/groupId&gt;
       &lt;artifactId&gt;neo4j-udc&lt;/artifactId&gt;
     &lt;/exclusion&gt;
   &lt;/exclusions&gt;
 &lt;/dependency&gt;</programlisting>
<simpara><emphasis>Where ${neo4j-version} is the Neo4j version in use.</emphasis></simpara>
</listitem>
<listitem>
<simpara>
Lastly, if you are using a packaged version of Neo4j, and do not want to make any change to the jars, a system property setting like this will also make sure that UDC is never activated: <literal>-Dneo4j.ext.udc.disable=true</literal>.
</simpara>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter id="embedded-configuration">
<title>Configuration &amp; Performance</title>
<simpara>In order to get optimum performance out of Neo4j for your application there are a few parameters that can be tweaked.
The two main components that can be configured are the Neo4j caches and the JVM that Neo4j runs in.
The following sections describe how to tune these.</simpara>
<section id="configuration-introduction">
<title>Introduction</title>
<simpara>To gain good performance, these are the things to look into first:</simpara>
<itemizedlist>
<listitem>
<simpara>
Make sure the JVM is not spending too much time performing garbage collection.
  Monitoring heap usage on an application that uses Neo4j can be a bit confusing since Neo4j will increase the size of caches if there is available memory and decrease if the heap is getting full.
  The goal is to have a large enough heap to make sure that heavy/peak load will not result in so called GC trashing (performance can drop as much as two orders of magnitude when GC trashing happens).
</simpara>
</listitem>
<listitem>
<simpara>
Start the JVM with the -server flag and a good sized heap (see <xref linkend="configuration-jvm"/>). Having too large heap may also hurt performance so you may have to try some different heap sizes.
</simpara>
</listitem>
<listitem>
<simpara>
Use the parallel/concurrent garbage collector (we found that <literal>-XX:+UseConcMarkSweepGC</literal> works well in most use-cases)
</simpara>
</listitem>
</itemizedlist>
<section id="_how_to_add_configuration_settings">
<title>How to add configuration settings</title>
<simpara>When creating the embedded Neo4j instance it is possible to pass in parameters contained in a map where keys and values are strings, see <xref linkend="tutorials-java-embedded-setup-config"/> for an example.</simpara>
<simpara>If no configuration is provided, the Database Kernel will try to determine suitable settings from the information available via the JVM settings and the underlying operating system.</simpara>
<simpara>The JVM is configured by passing command line flags when starting the JVM.
The most important configuration parameters for Neo4j are the ones that control the memory and garbage collector, but some of the parameters for configuring the Just In Time compiler are also of interest.</simpara>
<simpara>This is an example of starting up your applications main class using 64-bit server VM mode and a heap space of 1GB:</simpara>
<programlisting language="plain" linenumbering="unnumbered">java -d64 -server -Xmx1024m -cp /path/to/neo4j-kernel.jar:/path/to/jta.jar:/path/to/your-application.jar com.example.yourapp.MainClass</programlisting>
<simpara>Looking at the example above you will also notice one of the most basic command line parameters: the one for specifying the classpath. The classpath is the path in which the JVM searches for your classes. It is usually a list of jar-files. Specifying the classpath is done by specifying the flag <literal>-cp</literal> (or <literal>-classpath</literal>) and then the value of the classpath. For Neo4j applications this should at least include the path to the Neo4j <literal>neo4j-kernel.jar</literal> and the Java Transaction API (<literal>jta.jar</literal>) as well as the path where the classes for your application are located.</simpara>
<tip><simpara>On Linux, Unix and Mac OS X each element in the path list are separated by a colon symbol (<literal>:</literal>), on Windows the path elements are separated by a semicolon (<literal>;</literal>).</simpara></tip>
<simpara>When using the Neo4j REST server, see <xref linkend="server-configuration"/> for how to add configuration settings for the database to the server.</simpara>
</section>
</section>
<section id="server-configuration">
<title>Server Configuration</title>
<sidebar>
<title>Quick info</title>
<itemizedlist>
<listitem>
<simpara>
The server&#8217;s primary configuration file is found under <emphasis>conf/neo4j-server.properties</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
The <emphasis>conf/log4j.properties</emphasis> file contains the default server logging configuration
</simpara>
</listitem>
<listitem>
<simpara>
Low-level performance tuning parameters are found in <emphasis>conf/neo4j.properties</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
Configuraion of the deamonizing wrapper are found in <emphasis>conf/neo4j-wrapper.properties</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
HTTP logging configuration is found in <emphasis>conf/neo4j-http-logging.xml</emphasis>
</simpara>
</listitem>
</itemizedlist>
</sidebar>
<section id="_important_server_configurations_parameters">
<title>Important server configurations parameters</title>
<simpara>The main configuration file for the server can be found at <emphasis>conf/neo4j-server.properties</emphasis>.
This file contains several important settings, and although the defaults are sensible
administrators might choose to make changes (especially to the port settings).</simpara>
<simpara>Set the location on disk of the database directory like this:</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.database.location=data/graph.db</programlisting>
<note><simpara>On Windows systems, absolute locations including drive letters need to read <emphasis>"c:/data/db"</emphasis>.</simpara></note>
<simpara>Specify the HTTP server port supporting data, administrative, and UI access:</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.webserver.port=7474</programlisting>
<simpara>Specify the client accept pattern for the webserver (default is <literal>127.0.0.1</literal>, localhost only):</simpara>
<programlisting language="plain" linenumbering="unnumbered">#allow any client to connect
org.neo4j.server.webserver.address=0.0.0.0</programlisting>
<simpara>For securing the Neo4j Server, see also <xref linkend="operations-security"/></simpara>
<simpara>Set the location of the round-robin database directory which gathers metrics on the running server instance:</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.webadmin.rrdb.location=data/graph.db/../rrd</programlisting>
<simpara>Set the URI path for the REST data API through which the database is accessed. This should be a relative path.</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.webadmin.data.uri=/db/data/</programlisting>
<simpara>Setting the management URI for the administration API that the Webadmin tool uses. This should be a relative path.</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.webadmin.management.uri=/db/manage</programlisting>
<simpara>Force the server to use IPv4 network addresses, in <emphasis>conf/neo4j-wrapper.conf</emphasis> under the section <emphasis>Java Additional Parameters</emphasis> add a new paramter:</simpara>
<programlisting language="plain" linenumbering="unnumbered">wrapper.java.additional.3=-Djava.net.preferIPv4Stack=true</programlisting>
<simpara>Specify the number of threads used by the Neo4j Web server to control the level of concurrent HTTP requests that the server will service.</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.webserver.maxthreads=200</programlisting>
<note><simpara>The default value is 10 times the number of CPUs reported available by the JVM.</simpara></note>
<simpara>The server guards against orphaned transactions by using a timeout. If there are no requests for a given transaction
within the timeout period, the server will roll it back. You can configure the timeout period by setting
the following property to the number of seconds before timeout. The default timeout is 60 seconds.</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.transaction.timeout=60</programlisting>
<simpara>Low-level performance tuning parameters can be explicitly set by referring
to the following property:</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.db.tuning.properties=neo4j.properties</programlisting>
<simpara>If this property isn&#8217;t set, the server will look for a file called <emphasis>neo4j.properties</emphasis> in
the same directory as the <emphasis>neo4j-server.properties</emphasis> file.</simpara>
<simpara>If this property isn&#8217;t set, and there is no <emphasis>neo4j.properties</emphasis> file in the default
configuration directory, then the server will log a warning. Subsequently at runtime the
database engine will attempt tune itself based on the prevailing conditions.</simpara>
</section>
<section id="_neo4j_database_performance_configuration">
<title>Neo4j Database performance configuration</title>
<simpara>The fine-tuning of the low-level Neo4j graph database engine is specified in a separate
properties file, <emphasis>conf/neo4j.properties</emphasis>.</simpara>
<simpara>The graph database engine has a range of performance tuning options which are enumerated in
<xref linkend="server-performance"/>. Note that other factors than Neo4j tuning should be considered
when performance tuning a server, including general server load, memory and file contention,
and even garbage collection penalties on the JVM, though such considerations are beyond the scope
of this configuration document.</simpara>
</section>
<section id="_server_logging_configuration">
<title>Server logging configuration</title>
<simpara>Application events within Neo4j server are processed with
 <literal><ulink url="http://download.oracle.com/javase/6/docs/technotes/guides/logging/overview.html">java.util.logging</ulink></literal> and
 configured in the file <emphasis>conf/logging.properties</emphasis>.</simpara>
<simpara>By default it is setup to print <literal>INFO</literal> level messages both on screen and in a rolling file in <emphasis>data/log</emphasis>.
Most deployments will choose to use their own configuration here to meet local standards.
During development, much useful information can be found in the logs so some form of logging to disk is well worth keeping.
On the other hand, if you want to completely silence the console output, set:</simpara>
<programlisting language="plain" linenumbering="unnumbered">java.util.logging.ConsoleHandler.level=OFF</programlisting>
<simpara>By default log files are rotated at approximately 10Mb and named consecutively neo4j.&lt;id&gt;.&lt;rotation sequence #&gt;.log
To change the naming scheme, rotation frequency and backlog size modify</simpara>
<programlisting language="plain" linenumbering="unnumbered">java.util.logging.FileHandler.pattern
java.util.logging.FileHandler.limit
java.util.logging.FileHandler.count</programlisting>
<simpara>respectively to your needs. Details are available at the Javadoc for <literal><ulink url="http://download.oracle.com/javase/6/docs/api/java/util/logging/FileHandler.html">java.util.logging.FileHandler</ulink></literal>.</simpara>
<simpara>Apart from log statements originating from the Neo4j server, other libraries report their messages
through various frameworks.</simpara>
</section>
<section id="_http_logging_configuration">
<title>HTTP logging configuration</title>
<simpara>As well as logging events happening within the Neo4j server, it is possible to log the HTTP requests and responses
that the server consumes and produces. Configuring HTTP logging requires operators to enable and configure the
logger and where it will log; and then to optionally configure the log format.</simpara>
<warning><simpara>By default the HTTP logger uses <literal><ulink url="http://en.wikipedia.org/wiki/Common_Log_Format">Common Log Format</ulink></literal>
meaning that most Web server tooling can automtically consume such logs. In general users should only enable HTTP logging,
select an output directory, and if necessary alter the rollover and retention policies.</simpara></warning>
<simpara>To enable HTTP logging, edit the <emphasis>conf/neo4j-server.properties</emphasis> file to resemble the following:</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.http.log.enabled=true
org.neo4j.server.http.log.config=conf/neo4j-http-logging.xml</programlisting>
<simpara><emphasis>org.neo4j.server.http.log.enabled=true</emphasis> tells the server that HTTP logging is enabled. HTTP logging can be totally
disabled by setting this property to <emphasis>false</emphasis>.
<emphasis>org.neo4j.server.http.log.config=conf/neo4j-http-logging.xml</emphasis> specifies the logging format and rollover policy file
that governs how HTTP log output is presented and archived. The defaults provided with Neo4j server uses an hourly log
rotation and <literal><ulink url="http://en.wikipedia.org/wiki/Common_Log_Format">Common Log Format</ulink></literal>.</simpara>
<simpara>If logging is set up to use log files then the server will check that the log file directory exists and is writable. If
this check fails, then the server will not startup and wil report the failure another available channel like standard out.</simpara>
</section>
<section id="_using_x_forwarded_proto_and_x_forwarded_host_to_parameterize_the_base_uri_for_rest_responses">
<title>Using X-Forwarded-Proto and X-Forwarded-Host to parameterize the base URI for REST responses</title>
<simpara>There are occasions, for example when you want to host Neo4j server behind a proxy (e.g. one that handles HTTPS traffic),
and still have Neo4j respect the base URI of that externally visible proxy.</simpara>
<simpara>Ordinarily Neo4j uses the <literal>HOST</literal> header of the HTTP request to construct URIs in its responses. Where a proxy is involved
however, this is often undesirable. Instead Neo4j, uses the
<literal>X-Forwarded-Host</literal> and <literal>X-Forwarded-Proto</literal> headers provided by proxies to parameterize the URIs in the responses from
the database&#8217;s REST API. From the outside it looks as if the proxy generated that payload. If an <literal>X-Forwarded-Host</literal>
header value contains more than one address (<literal>X-Forwarded-Host</literal> allows comma-and-space separated lists of addresses),
Neo4j picks the first, which represents the client request.</simpara>
<simpara>In order to take advantage of this functionality, your proxy server must be configured to transmit these headers to the
Neo4j server. Failure to transmit both <literal>X-Forwarded-Host</literal> and <literal>X-Forwarded-Proto</literal> headers will result in the original
base URI being used.</simpara>
</section>
<section id="_other_configuration_options">
<title>Other configuration options</title>
<section id="_enabling_logging_from_the_garbage_collector">
<title>Enabling logging from the garbage collector</title>
<simpara>To get garbage collection logging output you have to pass the corresponding option to the server JVM
executable by setting in <emphasis>conf/neo4j-wrapper.conf</emphasis> the value</simpara>
<programlisting language="plain" linenumbering="unnumbered">wrapper.java.additional.3=-Xloggc:data/log/neo4j-gc.log</programlisting>
<simpara>This line is already present and needs uncommenting. Note also that logging is not directed to console ;
You will find the logging statements in <emphasis>data/log/ne4j-gc.log</emphasis> or whatever directory you set at the option.</simpara>
</section>
<section id="_disabling_console_types_in_webadmin">
<title>Disabling console types in Webadmin</title>
<simpara>You may, for security reasons, want to disable the the Neo4j Shell in Webadmin.
Shells allow arbitrary code execution, and so they could constitute a security risk if you do not trust all users of your Neo4j Server.</simpara>
<simpara>In the <emphasis>conf/neo4j-server.properties</emphasis> file:</simpara>
<programlisting language="plain" linenumbering="unnumbered"># To disable all shells:
org.neo4j.server.manage.console_engines=

# To enable only the Neo4j Shell:
org.neo4j.server.manage.console_engines=shell</programlisting>
</section>
</section>
</section>
<section id="server-performance">
<title>Server Performance Tuning</title>
<simpara>At the heart of the Neo4j server is a regular Neo4j storage engine instance.
That engine can be tuned in the same way as the other embedded configurations, using the same file format.
The only difference is that the server must be told where to find the fine-tuning configuration.</simpara>
<sidebar>
<title>Quick info</title>
<itemizedlist>
<listitem>
<simpara>
The neo4j.properties file is a standard configuration file that databases load in order to tune their memory use and caching strategies.
</simpara>
</listitem>
<listitem>
<simpara>
See <xref linkend="configuration-caches"/> for more information.
</simpara>
</listitem>
</itemizedlist>
</sidebar>
<section id="_specifying_neo4j_tuning_properties">
<title>Specifying Neo4j tuning properties</title>
<simpara>The <literal>conf/neo4j-server.properties</literal> file in the server distribution, is the main configuration file for the server.
In this file we can specify a second properties file that contains the database tuning settings (that is, the <literal>neo4j.properties</literal> file).
This is done by setting a single property to point to a valid <literal>neo4j.properties</literal> file:</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.db.tuning.properties={neo4j.properties file}</programlisting>
<simpara>On restarting the server the tuning enhancements specified in the <literal>neo4j.properties</literal> file will be loaded and configured into the underlying database engine.</simpara>
</section>
<section id="_specifying_jvm_tuning_properties">
<title>Specifying JVM tuning properties</title>
<simpara>Tuning the standalone server is achieved by editing the <literal>neo4j-wrapper.conf</literal> file in the <literal>conf</literal> directory of <literal>NEO4J_HOME</literal>.</simpara>
<simpara>Edit the following properties:</simpara>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>neo4j-wrapper.conf JVM tuning properties</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"> Property Name             </entry>
<entry align="left" valign="top"> Meaning</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>wrapper.java.initmemory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>initial heap size (in MB)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>wrapper.java.maxmemory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>maximum heap size (in MB)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>wrapper.java.additional.N</literal></simpara></entry>
<entry align="left" valign="top"><simpara>additional literal JVM parameter, where N is a number for each</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>For more information on the tuning properties, see <xref linkend="configuration-jvm"/>.</simpara>
</section>
</section>
<section id="performance-guide">
<title>Performance Guide</title>
<simpara>This is the Neo4j performance guide. It will attempt to give you guidance on how to use Neo4j to achieve maximum performance.</simpara>
<section id="_try_this_first">
<title>Try this first</title>
<simpara>The first thing is to make sure the JVM is running well and not spending too much
time in garbage collection. Monitoring heap usage of an application that uses Neo4j
can be a bit confusing since Neo4j will increase the size of caches if there is
available memory and decrease if the heap is getting full. The goal is to have a
large enough heap so heavy/peak load will not result in so called GC trashing
(performance can drop as much as two orders of a magnitude when this happens).</simpara>
<simpara>Start the JVM with <literal>-server</literal> flag and <literal>-Xmx&lt;good sized heap&gt;</literal>
(f.ex. -Xmx512M for 512Mb memory or -Xmx3G for 3Gb memory). Having too large heap
may also hurt performance so you may have to try out some different heap sizes.
Make sure a parallel/concurrent garbage collector is running (<literal>-XX:+UseConcMarkSweepGC</literal> works well in most use-cases).</simpara>
<simpara>Finally make sure that the OS has some memory left to manage proper file system
caches. This means, if your server has 8GB of RAM don&#8217;t use all of that RAM for
heap (unless you have turned off memory mapped buffers), but leave a good part of it to the OS.
For more information on this see <xref linkend="embedded-configuration"/>.</simpara>
<simpara>For Linux specific tweaks, see <xref linkend="linux-performance-guide"/>.</simpara>
</section>
<section id="_neo4j_primitives_lifecycle">
<title>Neo4j primitives' lifecycle</title>
<simpara>Neo4j manages its primitives (nodes, relationships and properties)
different depending on how you use Neo4j. For example if you never get a
property from a certain node or relationship that node or relationship will
not have its properties loaded into memory. The first time, after loading a node or relationship,
that any property is accessed all the properties are loaded for that entity. If any of those properties
contain an array larger than a few elements or a long string such values are loaded
on demand when requesting them individually. Similarly, relationships of a node will
only be loaded the first time they are requested for that node.</simpara>
<simpara>Nodes and relationships are cached using LRU caches. If you (for some strange reason)
only work with nodes the relationship cache will become smaller and smaller while the
node cache is allowed to grow (if needed). Working with many relationships and few nodes
results in a bigger relationship cache and smaller node cache.</simpara>
<simpara>The Neo4j API specification does not say anything about order regarding
relationships so invoking <literal>Node.getRelationships()</literal>
may return the relationships in a different order than the previous invocation.
This allows us to make even heavier optimizations returning the relationships
that are most commonly traversed.</simpara>
<simpara>All in all Neo4j has been designed to be very adaptive depending on how it
is used. The (unachievable) overall goal is to be able to handle any incoming
operation without having to go down and work with the file/disk I/O layer.</simpara>
</section>
<section id="_configuring_neo4j">
<title>Configuring Neo4j</title>
<simpara>In <xref linkend="embedded-configuration"/> page there&#8217;s information on how to configure Neo4j and the JVM.
These settings have a lot of impact on performance.</simpara>
<section id="_disks_ram_and_other_tips">
<title>Disks, RAM and other tips</title>
<simpara>As always, as with any persistence solution, performance depends a lot on the
persistence media used. Better disks equals better performance.</simpara>
<simpara>If you have multiple disks or persistence media available it may be a
good idea to split the store files and transaction logs across those disks.
Having the store files running on disks with low seek time can do wonders for
non-cached read operations. Today a typical mechanical drive has an average
seek time of about 5ms, this can cause a query or traversal to be very slow
when the available amount of RAM is too small or the configuration for caches and memory mapping
is bad. A new good SATA enabled SSD has an average seek time of &lt;100 microseconds
meaning those scenarios will execute at least 50 times faster.</simpara>
<simpara>To avoid hitting disk you need more RAM. On a standard mechanical drive you
can handle graphs with a few tens of millions of primitives with 1-2GB of RAM.
4-8GB of RAM can handle graphs with hundreds of millions of primitives while you
need a good server with 16-32GB to handle billions of primitives. However, if you
invest in a good SSD you will be able to handle much larger graphs on less RAM.</simpara>
<simpara>Use tools like <literal>vmstat</literal> or
equivalent to gather information when your application is running. If you have high I/O
waits and not that many blocks going out/in to disks when running write/read
transactions it&#8217;s a sign that you need to tweak your Java heap, Neo4j cache
and memory mapping settings (maybe even get more RAM or better disks).</simpara>
</section>
<section id="_write_performance">
<title>Write performance</title>
<simpara>If you are experiencing poor write performance after writing some data
(initially fast, then massive slowdown) it may be the operating system that is
writing out dirty pages from the memory mapped regions of the store files.
These regions do not need to be written out to maintain consistency so to
achieve highest possible write speed that type of behavior should be avoided.</simpara>
<simpara>Another source of writes slowing down can be the transaction size. Many small
transactions result in a lot of I/O writes to disc and should be avoided.
Too big transactions can result in OutOfMemory errors, since the uncommitted
transaction data is held on the Java Heap in memory. For details about transaction
management in Neo4j, please see <xref linkend="transactions"/>.</simpara>
<simpara>The Neo4j kernel makes use of several store files and a logical log file
to store the graph on disk. The store files contain the actual graph and the
log contains modifying operations. All writes to the logical log are append-only
and when a transaction is committed changes to the logical log will be forced
(<literal>fdatasync</literal>) down to disk. The store files are however not flushed to disk and
writes to them are not append-only either. They will be written to in a more or
less random pattern (depending on graph layout) and writes will not be forced to
disk until the log is rotated or the Neo4j kernel is shut down.</simpara>
<simpara>Since random writes to memory mapped regions for the store files may
happen it is very important that the data does not get written out to disk unless
needed. Some operating systems have very aggressive settings regarding when to write
out these dirty pages to disk. If the OS decides to start writing out dirty pages
of these memory mapped regions, write access to disk will stop being sequential and
become random. That hurts performance a lot, so to get maximum write performance when
using Neo4j make sure the OS is configured not to write out any of the dirty pages
caused by writes to the memory mapped regions of the store files. As an example,
if the machine has 8GB of RAM and the total size of the store files is 4GB (fully
memory mapped) the OS has to be configured to accept at least 50% dirty pages in
virtual memory to make sure we do not get random disk writes.</simpara>
<note><simpara>Make sure to read <xref linkend="linux-performance-guide"/> as well for more specific information.</simpara></note>
</section>
<section id="_second_level_caching">
<title>Second level caching</title>
<simpara>While normally building applications and &#8220;always assume the graph is in memory&#8221;,
sometimes it is necessary to optimize certain performance critical sections.
Neo4j adds a small overhead even if the node, relationship or property in question
is cached compared to in-memory data structures. If this becomes an
issue, use a profiler to find these hot spots and then add your own second-level
caching. We believe second-level caching should be avoided to greatest extent
possible since it will force you to take care of invalidation which sometimes
can be hard. But when everything else fails you have to use it so here is an
example of how it can be done.</simpara>
<simpara>We have some POJO that wrapps a node holding its state. In this particular
POJO we have overridden the equals implementation.</simpara>
<programlisting language="java" linenumbering="unnumbered">   public boolean equals( Object obj )
   {
       return underlyingNode.getProperty( "some_property" ).equals( obj );
   }

   public int hashCode()
   {
       return underlyingNode.getProperty( "some_property" ).hashCode();
   }</programlisting>
<simpara>This works fine in most scenarios, but in this particular scenario many instances of that POJO is being worked with in nested loops adding/removing/getting/finding to collection classes.
Profiling the applications will show that the equals implementation is being called many times and can be viewed as a hot spot.
Adding second-level caching for the equals override will in this particular scenario increase performance.</simpara>
<programlisting language="java" linenumbering="unnumbered">    private Object cachedProperty = null;

    public boolean equals( Object obj )
    {
       if ( cachedProperty == null )
       {
           cachedProperty = underlyingNode.getProperty( "some_property" );
       }
       return cachedProperty.equals( obj );
    }

    public int hashCode()
    {
       if ( cachedPropety == null )
       {
           cachedProperty = underlyingNode.getProperty( "some_property" );
       }
       return cachedProperty.hashCode();
    }</programlisting>
<simpara>The problem with this is that now we need to invalidate the cached property whenever <literal>some_property</literal>
is changed (may not be a problem in this scenario since the state picked for equals and hash
code computation often won&#8217;t change).</simpara>
<tip><simpara>To sum up, avoid second-level caching if possible and only add it when you really need it.</simpara></tip>
</section>
</section>
</section>
<section id="kernel-configuration">
<title>Kernel configuration</title>
<simpara>These are the configuration options you can pass to the neo4j kernel. They
can either be passed as a map when using the embedded database, or in the
neo4j.properties file when using the Neo4j Server.</simpara>
<table id="all_stores_total_mapped_memory_size" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>All stores total mapped memory size</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 524288000
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>all_stores_total_mapped_memory_size</literal></simpara><simpara role="configsetting-desc">The size to allocate for a memory mapping pool to be shared between all stores.</simpara></entry></row></tbody></tgroup></table>
<table id="allow_store_upgrade" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Allow store upgrade</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> false
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>allow_store_upgrade</literal></simpara><simpara role="configsetting-desc">Whether to allow a store upgrade in case the current version of the database starts against an older store version. Setting this to true does not guarantee successful upgrade, just that it allows an attempt at it.</simpara></entry></row></tbody></tgroup></table>
<table id="array_block_size" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Array block size</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 120
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>array_block_size</literal></simpara><simpara role="configsetting-desc">Specifies the block size for storing arrays. This parameter is only honored when the store is created, otherwise it is ignored. The default block size is 120 bytes, and the overhead of each block is the same as for string blocks, i.e., 8 bytes.</simpara></entry></row></tbody></tgroup></table>
<table id="backup_slave" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Backup slave</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> false
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>backup_slave</literal></simpara><simpara role="configsetting-desc">Mark this database as a backup slave.</simpara></entry></row></tbody></tgroup></table>
<table id="cache_type" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Cache type</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> soft
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>cache_type</literal></simpara><simpara role="configsetting-desc">The type of cache to use for nodes and relationships. Note that the Neo4j Enterprise Edition has the additional 'hpc' cache type (High-Performance Cache). See the chapter on caches in the manual for more information.</simpara></entry></row></tbody></tgroup></table>
<table id="cypher_parser_version
" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Cypher parser version</title><tgroup cols="1"><colspec colname="col1"/><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>cypher_parser_version
</literal></simpara><simpara role="configsetting-desc">Enable this to specify a parser other than the default one.</simpara></entry></row></tbody></tgroup></table>
<table id="dump_configuration" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Dump configuration</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> false
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>dump_configuration</literal></simpara><simpara role="configsetting-desc">Print out the effective Neo4j configuration after startup.</simpara></entry></row></tbody></tgroup></table>
<table id="forced_kernel_id
" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Forced kernel id</title><tgroup cols="1"><colspec colname="col1"/><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>forced_kernel_id
</literal></simpara><simpara role="configsetting-desc">An identifier that uniquely identifies this graph database instance within this JVM. Defaults to an auto-generated number depending on how many instance are started in this JVM.</simpara></entry></row></tbody></tgroup></table>
<table id="gc_monitor_threshold" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Gc monitor threshold</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 200
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>gc_monitor_threshold</literal></simpara><simpara role="configsetting-desc">The amount of time in ms the monitor thread has to be blocked before logging a message it was blocked.</simpara></entry></row></tbody></tgroup></table>
<table id="gc_monitor_wait_time" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Gc monitor wait time</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 100
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>gc_monitor_wait_time</literal></simpara><simpara role="configsetting-desc">Amount of time in ms the GC monitor thread will wait before taking another measurement.</simpara></entry></row></tbody></tgroup></table>
<table id="intercept_committing_transactions" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Intercept committing transactions</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> false
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>intercept_committing_transactions</literal></simpara><simpara role="configsetting-desc">Determines whether any TransactionInterceptors loaded will intercept prepared transactions before they reach the logical log.</simpara></entry></row></tbody></tgroup></table>
<table id="intercept_deserialized_transactions" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Intercept deserialized transactions</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> false
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>intercept_deserialized_transactions</literal></simpara><simpara role="configsetting-desc">Determines whether any TransactionInterceptors loaded will intercept externally received transactions (e.g. in HA) before they reach the logical log and are applied to the store.</simpara></entry></row></tbody></tgroup></table>
<table id="keep_logical_logs" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Keep logical logs</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> true
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>keep_logical_logs</literal></simpara><simpara role="configsetting-desc">Make Neo4j keep the logical transaction logs for being able to backup the database.Can be used for specifying the threshold to prune logical logs after. For example "10 days" will prune logical logs that only contains transactions older than 10 days from the current time, or "100k txs" will keep the 100k latest transactions and prune any older transactions.</simpara></entry></row></tbody></tgroup></table>
<table id="label_block_size" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Label block size</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 60
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>label_block_size</literal></simpara><simpara role="configsetting-desc">Specifies the block size for storing labels exceeding in-lined space in node record. This parameter is only honored when the store is created, otherwise it is ignored. The default block size is 60 bytes, and the overhead of each block is the same as for string blocks, i.e., 8 bytes.</simpara></entry></row></tbody></tgroup></table>
<table id="log_mapped_memory_stats" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Log mapped memory stats</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> false
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>log_mapped_memory_stats</literal></simpara><simpara role="configsetting-desc">Tell Neo4j to regularly log memory mapping statistics.</simpara></entry></row></tbody></tgroup></table>
<table id="log_mapped_memory_stats_filename" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Log mapped memory stats filename</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> mapped_memory_stats.log
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>log_mapped_memory_stats_filename</literal></simpara><simpara role="configsetting-desc">The file where Neo4j will record memory mapping statistics.</simpara></entry></row></tbody></tgroup></table>
<table id="log_mapped_memory_stats_interval" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Log mapped memory stats interval</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 1000000
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>log_mapped_memory_stats_interval</literal></simpara><simpara role="configsetting-desc">The number of records to be loaded between regular logging of memory mapping statistics.</simpara></entry></row></tbody></tgroup></table>
<table id="logging.threshold_for_rotation" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Logging.threshold for rotation</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 104857600
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>logging.threshold_for_rotation</literal></simpara><simpara role="configsetting-desc">Threshold in bytes for when database logs (text logs, for debugging, that is) are rotated.</simpara></entry></row></tbody></tgroup></table>
<table id="logical_log" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Logical log</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> nioneo_logical.log
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>logical_log</literal></simpara><simpara role="configsetting-desc">The base name for the logical log files, either an absolute path or relative to the store_dir setting. This should generally not be changed.</simpara></entry></row></tbody></tgroup></table>
<table id="logical_log_rotation_threshold" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Logical log rotation threshold</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 26214400
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>logical_log_rotation_threshold</literal></simpara><simpara role="configsetting-desc">Specifies at which file size the logical log will auto-rotate. 0 means that no rotation will automatically occur based on file size. Default is 25M</simpara></entry></row></tbody></tgroup></table>
<table id="lucene_searcher_cache_size" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Lucene searcher cache size</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 2147483647
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>lucene_searcher_cache_size</literal></simpara><simpara role="configsetting-desc">Integer value that sets the maximum number of open lucene index searchers.</simpara></entry></row></tbody></tgroup></table>
<table id="mapped_memory_page_size" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Mapped memory page size</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 1048576
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>mapped_memory_page_size</literal></simpara><simpara role="configsetting-desc">Target size for pages of mapped memory.</simpara></entry></row></tbody></tgroup></table>
<table id="neo_store" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Neo store</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> neostore
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>neo_store</literal></simpara><simpara role="configsetting-desc">The base name for the Neo4j Store files, either an absolute path or relative to the store_dir setting. This should generally not be changed.</simpara></entry></row></tbody></tgroup></table>
<table id="neostore.nodestore.db.mapped_memory" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Neostore.nodestore.db.mapped memory</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 20971520
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>neostore.nodestore.db.mapped_memory</literal></simpara><simpara role="configsetting-desc">The size to allocate for memory mapping the node store.</simpara></entry></row></tbody></tgroup></table>
<table id="neostore.propertystore.db.arrays.mapped_memory" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Neostore.propertystore.db.arrays.mapped memory</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 136314880
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>neostore.propertystore.db.arrays.mapped_memory</literal></simpara><simpara role="configsetting-desc">The size to allocate for memory mapping the array property store.</simpara></entry></row></tbody></tgroup></table>
<table id="neostore.propertystore.db.index.keys.mapped_memory" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Neostore.propertystore.db.index.keys.mapped memory</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 1048576
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>neostore.propertystore.db.index.keys.mapped_memory</literal></simpara><simpara role="configsetting-desc">The size to allocate for memory mapping the store for property key strings.</simpara></entry></row></tbody></tgroup></table>
<table id="neostore.propertystore.db.index.mapped_memory" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Neostore.propertystore.db.index.mapped memory</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 1048576
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>neostore.propertystore.db.index.mapped_memory</literal></simpara><simpara role="configsetting-desc">The size to allocate for memory mapping the store for property key indexes.</simpara></entry></row></tbody></tgroup></table>
<table id="neostore.propertystore.db.mapped_memory" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Neostore.propertystore.db.mapped memory</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 94371840
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>neostore.propertystore.db.mapped_memory</literal></simpara><simpara role="configsetting-desc">The size to allocate for memory mapping the property value store.</simpara></entry></row></tbody></tgroup></table>
<table id="neostore.propertystore.db.strings.mapped_memory" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Neostore.propertystore.db.strings.mapped memory</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 136314880
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>neostore.propertystore.db.strings.mapped_memory</literal></simpara><simpara role="configsetting-desc">The size to allocate for memory mapping the string property store.</simpara></entry></row></tbody></tgroup></table>
<table id="neostore.relationshipstore.db.mapped_memory" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Neostore.relationshipstore.db.mapped memory</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 104857600
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>neostore.relationshipstore.db.mapped_memory</literal></simpara><simpara role="configsetting-desc">The size to allocate for memory mapping the relationship store.</simpara></entry></row></tbody></tgroup></table>
<table id="node_auto_indexing" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Node auto indexing</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> false
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>node_auto_indexing</literal></simpara><simpara role="configsetting-desc">Controls the auto indexing feature for nodes. Setting to false shuts it down, while true enables it by default for properties listed in the node_keys_indexable setting.</simpara></entry></row></tbody></tgroup></table>
<table id="node_keys_indexable
" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Node keys indexable</title><tgroup cols="1"><colspec colname="col1"/><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>node_keys_indexable
</literal></simpara><simpara role="configsetting-desc">A list of property names (comma separated) that will be indexed by default. This applies to Nodes only.</simpara></entry></row></tbody></tgroup></table>
<table id="query_cache_size" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Query cache size</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 100
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>query_cache_size</literal></simpara><simpara role="configsetting-desc">Used to set the number of Cypher query execution plans that are cached.</simpara></entry></row></tbody></tgroup></table>
<table id="read_only" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Read only database</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> false
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>read_only</literal></simpara><simpara role="configsetting-desc">Only allow read operations from this Neo4j instance. This mode still requires write access to the directory for lock purposes</simpara></entry></row></tbody></tgroup></table>
<table id="rebuild_idgenerators_fast" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Rebuild idgenerators fast</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> true
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>rebuild_idgenerators_fast</literal></simpara><simpara role="configsetting-desc">Use a quick approach for rebuilding the ID generators. This give quicker recovery time, but will limit the ability to reuse the space of deleted entities.</simpara></entry></row></tbody></tgroup></table>
<table id="relationship_auto_indexing" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Relationship auto indexing</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> false
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>relationship_auto_indexing</literal></simpara><simpara role="configsetting-desc">Controls the auto indexing feature for relationships. Setting to false shuts it down, while true enables it by default for properties listed in the relationship_keys_indexable setting.</simpara></entry></row></tbody></tgroup></table>
<table id="relationship_grab_size" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Relationship grab size</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 100
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>relationship_grab_size</literal></simpara><simpara role="configsetting-desc">How many relationships to read at a time during iteration</simpara></entry></row></tbody></tgroup></table>
<table id="relationship_keys_indexable
" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Relationship keys indexable</title><tgroup cols="1"><colspec colname="col1"/><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>relationship_keys_indexable
</literal></simpara><simpara role="configsetting-desc"> A list of property names (comma separated) that will be indexed by default. This applies to Relationships only.</simpara></entry></row></tbody></tgroup></table>
<table id="remote_logging_enabled" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Remote logging enabled</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> false
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>remote_logging_enabled</literal></simpara><simpara role="configsetting-desc">Whether to enable logging to a remote server or not.</simpara></entry></row></tbody></tgroup></table>
<table id="remote_logging_host" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Remote logging host</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 127.0.0.1
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>remote_logging_host</literal></simpara><simpara role="configsetting-desc">Host for remote logging using LogBack SocketAppender.</simpara></entry></row></tbody></tgroup></table>
<table id="remote_logging_port" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Remote logging port</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 4560
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>remote_logging_port</literal></simpara><simpara role="configsetting-desc">Port for remote logging using LogBack SocketAppender.</simpara></entry></row></tbody></tgroup></table>
<table id="store_dir
" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Store dir</title><tgroup cols="1"><colspec colname="col1"/><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>store_dir
</literal></simpara><simpara role="configsetting-desc">The directory where the database files are located.</simpara></entry></row></tbody></tgroup></table>
<table id="string_block_size" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>String block size</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> 120
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>string_block_size</literal></simpara><simpara role="configsetting-desc">Specifies the block size for storing strings. This parameter is only honored when the store is created, otherwise it is ignored. Note that each character in a string occupies two bytes, meaning that a block size of 120 (the default size) will hold a 60 character long string before overflowing into a second block. Also note that each block carries an overhead of 8 bytes. This means that if the block size is 120, the size of the stored records will be 128 bytes.</simpara></entry></row></tbody></tgroup></table>
<table id="tx_manager_impl" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Tx manager impl</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> native
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>tx_manager_impl</literal></simpara><simpara role="configsetting-desc">The name of the Transaction Manager service to use as defined in the TM service provider constructor.</simpara></entry></row></tbody></tgroup></table>
<table id="use_memory_mapped_buffers" tabstyle="configsetting table" role="configsetting" frame="all" rowsep="1" colsep="1"><title>Use memory mapped buffers</title><tgroup cols="1"><colspec colname="col1"/><tfoot><row><entry role="configsetting-default" align="left" valign="top" namest="col1" nameend="col1">Default value: <literal> true
</literal></entry></row></tfoot><tbody><row><entry align="left" valign="top" namest="col1" nameend="col1"><simpara role="configsetting-key"><literal>use_memory_mapped_buffers</literal></simpara><simpara role="configsetting-desc">Tell Neo4j to use memory mapped buffers for accessing the native storage layer.</simpara></entry></row></tbody></tgroup></table>
</section>
<section id="configuration-caches">
<title>Caches in Neo4j</title>
<simpara>For how to provide custom configuration to Neo4j, see <xref linkend="configuration-introduction"/>.</simpara>
<simpara>Neo4j utilizes two different types of caches:
A file buffer cache and an object cache.
The file buffer cache caches the storage file data in the same format as it is stored on the durable storage media.
The object cache caches the nodes, relationships and properties in a format that is optimized for high traversal speeds and transactional writes.</simpara>
<section id="_file_buffer_cache">
<title>File buffer cache</title>
<sidebar>
<title>Quick info</title>
<itemizedlist>
<listitem>
<simpara>
The file buffer cache is sometimes called <emphasis>low level cache</emphasis> or <emphasis>file system cache</emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
It caches the Neo4j data as stored on the durable media.
</simpara>
</listitem>
<listitem>
<simpara>
It uses the operating system memory mapping features when possible.
</simpara>
</listitem>
<listitem>
<simpara>
Neo4j will configure the cache automatically as long as the heap size of the JVM is configured properly.
</simpara>
</listitem>
</itemizedlist>
</sidebar>
<simpara>The file buffer cache caches the Neo4j data in the same format as it is represented on the durable storage media.
The purpose of this cache layer is to improve both read and write performance.
The file buffer cache improves write performance by writing to the cache and deferring durable write until the logical log is rotated.
This behavior is safe since all transactions are always durably written to the logical log, which can be used to recover the store files in the event of a crash.</simpara>
<simpara>Since the operation of the cache is tightly related to the data it stores, a short description of the Neo4j durable representation format is necessary background.
Neo4j stores data in multiple files and relies on the underlying file system to handle this efficiently.
Each Neo4j storage file contains uniform fixed size records of a particular type:</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="153*"/>
<colspec colname="col_2" colwidth="68*"/>
<colspec colname="col_3" colwidth="119*"/>
<thead>
<row>
<entry align="left" valign="top"> Store file  </entry>
<entry align="right" valign="top"> Record size  </entry>
<entry align="left" valign="top"> Contents</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>neostore.nodestore.db</simpara></entry>
<entry align="right" valign="top"><simpara><literal>14 B</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Nodes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>neostore.relationshipstore.db</simpara></entry>
<entry align="right" valign="top"><simpara><literal>33 B</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Relationships</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>neostore.propertystore.db</simpara></entry>
<entry align="right" valign="top"><simpara><literal>41 B</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Properties for nodes and relationships</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>neostore.propertystore.db.strings</simpara></entry>
<entry align="right" valign="top"><simpara><literal>128 B</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Values of string properties</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>neostore.propertystore.db.arrays</simpara></entry>
<entry align="right" valign="top"><simpara><literal>128 B</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Values of array properties</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For strings and arrays, where data can be of variable length, data is stored in one or more 120B chunks, with 8B record overhead.
The sizes of these blocks can actually be configured when the store is created using the <literal>string_block_size</literal> and <literal>array_block_size</literal> parameters.
The size of each record type can also be used to calculate the storage requirements of a Neo4j graph or the appropriate cache size for each file buffer cache.
Note that some strings and arrays can be stored without using the string store or the array store respectively, see <xref linkend="short-strings"/> and <xref linkend="short-arrays"/>.</simpara>
<simpara>Neo4j uses multiple file buffer caches, one for each different storage file.
Each file buffer cache divides its storage file into a number of equally sized windows.
Each cache window contains an even number of storage records.
The cache holds the most active cache windows in memory and tracks hit vs. miss ratio for the windows.
When the hit ratio of an uncached window gets higher than the miss ratio of a cached window, the cached window gets evicted and the previously uncached window is cached instead.</simpara>
<important><simpara>Note that the block sizes can only be configured at store creation time.</simpara></important>
<section id="_configuration">
<title>Configuration</title>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="35*"/>
<colspec colname="col_2" colwidth="30*"/>
<colspec colname="col_3" colwidth="35*"/>
<thead>
<row>
<entry align="left" valign="top"> Parameter                 </entry>
<entry align="left" valign="top"> Possible values   </entry>
<entry align="left" valign="top"> Effect</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>use_memory_mapped_buffers</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal> or <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If set to <literal>true</literal> Neo4j will use the operating systems memory mapping functionality for the file buffer cache windows.
  If set to <literal>false</literal> Neo4j will use its own buffer implementation.
  In this case the buffers will reside in the JVM heap which needs to be increased accordingly.
  The default value for this parameter is <literal>true</literal>, except on Windows.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.nodestore.db.mapped_memory</literal></simpara></entry>
<entry align="center" valign="middle" morerows="6"><simpara>The maximum amount of memory to use for memory mapped buffers for this file buffer cache.
  The default unit is <literal>MiB</literal>, for other units use any of the following suffixes: <literal>B</literal>, <literal>k</literal>, <literal>M</literal> or <literal>G</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>The maximum amount of memory to use for the file buffer cache of the node storage file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.relationshipstore.db.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum amount of memory to use for the file buffer cache of the relationship store file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.propertystore.db.index.keys.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum amount of memory to use for the file buffer cache of the something-something file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.propertystore.db.index.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum amount of memory to use for the file buffer cache of the something-something file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.propertystore.db.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum amount of memory to use for the file buffer cache of the property storage file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.propertystore.db.strings.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum amount of memory to use for the file buffer cache of the string property storage file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.propertystore.db.arrays.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum amount of memory to use for the file buffer cache of the array property storage file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>string_block_size</literal></simpara></entry>
<entry align="center" valign="middle" morerows="1"><simpara>The number of bytes per block.</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the block size for storing strings.
  This parameter is only honored when the store is created, otherwise it is ignored.
  Note that each character in a string occupies two bytes, meaning that a block size of 120 (the default size) will hold a 60 character long string before overflowing into a second block.
  Also note that each block carries an overhead of 8 bytes.
  This means that if the block size is 120, the size of the stored records will be 128 bytes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>array_block_size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the block size for storing arrays.
  This parameter is only honored when the store is created, otherwise it is ignored.
  The default block size is 120 bytes, and the overhead of each block is the same as for string blocks, i.e., 8 bytes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>dump_configuration</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal> or <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If set to <literal>true</literal> the current configuration settings will be written to the default system output, mostly the console or the logfiles.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When memory mapped buffers are used (<literal>use_memory_mapped_buffers = true</literal>) the heap size of the JVM must be smaller than the total available memory of the computer, minus the total amount of memory used for the buffers.
When heap buffers are used (<literal>use_memory_mapped_buffers = false</literal>) the heap size of the JVM must be large enough to contain all the buffers, plus the runtime heap memory requirements of the application and the object cache.</simpara>
<simpara>When reading the configuration parameters on startup Neo4j will automatically configure the parameters that are not specified.
The cache sizes will be configured based on the available memory on the computer, how much is used by the JVM heap, and how large the storage files are.</simpara>
</section>
</section>
<section id="_object_cache">
<title>Object cache</title>
<sidebar>
<title>Quick info</title>
<itemizedlist>
<listitem>
<simpara>
The object cache is sometimes called <emphasis>high level cache</emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
It caches the Neo4j data in a form optimized for fast traversal.
</simpara>
</listitem>
</itemizedlist>
</sidebar>
<simpara>The object cache caches individual nodes and relationships and their properties in a form that is optimized for fast traversal of the graph.
There are two different categories of object caches in Neo4j.</simpara>
<simpara>There is the reference caches.
Here Neo4j will utilize as much as it can out of the allocated heap memory for the JVM for object caching and relies on garbage collection for eviction from the cache in an LRU manner.
Note however that Neo4j is &#8220;competing&#8221; for the heap space with other objects in the same JVM, such as a your application, if deployed in embedded mode, and Neo4j will let the application &#8220;win&#8221; by using less memory if the application needs more.</simpara>
<note><simpara>The High-Performance Cache described below is only available in the Neo4j Enterprise Edition.</simpara></note>
<simpara>The other is the <emphasis>High-Performance Cache</emphasis> which gets assigned a certain amount of space in the JVM heap and will purge objects whenever it grows bigger than that.
It is assigned a maximum amount of memory which the sum of all cached objects in it will not exceed.
Objects will be evicted from cache when the maximum size is about to be reached, instead of relying on garbage collection (GC) to make that decision.
Here the competition with other objects in the heap as well as GC-pauses can be better controlled since the cache gets assigned a maximum heap space usage.
The overhead of the High-Performance Cache is also much smaller as well as insert/lookup times faster than for reference caches.</simpara>
<tip><simpara>The use of heap memory is subject to the java garbage collector&#8201;&#8212;&#8201;depending on the cache type some tuning might be needed to play well with the GC at large heap sizes.
Therefore, assigning a large heap for Neo4j&#8217;s sake isn&#8217;t always the best strategy as it may lead to long GC-pauses.
Instead leave some space for Neo4j&#8217;s filesystem caches.
These are outside of the heap and under under the kernel&#8217;s direct control, thus more efficiently managed.</simpara></tip>
<simpara>The content of this cache are objects with a representation geared towards supporting the Neo4j object API and graph traversals.
Reading from this cache is 5 to 10 times faster than reading from the file buffer cache.
This cache is contained in the heap of the JVM and the size is adapted to the current amount of available heap memory.</simpara>
<simpara>Nodes and relationships are added to the object cache as soon as they are accessed.
The cached objects are however populated lazily.
The properties for a node or relationship are not loaded until properties are accessed for that node or relationship.
String (and array) properties are not loaded until that particular property is accessed.
The relationships for a particular node is also not loaded until the relationships are accessed for that node.</simpara>
<section id="_configuration_2">
<title>Configuration</title>
<simpara>The main configuration parameter for the object cache is the <literal>cache_type</literal> parameter.
This specifies which cache implementation to use for the object cache.
Note that there will exist two cache instances, one for nodes and one for relationships.
The available cache types are:</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="15*"/>
<colspec colname="col_2" colwidth="85*"/>
<thead>
<row>
<entry align="left" valign="top"> <literal>cache_type</literal> </entry>
<entry align="left" valign="top"> Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Do not use a high level cache. No objects will be cached.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>soft</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Provides optimal utilization of the available memory.
                 Suitable for high performance traversal.
                 May run into GC issues under high load if the frequently accessed parts of the graph does not fit in the cache.</simpara>
<simpara>                 This is the default cache implementation.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>weak</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Provides short life span for cached objects.
                 Suitable for high throughput applications where a larger portion of the graph than what can fit into memory is frequently accessed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>strong</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This cache will hold on to <emphasis role="strong">all data</emphasis> that gets loaded to never release it again.
                 Provides good performance if your graph is small enough to fit in memory.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>hpc</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The High-Performance Cache. Provides means of assigning a specific amount of memory to dedicate to caching loaded nodes and relationships.
                 Small footprint and fast insert/lookup. Should be the best option for most scenarios. See below on how to configure it.
                 Note that this option is only available in the Neo4j Enterprise Edition.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_high_performance_cache">
<title>High-Performance Cache</title>
<simpara>Since the High-Performance Cache operates with a maximum size in the JVM it may be configured per use case for optimal performance.
There are two aspects of the cache size.</simpara>
<simpara>One is the size of the array referencing the objects that are put in the cache.
It is specified as a fraction of the heap, for example specifying <literal>5</literal> will let that array itself take up 5% out of the entire heap.
Increasing this figure (up to a maximum of 10) will reduce the chance of hash collisions at the expense of more heap used for it.
More collisions means more redundant loading of objects from the low level cache.</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="35*"/>
<colspec colname="col_2" colwidth="55*"/>
<colspec colname="col_3" colwidth="10*"/>
<thead>
<row>
<entry align="left" valign="top"> <literal>configuration option</literal>            </entry>
<entry align="left" valign="top"> Description (what it controls)                                                                 </entry>
<entry align="left" valign="top"> Example value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>node_cache_array_fraction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Fraction of the heap to dedicate to the array holding the nodes in the cache (max 10).</simpara></entry>
<entry align="left" valign="top"><simpara><literal>7</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>relationship_cache_array_fraction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Fraction of the heap to dedicate to the array holding the relationships in the cache (max 10).</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The other aspect is the maximum size of all the objects in the cache. It is specified as size in bytes, for example <literal>500M</literal> for 500 megabytes or <literal>2G</literal> for two gigabytes.
Right before the maximum size is reached a <literal>purge</literal> is performed where (currently) random objects are evicted from the cache until the cache size gets below 90% of the maximum size.
Optimal settings for the maximum size depends on the size of your graph.
The configured maximum size should leave enough room for other objects to coexist in the same JVM, but at the same time large enough to keep loading from the low level cache at a minimum.
Predicted load on the JVM as well as layout of domain level objects should also be take into consideration.</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="65*"/>
<colspec colname="col_3" colwidth="10*"/>
<thead>
<row>
<entry align="left" valign="top"> <literal>configuration option</literal>   </entry>
<entry align="left" valign="top"> Description (what it controls)                                           </entry>
<entry align="left" valign="top"> Example value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>node_cache_size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Maximum size of the heap memory to dedicate to the cached nodes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>2G</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>relationship_cache_size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Maximum size of the heap memory to dedicate to the cached relationships.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>800M</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>You can read about references and relevant JVM settings for Sun HotSpot here:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html">Understanding soft/weak references</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://jeremymanson.blogspot.com/2009/07/how-hotspot-decides-to-clear_07.html">How Hotspot Decides to Clear SoftReferences</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://www.oracle.com/technetwork/java/hotspotfaq-138619.html#gc_softrefs">HotSpot FAQ</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section id="configuration-logical-logs">
<title>Logical logs</title>
<simpara>Logical logs in Neo4j are the journal of which operations happens and are the source of truth in scenarios where the database needs to be recovered after a crash or similar.
Logs are rotated every now and then (defaults to when they surpass 25 Mb in size) and the amount of legacy logs to keep can be configured.
Purpose of keeping a history of logical logs include being able to serve incremental backups as well as keeping an HA cluster running.</simpara>
<simpara>For any given configuration at least the latest non-empty logical log will be kept, but configuration can be supplied to control how much more to keep.
There are several different means of controlling it and the format in which configuration is supplied is:</simpara>
<programlisting language="plain" linenumbering="unnumbered">keep_logical_logs=&lt;true/false&gt;
keep_logical_logs=&lt;amount&gt; &lt;type&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="plain" linenumbering="unnumbered"># Will keep logical logs indefinitely
keep_logical_logs=true

# Will keep only the most recent non-empty log
keep_logical_logs=false

# Will keep logical logs which contains any transaction committed within 30 days
keep_logical_logs=30 days

# Will keep logical logs which contains any of the most recent 500 000 transactions
keep_logical_logs=500k txs</programlisting>
<simpara>Full list:</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<?dbhtml table-width="75%"?>
<?dbfo table-width="75%"?>
<?dblatex table-width="75%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="48*"/>
<colspec colname="col_2" colwidth="191*"/>
<colspec colname="col_3" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top"> Type      </entry>
<entry align="left" valign="top"> Description </entry>
<entry align="left" valign="top"> Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>files</simpara></entry>
<entry align="left" valign="top"><simpara>Number of most recent logical log files to keep</simpara></entry>
<entry align="left" valign="top"><simpara>"10 files"</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>size</simpara></entry>
<entry align="left" valign="top"><simpara>Max disk size to allow log files to occupy</simpara></entry>
<entry align="left" valign="top"><simpara>"300M size" or "1G size"</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>txs</simpara></entry>
<entry align="left" valign="top"><simpara>Number of latest transactions to keep Keep</simpara></entry>
<entry align="left" valign="top"><simpara>"250k txs" or "5M txs"</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>hours</simpara></entry>
<entry align="left" valign="top"><simpara>Keep logs which contains any transaction committed within N hours from current time</simpara></entry>
<entry align="left" valign="top"><simpara>"10 hours"</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>days</simpara></entry>
<entry align="left" valign="top"><simpara>Keep logs which contains any transaction committed within N days from current time</simpara></entry>
<entry align="left" valign="top"><simpara>"50 days"</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="configuration-jvm">
<title>JVM Settings</title>
<section id="_background">
<title>Background</title>
<simpara>There are two main memory parameters for the JVM, one controls the heap space and the other controls the stack space. The heap space parameter is the most important one for Neo4j, since this governs how many objects you can allocate. The stack space parameter governs the how deep the call stack of your application is allowed to get.</simpara>
<simpara>When it comes to heap space the general rule is: the larger heap space you have the better, but make sure the heap fits in the RAM memory of the computer. If the heap is paged out to disk performance will degrade rapidly. Having a heap that is much larger than what your application needs is not good either, since this means that the JVM will accumulate a lot of dead objects before the garbage collector is executed, this leads to long garbage collection pauses and undesired performance behavior.</simpara>
<simpara>Having a larger heap space will mean that Neo4j can handle larger transactions and more concurrent transactions. A large heap space will also make Neo4j run faster since it means Neo4j can fit a larger portion of the graph in its caches, meaning that the nodes and relationships your application uses frequently are always available quickly. The default heap size for a 32bit JVM is 64MB (and 30% larger for 64bit), which is too small for most real applications.</simpara>
<simpara>Neo4j works fine with the default stack space configuration, but if your application implements some recursive behavior it is a good idea to increment the stack size. Note that the stack size is shared for all threads, so if you application is running a lot of concurrent threads it is a good idea to increase the stack size.</simpara>
<itemizedlist>
<listitem>
<simpara>
The heap size is set by specifying the <literal>-Xmx???m</literal> parameter to hotspot, where <literal>???</literal> is the heap size in megabytes. Default heap size is 64MB for 32bit JVMs, 30% larger (appr. 83MB) for 64bit JVMs.
</simpara>
</listitem>
<listitem>
<simpara>
The stack size is set by specifying the <literal>-Xss???m</literal> parameter to hotspot, where <literal>???</literal> is the stack size in megabytes. Default stack size is 512kB for 32bit JVMs on Solaris, 320kB for 32bit JVMs on Linux (and Windows), and 1024kB for 64bit JVMs.
</simpara>
</listitem>
</itemizedlist>
<simpara>Most modern CPUs implement a <ulink url="http://en.wikipedia.org/wiki/Non-Uniform_Memory_Access">Non-Uniform Memory Access (NUMA) architecture</ulink>, where different parts of the memory have different access speeds. Suns Hotspot JVM is able to allocate objects with awareness of the NUMA structure as of version 1.6.0 update 18. When enabled this can give up to 40% performance improvements. To enabled the NUMA awareness, specify the <literal>-XX:+UseNUMA</literal> parameter (works only when using the Parallel Scavenger garbage collector (default or <literal>-XX:+UseParallelGC</literal> not the concurrent mark and sweep one).</simpara>
<simpara>Properly configuring memory utilization of the JVM is crucial for optimal performance.
As an example, a poorly configured JVM could spend all CPU time performing garbage collection (blocking all threads from performing any work).
Requirements such as latency, total throughput and available hardware have to be considered to find the right setup.
In production, Neo4j should run on a multi core/CPU platform with the JVM in server mode.</simpara>
</section>
<section id="_configuring_heap_size_and_gc">
<title>Configuring heap size and GC</title>
<simpara>A large heap allows for larger node and relationship caches&#8201;&#8212;&#8201;which is a good thing&#8201;&#8212;&#8201;but large heaps can also lead to latency problems caused by full garbage collection.
The different high level cache implementations available in Neo4j together with a suitable JVM configuration of heap size and garbage collection (GC) should be able to handle most workloads.</simpara>
<simpara>The default cache (soft reference based LRU cache) works best with a heap that never gets full: a graph where the most used nodes and relationships can be cached.
If the heap gets too full there is a risk that a full GC will be triggered; the larger the heap, the longer it can take to determine what soft references should be cleared.</simpara>
<simpara>Using the strong reference cache means that <emphasis>all</emphasis> the nodes and relationships being used must fit in the available heap.
Otherwise there is a risk of getting out-of-memory exceptions.
The soft reference and strong reference caches are well suited for applications were the overal throughput is important.</simpara>
<simpara>The weak reference cache basically needs enough heap to handle the peak load of the application&#8201;&#8212;&#8201;peak load multiplied by the average memory required per request.
It is well suited for low latency requirements were GC interuptions are not acceptable.</simpara>
<important><simpara>When running Neo4j on Windows, keep in mind that the memory mapped buffers are allocated on heap by default, so they need to be taken into account when determining heap size.</simpara></important>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>Guidelines for heap size</title>
<?dbhtml table-width="75%"?>
<?dbfo table-width="75%"?>
<?dblatex table-width="75%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="80*"/>
<colspec colname="col_2" colwidth="80*"/>
<colspec colname="col_3" colwidth="80*"/>
<colspec colname="col_4" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Number of primitives</entry>
<entry align="left" valign="top">RAM size</entry>
<entry align="left" valign="top">Heap configuration</entry>
<entry align="left" valign="top">Reserved RAM for the OS</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>10M</simpara></entry>
<entry align="left" valign="top"><simpara>2GB</simpara></entry>
<entry align="left" valign="top"><simpara>512MB</simpara></entry>
<entry align="left" valign="top"><simpara>the rest</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>100M</simpara></entry>
<entry align="left" valign="top"><simpara>8GB+</simpara></entry>
<entry align="left" valign="top"><simpara>1-4GB</simpara></entry>
<entry align="left" valign="top"><simpara>1-2GB</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1B+</simpara></entry>
<entry align="left" valign="top"><simpara>16GB-32GB+</simpara></entry>
<entry align="left" valign="top"><simpara>4GB+</simpara></entry>
<entry align="left" valign="top"><simpara>1-2GB</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<tip><simpara>The recommended garbage collector to use when running Neo4j in production is the Concurrent Mark and Sweep Compactor turned on by supplying <literal>-XX:+UseConcMarkSweepGC</literal> as a JVM parameter.</simpara></tip>
<simpara>When having made sure that the heap size is well configured the second thing to tune in order to tune the garbage collector for your application is to specify the sizes of the different generations of the heap. The default settings are well tuned for "normal" applications, and work quite well for most applications, but if you have an application with either really high allocation rate, or a lot of long lived objects you might want to consider tuning the sizes of the heap generation. The ratio between the young and tenured generation of the heap is specified by using the <literal>-XX:NewRatio=#</literal> command line option (where <literal>#</literal> is replaced by a number). The default ratio is 1:12 for client mode JVM, and 1:8 for server mode JVM. You can also specify the size of the young generation explicitly using the <literal>-Xmn</literal> command line option, which works just like the <literal>-Xmx</literal> option that specifies the total heap space.</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">GC shortname </entry>
<entry align="left" valign="top">Generation </entry>
<entry align="left" valign="top"> Command line parameter </entry>
<entry align="left" valign="top">Comment</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Copy</simpara></entry>
<entry align="left" valign="top"><simpara>Young</simpara></entry>
<entry align="left" valign="top"><simpara><literal>-XX:+UseSerialGC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Copying collector</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MarkSweepCompact</simpara></entry>
<entry align="left" valign="top"><simpara>Tenured</simpara></entry>
<entry align="left" valign="top"><simpara><literal>-XX:+UseSerialGC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Mark and Sweep Compactor</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ConcurrentMarkSweep</simpara></entry>
<entry align="left" valign="top"><simpara>Tenured</simpara></entry>
<entry align="left" valign="top"><simpara><literal>-XX:+UseConcMarkSweepGC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Concurrent Mark and Sweep Compactor</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ParNew</simpara></entry>
<entry align="left" valign="top"><simpara>Young</simpara></entry>
<entry align="left" valign="top"><simpara><literal>-XX:+UseParNewGC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The parallel Young Generation Collector&#8201;&#8212;&#8201;can only be used with the Concurrent mark and sweep compactor.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PS Scavenge</simpara></entry>
<entry align="left" valign="top"><simpara>Young</simpara></entry>
<entry align="left" valign="top"><simpara><literal>-XX:+UseParallelGC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The parallel object scavenger</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PS MarkSweep</simpara></entry>
<entry align="left" valign="top"><simpara>Tenured</simpara></entry>
<entry align="left" valign="top"><simpara><literal>-XX:+UseParallelGC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The parallel mark and sweep collector</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These are the default configurations on some platforms according to our non-exhaustive research:</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">JVM </entry>
<entry align="left" valign="top">-d32 -client </entry>
<entry align="left" valign="top">-d32 -server </entry>
<entry align="left" valign="top">-d64 -client </entry>
<entry align="left" valign="top">-d64 -server</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Mac OS X Snow Leopard, 64-bit, Hotspot 1.6.0_17</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ParNew</literal> and <literal>ConcurrentMarkSweep</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS Scavenge</literal> and <literal>PS MarkSweep</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>ParNew</literal> and <literal>ConcurrentMarkSweep</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS Scavenge</literal> and <literal>PS MarkSweep</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ubuntu, 32-bit, Hotspot 1.6.0_16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Copy</literal> and <literal>MarkSweepCompact</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Copy</literal> and <literal>MarkSweepCompact</literal></simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section id="short-strings">
<title>Compressed storage of short strings</title>
<simpara>Neo4j will try to classify your strings in a short string class and if it manages that it will treat it accordingly.
In that case, it will be stored without indirection in the property store, inlining it instead in the property record,
meaning that the dynamic string store will not be involved in storing that value, leading to reduced disk footprint.
Additionally, when no string record is needed to store the property, it can be read and written in a single lookup,
leading to performance improvements and less disk space required.</simpara>
<simpara>The various classes for short strings are:</simpara>
<itemizedlist>
<listitem>
<simpara>
Numerical, consisting of digits 0..9 and the punctuation space, period, dash, plus, comma and apostrophe.
</simpara>
</listitem>
<listitem>
<simpara>
Date, consisting of digits 0..9 and the punctuation space dash, colon, slash, plus and comma.
</simpara>
</listitem>
<listitem>
<simpara>
Hex (lower case), consisting of digits 0..9 and lower case letters a..f
</simpara>
</listitem>
<listitem>
<simpara>
Hex (upper case), consisting of digits 0..9 and upper case letters a..f
</simpara>
</listitem>
<listitem>
<simpara>
Upper case, consisting of upper case letters A..Z, and the punctuation space, underscore, period, dash, colon and slash.
</simpara>
</listitem>
<listitem>
<simpara>
Lower case, like upper but with lower case letters a..z instead of upper case
</simpara>
</listitem>
<listitem>
<simpara>
E-mail, consisting of lower case letters a..z and the punctuation comma, underscore, period, dash, plus and the at sign (@).
</simpara>
</listitem>
<listitem>
<simpara>
URI, consisting of lower case letters a..z, digits 0..9 and most punctuation available.
</simpara>
</listitem>
<listitem>
<simpara>
Alpha-numerical, consisting of both upper and lower case letters a..zA..z, digits 0..9 and punctuation space and underscore.
</simpara>
</listitem>
<listitem>
<simpara>
Alpha-symbolical, consisting of both upper and lower case letters a..zA..Z and the punctuation space, underscore, period, dash, colon, slash, plus, comma, apostrophe, at sign, pipe and semicolon.
</simpara>
</listitem>
<listitem>
<simpara>
European, consisting of most accented european characters and digits plus punctuation space, dash, underscore and period&#8201;&#8212;&#8201;like latin1 but with less punctuation.
</simpara>
</listitem>
<listitem>
<simpara>
Latin 1.
</simpara>
</listitem>
<listitem>
<simpara>
UTF-8.
</simpara>
</listitem>
</itemizedlist>
<simpara>In addition to the string&#8217;s contents, the number of characters also determines if the string can be inlined or not. Each class has its own character count limits, which are</simpara>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>Character count limits</title>
<?dbhtml table-width="50%"?>
<?dbfo table-width="50%"?>
<?dblatex table-width="50%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="163*"/>
<colspec colname="col_2" colwidth="49*"/>
<thead>
<row>
<entry align="left" valign="top"> String class </entry>
<entry align="left" valign="top"> Character count limit</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Numerical, Date and Hex</simpara></entry>
<entry align="left" valign="top"><simpara><literal>54</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Uppercase, Lowercase and E-mail</simpara></entry>
<entry align="left" valign="top"><simpara><literal>43</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>URI, Alphanumerical and Alphasymbolical</simpara></entry>
<entry align="left" valign="top"><simpara><literal>36</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>European</simpara></entry>
<entry align="left" valign="top"><simpara><literal>31</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Latin1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>27</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>UTF-8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>14</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>That means that the largest inline-able string is 54 characters long and must be of the Numerical class and also that all Strings of size 14 or less will always be inlined.</simpara>
<simpara>Also note that the above limits are for the default 41 byte PropertyRecord layout&#8201;&#8212;&#8201;if that parameter is changed via editing the source and recompiling, the above have to be recalculated.</simpara>
</section>
<section id="short-arrays">
<title>Compressed storage of short arrays</title>
<simpara>Neo4j will try to store your primitive arrays in a compressed way, so as to save disk space and possibly an I/O operation.
To do that, it employs a "bit-shaving" algorithm that tries to reduce the number of bits required for storing the members
of the array. In particular:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
For each member of the array, it determines the position of leftmost set bit.
</simpara>
</listitem>
<listitem>
<simpara>
Determines the largest such position among all members of the array
</simpara>
</listitem>
<listitem>
<simpara>
It reduces all members to that number of bits
</simpara>
</listitem>
<listitem>
<simpara>
Stores those values, prefixed by a small header.
</simpara>
</listitem>
</orderedlist>
<simpara>That means that when even a single negative value is included in the array then the natural size of the primitives will be used.</simpara>
<simpara>There is a possibility that the result can be inlined in the property record if:</simpara>
<itemizedlist>
<listitem>
<simpara>
It is less than 24 bytes after compression
</simpara>
</listitem>
<listitem>
<simpara>
It has less than 64 members
</simpara>
</listitem>
</itemizedlist>
<simpara>For example, an array long[] {0L, 1L, 2L, 4L} will be inlined, as the largest entry (4) will require 3 bits to store so the whole array will be stored in 4*3=12 bits. The array long[] {-1L, 1L, 2L, 4L}
however will require the whole 64 bits for the -1 entry so it needs 64*4 = 32 bytes and it will end up in the dynamic store.</simpara>
</section>
<section id="configuration-io-examples">
<title>Memory mapped IO settings</title>
<section id="_introduction_5">
<title>Introduction</title>
<simpara>Each file in the Neo4j store can use memory mapped I/O for reading/writing.
Best performance is achieved if the full file can be memory mapped but if
there isn&#8217;t enough memory for that Neo4j will try and make the best use of
the memory it gets (regions of the file that get accessed often will more
likely be memory mapped).</simpara>
<important><simpara>Neo4j makes heavy use of the <literal>java.nio</literal> package. Native I/O will result in
memory being allocated outside the normal Java heap so  that memory usage
needs to be taken into consideration. Other processes running on the OS will
impact the availability of such memory. Neo4j will require all of the heap
memory of the JVM plus the memory to be used for memory mapping to be available
as physical memory. Other processes may thus not use more than what is
available after the configured memory allocation is made for Neo4j.</simpara></important>
<simpara>A well configured OS
with large disk caches will help a lot once we get cache misses in the node
and relationship caches. Therefore it is not a good idea to use all available memory as Java heap.</simpara>
<simpara>If you look into the directory of your Neo4j database, you will find its store files, all prefixed by <literal>neostore</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>nodestore</literal> stores information about nodes
</simpara>
</listitem>
<listitem>
<simpara>
<literal>relationshipstore</literal> holds all the relationships
</simpara>
</listitem>
<listitem>
<simpara>
<literal>propertystore</literal> stores information of properties and all simple properties such as primitive types (both for relationships and nodes)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>propertystore strings</literal> stores all string properties
</simpara>
</listitem>
<listitem>
<simpara>
<literal>propertystore arrays</literal> stores all array properties
</simpara>
</listitem>
</itemizedlist>
<simpara>There are other files there as well, but they are normally not interesting in this context.</simpara>
<simpara>This is how the default memory mapping configuration looks:</simpara>
<programlisting language="plain" linenumbering="unnumbered">neostore.nodestore.db.mapped_memory=25M
neostore.relationshipstore.db.mapped_memory=50M
neostore.propertystore.db.mapped_memory=90M
neostore.propertystore.db.strings.mapped_memory=130M
neostore.propertystore.db.arrays.mapped_memory=130M</programlisting>
</section>
<section id="_optimizing_for_traversal_speed_example">
<title>Optimizing for traversal speed example</title>
<simpara>To tune the memory mapping settings start by investigating the size of the different store files found in the directory of your Neo4j database. Here is an example of some of the files and sizes in a Neo4j database:</simpara>
<programlisting language="plain" linenumbering="unnumbered">14M neostore.nodestore.db
510M neostore.propertystore.db
1.2G neostore.propertystore.db.strings
304M neostore.relationshipstore.db</programlisting>
<simpara>In this example the application is running on a machine with 4GB of RAM. We&#8217;ve reserved about 2GB for the OS and other programs. The Java heap is set to 1.5GB, that leaves about 500MB of RAM that can be used for memory mapping.</simpara>
<tip><simpara>If traversal speed is the highest priority it is good to memory map as much as possible of the node- and relationship stores.</simpara></tip>
<simpara>An example configuration on the example machine focusing on traversal speed would then look something like:</simpara>
<programlisting language="plain" linenumbering="unnumbered">neostore.nodestore.db.mapped_memory=15M
neostore.relationshipstore.db.mapped_memory=285M
neostore.propertystore.db.mapped_memory=100M
neostore.propertystore.db.strings.mapped_memory=100M
neostore.propertystore.db.arrays.mapped_memory=0M</programlisting>
</section>
<section id="configuration-batchinsert">
<title>Batch insert example</title>
<simpara>Read general information on batch insertion in <xref linkend="batchinsert"/>.</simpara>
<simpara>The configuration should suit the data set you are about to inject using BatchInsert. Lets say we have a random-like graph with 10M nodes and 100M relationships. Each node (and maybe some relationships) have different properties of string and Java primitive types (but no arrays). The important thing with a random graph will be to give lots of memory to the relationship and node store:</simpara>
<programlisting language="plain" linenumbering="unnumbered">neostore.nodestore.db.mapped_memory=90M
neostore.relationshipstore.db.mapped_memory=3G
neostore.propertystore.db.mapped_memory=50M
neostore.propertystore.db.strings.mapped_memory=100M
neostore.propertystore.db.arrays.mapped_memory=0M</programlisting>
<simpara>The configuration above will fit the entire graph (with exception to properties) in memory.</simpara>
<simpara>A rough formula to calculate the memory needed for the nodes:</simpara>
<programlisting language="plain" linenumbering="unnumbered">number_of_nodes * 9 bytes</programlisting>
<simpara>and for relationships:</simpara>
<programlisting language="plain" linenumbering="unnumbered">number_of_relationships * 33 bytes</programlisting>
<simpara>Properties will typically only be injected once and never read so a few megabytes for the property store and string store is usually enough. If you have very large strings or arrays you may want to increase the amount of memory assigned to the string and array store files.</simpara>
<simpara>An important thing to remember is that the above configuration will need a Java heap of 3.3G+ since in batch inserter mode normal Java buffers that gets allocated on the heap will be used instead of memory mapped ones.</simpara>
</section>
</section>
<section id="linux-performance-guide">
<title>Linux Performance Guide</title>
<section id="_introduction_6">
<title>Introduction</title>
<simpara>The key to achieve good performance on reads and writes is to have lots of RAM since disks are so slow. This guide will focus on achieving good write performance on a Linux kernel based operating system.</simpara>
<simpara>If you have not already read the information available in <xref linkend="embedded-configuration"/>, do that now to get some basic knowledge on memory mapping and store files with Neo4j.</simpara>
<simpara>This section will guide you through how to set up a file system benchmark and use it to configure your system in a better way.</simpara>
</section>
<section id="_file_system_benchmark">
<title>File system benchmark</title>
<section id="_setup">
<title>Setup</title>
<simpara>Create a large file with random data. The file should fit in RAM so if your machine has 4GB of RAM a 1-2GB file with random data will be enough. After the file has been created we will read the file sequentially a few times to make sure it is cached.</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ dd if=/dev/urandom of=store bs=1M count=1000
1000+0 records in
1000+0 records out
1048576000 bytes (1.0 GB) copied, 263.53 s, 4.0 MB/s
$
$ dd if=store of=/dev/null bs=100M
10+0 records in
10+0 records out
1048576000 bytes (1.0 GB) copied, 38.6809 s, 27.1 MB/s
$
$ dd if=store of=/dev/null bs=100M
10+0 records in
10+0 records out
1048576000 bytes (1.0 GB) copied, 1.52365 s, 688 MB/s
$ dd if=store of=/dev/null bs=100M
10+0 records in
10+0 records out
1048576000 bytes (1.0 GB) copied, 0.776044 s, 1.4 GB/s</programlisting>
<simpara>If you have a standard hard drive in the machine you may know that it is not capable of transfer speeds as high as 1.4GB/s. What is measured is how fast we can read a file that is cached for us by the operating system.</simpara>
<simpara>Next we will use a small utility that simulates the Neo4j kernel behavior to benchmark write speed of the system.</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ git clone git@github.com:neo4j-contrib/tooling.git
...
$ cd tooling/write-test/
$ mvn compile
[INFO] Scanning for projects...
...
$ ./run
Usage: &lt;large file&gt; &lt;log file&gt; &lt;[record size] [min tx size] [max tx size] [tx count] &lt;[--nosync | --nowritelog | --nowritestore | --noread | --nomemorymap]&gt;&gt;</programlisting>
<simpara>The utility will be given a store file (large file we just created) and a name of a log file. Then a record size in bytes, min tx size, max tx size and transaction count must be set. When started the utility will map the large store file entirely in memory and read (transaction size) records from it randomly and then write them sequentially to the log file. The log file will then force changes to disk and finally the records will be written back to the store file.</simpara>
</section>
<section id="_running_the_benchmark">
<title>Running the benchmark</title>
<simpara>Lets try to benchmark 100 transactions of size 100-500 with a record size of 33 bytes (same record size used by the relationship store).</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ ./run store logfile 33 100 500 100
tx_count[100] records[30759] fdatasyncs[100] read[0.96802425 MB] wrote[1.9360485 MB]
Time was: 4.973
20.108585 tx/s, 6185.2 records/s, 20.108585 fdatasyncs/s, 199.32773 kB/s on reads, 398.65546 kB/s on writes</programlisting>
<simpara>We see that we get about 6185 record updates/s and 20 transactions/s with the current transaction size. We can change the transaction size to be bigger, for example writing 10 transactions of size 1000-5000 records:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ ./run store logfile 33 1000 5000 10
tx_count[10] records[24511] fdatasyncs[10] read[0.77139187 MB] wrote[1.5427837 MB]
Time was: 0.792
12.626263 tx/s, 30948.232 records/s, 12.626263 fdatasyncs/s, 997.35516 kB/s on reads, 1994.7103 kB/s on writes</programlisting>
<simpara>With larger transaction we will do fewer of them per second but record throughput will increase. Lets see if it scales, 10 transactions in under 1s then 100 of them should execute in about 10s:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ ./run store logfile 33 1000 5000 100
tx_count[100] records[308814] fdatasyncs[100] read[9.718763 MB] wrote[19.437527 MB]
Time was: 65.115
1.5357445 tx/s, 4742.594 records/s, 1.5357445 fdatasyncs/s, 152.83751 kB/s on reads, 305.67502 kB/s on writes</programlisting>
<simpara>This is not very linear scaling. We modified a bit more than 10x records in total but the time jumped up almost 100x. Running the benchmark watching vmstat output will reveal that something is not as it should be:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ vmstat 3
procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa
 0  1  47660 298884 136036 2650324    0    0     0 10239 1167 2268  5  7 46 42
 0  1  47660 302728 136044 2646060    0    0     0  7389 1267 2627  6  7 47 40
 0  1  47660 302408 136044 2646024    0    0     0 11707 1861 2016  8  5 48 39
 0  2  47660 302472 136060 2646432    0    0     0 10011 1704 1878  4  7 49 40
 0  1  47660 303420 136068 2645788    0    0     0 13807 1406 1601  4  5 44 47</programlisting>
<simpara>There are a lot of blocks going out to IO, way more than expected for the write speed we are seeing in the benchmark. Another observation that can be made is that the Linux kernel has spawned a process called "flush-x:x" (run top) that seems to be consuming a lot of resources.</simpara>
<simpara>The problem here is that the Linux kernel is trying to be smart and write out dirty pages from the virtual memory. As the benchmark will memory map a 1GB file and do random writes it is likely that this will result in 1/4 of the memory pages available on the system to be marked as dirty. The Neo4j kernel is not sending any system calls to the Linux kernel to write out these pages to disk however the Linux kernel decided to start doing so and it is a very bad decision. The result is that instead of doing sequential like writes down to disk (the logical log file) we are now doing random writes writing regions of the memory mapped file to disk.</simpara>
<simpara>It is possible to observe this behavior in more detail by looking at /proc/vmstat "nr_dirty" and "nr_writeback" values. By default the Linux kernel will start writing out pages at a very low ratio of dirty pages (10%).</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ sync
$ watch grep -A 1 dirty /proc/vmstat
...
nr_dirty 22
nr_writeback 0</programlisting>
<simpara>The "sync" command will write out all data (that needs writing) from memory to disk. The second command will watch the "nr_dirty" and "nr_writeback" count from vmstat. Now start the benchmark again and observe the numbers:</simpara>
<programlisting language="shell" linenumbering="unnumbered">nr_dirty 124947
nr_writeback 232</programlisting>
<simpara>The "nr_dirty" pages will quickly start to rise and after a while the "nr_writeback" will also increase meaning the Linux kernel is scheduling a lot of pages to write out to disk.</simpara>
</section>
<section id="_fixing_the_problem">
<title>Fixing the problem</title>
<simpara>As we have 4GB RAM on the machine and memory map a 1GB file that does not need its content written to disk (until we tell it to do so because of logical log rotation or Neo4j kernel shutdown) it should be possible to do endless random writes to that memory with high throughput. All we have to do is to tell the Linux kernel to stop trying to be smart. Edit the /etc/sysctl.conf (need root access) and add the following lines:</simpara>
<programlisting language="shell" linenumbering="unnumbered">vm.dirty_background_ratio = 50
vm.dirty_ratio = 80</programlisting>
<simpara>Then (as root) execute:</simpara>
<programlisting language="shell" linenumbering="unnumbered"># sysctl -p</programlisting>
<simpara>The "vm.dirty_background_ratio" tells at what ratio should the linux kernel start the background task of writing out dirty pages. We increased this from the default 10% to 50% and that should cover the 1GB memory mapped file.
The "vm.dirty_ratio" tells at what ratio all IO writes become synchronous,
meaning that we can not do IO calls without waiting for the underlying
device to complete them (which is something you never want to happen).</simpara>
<simpara>Rerun the benchmark:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ ./run store logfile 33 1000 5000 100
tx_count[100] records[265624] fdatasyncs[100] read[8.35952 MB] wrote[16.71904 MB]
Time was: 6.781
14.7470875 tx/s, 39171.805 records/s, 14.7470875 fdatasyncs/s, 1262.3726 kB/s on reads, 2524.745 kB/s on writes</programlisting>
<simpara>Results are now more in line with what can be expected, 10x more records modified results in 10x longer execution time. The vmstat utility will not report any absurd amount of IO blocks going out (it reports the ones caused by the fdatasync to the logical log) and Linux kernel will not spawn a "flush-x:x" background process writing out dirty pages caused by writes to the memory mapped store file.</simpara>
</section>
</section>
<section id="_file_system_tuning_for_high_io">
<title>File system tuning for high IO</title>
<simpara>In order to support the high IO load of small transactions from a database, the underlying file system should be tuned.
Symptoms for this are low CPU load with high iowait.
In this case, there are a couple of tweaks possible on Linux systems:</simpara>
<itemizedlist>
<listitem>
<simpara>
Disable access-time updates: <literal>noatime,nodiratime</literal> flags for disk mount command or in the <emphasis>/etc/fstab</emphasis> for the database disk volume mount.
</simpara>
</listitem>
<listitem>
<simpara>
Tune the IO scheduler for high disk IO on the database disk.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_setting_the_number_of_open_files">
<title>Setting the number of open files</title>
<simpara>Linux platforms impose an upper limit on the number of concurrent files a user may have open. This number is reported for the current user and session with the command</simpara>
<programlisting language="shell" linenumbering="unnumbered">user@localhost:~$ ulimit -n
1024</programlisting>
<simpara>The usual default of 1024 is often not enough, especially when many indexes are used or a server installation sees too many connections (network sockets count against that limit as well).
Users are therefore encouraged to increase that limit to a healthy value of 40000 or more, depending on usage patterns.
Setting this value via the <literal>ulimit</literal> command is possible only for the root user and that for that session only.
To set the value system wide you have to follow the instructions for your platform.</simpara>
<simpara>What follows is the procedure to set the open file descriptor limit to 40k for user neo4j under Ubuntu 10.04 and later.
If you opted to run the neo4j service as a different user, change the first field in step 2 accordingly.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Become root since all operations that follow require editing protected system files.
</simpara>
<programlisting language="shell" linenumbering="unnumbered">user@localhost:~$ sudo su -
Password:
root@localhost:~$</programlisting>
</listitem>
<listitem>
<simpara>
Edit <literal>/etc/security/limits.conf</literal> and add these two lines:
</simpara>
<programlisting language="shell" linenumbering="unnumbered">neo4j   soft    nofile  40000
neo4j   hard    nofile  40000</programlisting>
</listitem>
<listitem>
<simpara>
Edit <literal>/etc/pam.d/su</literal> and uncomment or add the following line:
</simpara>
<programlisting language="shell" linenumbering="unnumbered">session    required   pam_limits.so</programlisting>
</listitem>
<listitem>
<simpara>
A restart is required for the settings to take effect.
</simpara>
<simpara>After the above procedure, the neo4j user will have a limit of 40000 simultaneous open files. If you continue experiencing exceptions on <literal>Too many open files</literal> or <literal>Could not stat() directory</literal> then you may have to raise that limit further.</simpara>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter id="ha">
<title>High Availability</title>
<note><simpara>The High Availability features are only available in the Neo4j Enterprise Edition.</simpara></note>
<simpara>Neo4j High Availability or “Neo4j HA” provides the following two main features:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
It enables a <emphasis>fault-tolerant database architecture</emphasis>, where several Neo4j slave databases can be configured to be exact replicas of a single Neo4j master database.
  This allows the end-user system to be fully functional and both read and write to the database in the event of hardware failure.
</simpara>
</listitem>
<listitem>
<simpara>
It enables a <emphasis>horizontally scaling read-mostly architecture</emphasis> that enables the system to handle more read load than a single Neo4j database instance can handle.
</simpara>
</listitem>
</orderedlist>
<section id="ha-architecture">
<title>Architecture</title>
<simpara>Neo4j HA has been designed to make the transition from single machine to multi machine operation simple, by not having to change the already existing application.</simpara>
<simpara>Consider an existing application with Neo4j embedded and running on a single machine.
To deploy such an application in a multi machine setup the only required change is to switch the creation of the <literal>GraphDatabaseService</literal> from <literal>GraphDatabaseFactory</literal> to <literal>HighlyAvailableGraphDatabaseFactory</literal>.
Since both implement the same interface, no additional changes are required.</simpara>
<figure><title>Multiple Neo4j instances in HA mode</title>
<ulink url="images/ha-architecture.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/ha-architecture.svg" width="100%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>Neo4j Highly Available Cluster</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara>When running Neo4j in HA mode there is always a single master and zero or more slaves.
Compared to other master-slave replication setups Neo4j HA can handle write requests on all machines so there is no need to redirect those to the master specifically.</simpara>
<simpara>A slave will handle writes by synchronizing with the master to preserve consistency.
Writes to master can be configured to be optimistically pushed to 0 or more slaves.
By optimistically we mean the master will try to push to slaves before the transaction completes but if it fails the transaction will still be successful (different from normal replication factor).
All updates will however propagate from the master to other slaves eventually so a write from one slave may not be immediately visible on all other slaves.
This is the only difference between multiple machines running in HA mode compared to single machine operation.
All other ACID characteristics are the same.</simpara>
</section>
<section id="ha-configuration">
<title>Setup and configuration</title>
<simpara>Neo4j HA can be set up to accommodate differing requirements for load, fault tolerance and available hardware.</simpara>
<simpara>In HA mode, Neo4j instances form a cluster.
The instances monitor each others' availability to take account of instances joining and leaving the cluster.
They elect one instance to be the master, and designate the other instances to be slaves.</simpara>
<simpara>For installation instructions of a High Availability cluster see <xref linkend="ha-setup-tutorial"/>.</simpara>
<section id="_specifying_cluster_members">
<title>Specifying cluster members</title>
<simpara>Specify the instances that should form the cluster by supplying <literal>ha.initial_hosts</literal>, a comma-separated list of URLs.
When each instance starts, if it can contact any of the initial hosts, then it will form a cluster with them,
otherwise it will start its own cluster.</simpara>
<simpara>Note that the parameter is called <literal>ha.initial_hosts</literal> because it&#8217;s only used when instances initially join the cluster.
This means that you can extend the cluster without changing the configuration of existing instances.</simpara>
</section>
<section id="_server_configuration">
<title>Server configuration</title>
<simpara>If you are running Neo4j server, specify <literal>org.neo4j.server.database.mode=HA</literal> in <emphasis>neo4j-server.properties</emphasis>.</simpara>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>HA server configuration parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="35*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="12*"/>
<thead>
<row>
<entry align="left" valign="top"> Parameter Name                 </entry>
<entry align="left" valign="top"> Description                                      </entry>
<entry align="left" valign="top"> Example value </entry>
<entry align="left" valign="top"> Required?</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>org.neo4j.server.database.mode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to run as a single server or in HA mode.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>single or HA</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="_database_configuration">
<title>Database configuration</title>
<simpara>HA configuration parameters should be supplied alongside general Neo4j parameters in <emphasis>neo4j.properties</emphasis>.
There are many configurable parameters, most in most cases it isn&#8217;t necessary to modify the default values.
The only parameters that need to be specified are <literal>ha.server_id</literal> and <literal>ha.initial_hosts</literal>.</simpara>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>HA database configuration parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="35*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="12*"/>
<thead>
<row>
<entry align="left" valign="top"> Parameter Name        </entry>
<entry align="left" valign="top"> Description                                     </entry>
<entry align="left" valign="top"> Example value  </entry>
<entry align="left" valign="top"> Required?</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ha.server_id</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Id for a cluster instance. Must be unique within the cluster.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.initial_hosts</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A comma-separated list of other members of the cluster to join.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>server1:5001,server2:5001</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.cluster_server</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Host &amp; port to bind the cluster management communication.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>server1:5001</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.allow_init_cluster</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to allow this instance to create a cluster if unable to join.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.default_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Default timeout used for clustering timeouts. Override specific timeout settings with proper values if necessary. This value is the default value for settings ha.heartbeat_interval, ha.paxos_timeout and ha.learn_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.heartbeat_interval</literal></simpara></entry>
<entry align="left" valign="top"><simpara>How often heartbeat messages should be sent. Defaults to ha.default_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.heartbeat_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for heartbeats between cluster members. Should be at least twice that of ha.heartbeat_interval.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>11s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.broadcast_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for broadcasting values in cluster. Must consider end-to-end duration of Paxos algorithm. This value is the default value for settings ha.join_timeout and ha.leave_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>30s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.join_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for joining a cluster. Defaults to ha.broadcast_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>30s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.configuration_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for waiting for configuration from an existing cluster member during cluster join.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.leave_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for waiting for cluster leave to finish. Defaults to ha.broadcast_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>30s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.paxos_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Default timeout for all Paxos timeouts. Defaults to ha.default_timeout. This value is the default value for settings ha.phase1_timeout, ha.phase2_timeout and ha.election_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.phase1_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for Paxos phase 1. Defaults to ha.paxos_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.phase2_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for Paxos phase 2. Defaults to ha.paxos_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.learn_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for learning values. Defaults to ha.default_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.election_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for waiting for other members to finish a role election. Defaults to ha.paxos_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.read_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>How long a slave will wait for response from master before giving up.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>20s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.state_switch_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for waiting for instance to become master or slave.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>20s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.lock_read_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for taking remote (write) locks on slaves. Defaults to ha.read_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>20s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.max_concurrent_channels_per_slave</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Maximum number of connections a slave can have to the master.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>20</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.server</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Hostname and port to bind the HA server.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>my-domain.com:6001</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.slave_only</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether this instance should only participate as slave in cluster. If set to true, it will never be elected as master.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.branched_data_policy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Policy for how to handle branched data.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>keep_last or keep_all or keep_none</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.com_chunk_size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Max size of the data chunks that flows between master and slaves in HA. Bigger size may increase throughput, but may be more sensitive to variations in bandwidth, whereas lower size increases tolerance for bandwidth variations.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>2M</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.pull_interval</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Interval of pulling updates from master.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.tx_push_factor</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of slaves the master will ask to replicate a committed transaction.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.tx_push_strategy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Push strategy of a transaction to a slave during commit.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>fixed or round_robin</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section id="ha-how">
<title>How Neo4j HA operates</title>
<simpara>A Neo4j HA cluster operates cooperatively&#8201;&#8212;&#8201;each database instance contains the logic needed in order to coordinate with the other members of the cluster.
On startup a Neo4j HA database instance will try to connect to an existing cluster specified by configuration.
If the cluster exists, the instance will join it as a slave.
Otherwise the cluster will be created and the instance will become its master.</simpara>
<simpara>When performing a write transaction on a slave each write operation will be synchronized with the master (locks will be acquired on both master and slave).
When the transaction commits it will first be committed on the master and then, if successful, on the slave.
To ensure consistency, a slave has to be up to date with the master before performing a write operation.
This is built into the communication protocol between the slave and master, so that updates will be applied to a slave communicating with its master automatically.</simpara>
<simpara>Write transactions performed directly through the master will execute in the same way as running in normal non-HA mode.
On success the transaction will be pushed out to a configurable number of slaves (default one slave).
This is done optimistically meaning if the push fails the transaction will still be successful.
It&#8217;s also possible to configure push factor to 0 for higher write performance when writing directly through the master, although increasing the risk of losing any transaction not yet pulled by another slave if the master goes down.</simpara>
<simpara>Slaves can also be configured to pull updates asynchronously by setting the <literal>ha.pull_interval</literal> option.</simpara>
<simpara>Whenever a Neo4j database becomes unavailable, by means of for example hardware failure or network outages, the other database instances in the cluster will detect that and mark it as temporarily failed.
A database instance that becomes available after being unavailable will automatically catch up with the cluster.
If the master goes down another (best suited) member will be elected and have its role switched from slave to master after a quorum has been reached within the cluster.
When the new master has performed its role switch it will broadcast its availability to all the other members of the cluster.
Normally a new master is elected and started within just a few seconds and during this time no writes can take place (the writes will block or in rare cases throw an exception).
The only time this is not true is when an old master had changes that did not get replicated to any other member before becoming unavailable.
If the new master is elected and performs changes before the old master recovers, there will be two "branches" of the database after the point where the old master became unavailable.
The old master will move away its database (its "branch") and download a full copy from the new master, to become available as a slave in the cluster.</simpara>
<simpara>All this can be summarized as:</simpara>
<itemizedlist>
<listitem>
<simpara>
Write transactions can be performed on any database instance in a cluster.
</simpara>
</listitem>
<listitem>
<simpara>
Neo4j HA is fault tolerant and can continue to operate from any number of machines down to a single machine.
</simpara>
</listitem>
<listitem>
<simpara>
Slaves will be automatically synchronized with the master on write operations.
</simpara>
</listitem>
<listitem>
<simpara>
If the master fails a new master will be elected automatically.
</simpara>
</listitem>
<listitem>
<simpara>
The cluster automatically handles instances becoming unavailable (for example due to network issues), and also makes sure to accept them as members in the cluster when they are available again.
</simpara>
</listitem>
<listitem>
<simpara>
Transactions are atomic, consistent and durable but eventually propagated out to other slaves.
</simpara>
</listitem>
<listitem>
<simpara>
Updates to slaves are eventual consistent by nature but can be configured to be pushed optimistically from master during commit.
</simpara>
</listitem>
<listitem>
<simpara>
If the master goes down any running write transaction will be rolled back and new transactions will block or fail until a new master has become available.
</simpara>
</listitem>
<listitem>
<simpara>
Reads are highly available and the ability to handle read load scales with more database instances in the cluster.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="arbiter-instances">
<title>Arbiter Instances</title>
<simpara>A typical deployment of Neo4j will use a cluster of 3 machines to provide fault-tolerance and read scalability.
This setup is described in <xref linkend="ha-setup-tutorial"/>.</simpara>
<simpara>While having at least 3 instances is necessary for failover to happen in case the master becomes unavailable, it is not required for all instances to run the full Neo4j stack, which includes the database engine.
Instead, what is called arbiter instances can be deployed.
They can be regarded as cluster participants in that their role is to take part in master elections with the single purpose of breaking ties in the election process.
That makes possible a scenario where you have a cluster of 2 Neo4j database instances and an additional arbiter instance and still enjoy tolerance of a single failure of either of the 3 instances.</simpara>
<simpara>Arbiter instances are configured in the same way as Neo4j HA members are&#8201;&#8212;&#8201;through the <emphasis>neo4j.properties</emphasis> file in the installation&#8217;s <emphasis>conf/</emphasis> directory.
Settings that are not cluster specific are of course ignored, so you can easily start up an arbiter instance in place of a properly configured Neo4j instance.</simpara>
<simpara>To start an arbiter instance, call</simpara>
<programlisting language="shell" linenumbering="unnumbered">neo4j_home$ ./bin/neo4j-arbiter start</programlisting>
<simpara>You can also stop, install and remove it as a service and ask for it&#8217;s status in exactly the same way as for Neo4j instances.
See also <xref linkend="server-installation"/>.</simpara>
</section>
<section id="upgrade-guide">
<title>Upgrading a Neo4j HA Cluster</title>
<simpara>This document describes the steps required to upgrade a Neo4j cluster without disrupting its operation.
This process is referred to as a <emphasis>rolling upgrade</emphasis>.</simpara>
<section id="_upgrading_from_1_9_x_to_2_0">
<title>Upgrading from 1.9.x to 2.0</title>
<simpara>It is currently <emphasis>not</emphasis> possible to do a rolling upgrade from 1.9.x to 2.0.
This means that in order for you to upgrade a 1.9.x cluster to 2.0, you will incur some downtime.</simpara>
<section id="_steps">
<title>Steps</title>
<simpara>In order to upgrade a cluster from 1.9.x to 2.0, you will need to do the following manually:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Backup your data!
</simpara>
</listitem>
<listitem>
<simpara>
Shut down every cluster member except the master.
</simpara>
</listitem>
<listitem>
<simpara>
Install the new version of Neo4j for each slave instance&#8201;&#8212;&#8201;removing the data directory, but keeping the configuration.
</simpara>
</listitem>
<listitem>
<simpara>
Shut down the master&#8201;&#8212;&#8201;this brings your cluster completely offline!
</simpara>
</listitem>
<listitem>
<simpara>
Follow the instructions found in <xref linkend="explicit-upgrade"/> for <emphasis>just</emphasis> the master instance&#8201;&#8212;&#8201;the data in master instance have now been converted to the new Neo4j 2.0 format.
</simpara>
</listitem>
<listitem>
<simpara>
Shut down the master instance again.
</simpara>
</listitem>
<listitem>
<simpara>
Distribute the data directory from master to each slave instance&#8201;&#8212;&#8201;this saves time by not having to re-build stores and indexes for each slave.
</simpara>
</listitem>
<listitem>
<simpara>
Bring master online.
</simpara>
</listitem>
<listitem>
<simpara>
Bring slaves online.
</simpara>
</listitem>
</orderedlist>
<simpara>Your entire cluster has now been completely converted to Neo4j 2.0.</simpara>
</section>
</section>
<section id="_upgrading_from_1_8_x_to_1_9">
<title>Upgrading from 1.8.x to 1.9</title>
<simpara>The starting assumptions are that there exists a cluster running Neo4j version 1.8 or newer with the corresponding ZooKeeper instances and that the machine which is currently the master is known.
It is also assumed that on each machine the Neo4j service and the neo4j coordinator service is installed under a directory which from here on is assumed to be /opt/old-neo4j</simpara>
<simpara>The process consists of upgrading each machine in turn by removing it from the cluster, moving over the database and starting it back up again.
Configuration settings also have to be transferred. It is important to note that the last machine to be upgraded must be the master.
In general, the "cluster version" is defined by the version of the master, providing the master is of the older version the cluster
as a whole can operate (the 1.9 instances running in compatibility mode). When a 1.9 instance is elected master however, the older
 instances are not capable of communicating with it, so we have to make sure that the last machine upgraded is the old master.
 The upgrade process is detected automatically from the joining 1.9 instances and they will not participate in a master election while even a single old instance is part of the cluster.</simpara>
<section id="_step_1_on_each_slave_perform_the_upgrade">
<title>Step 1: On each slave perform the upgrade</title>
<simpara>Download and unpack the new version. Copy over any configuration settings you run your instances with, taking care for deprecated settings and API changes that can occur between versions.
Also, ensure that newly introduced settings have proper values (see <xref linkend="ha-configuration"/>).
The most important thing about the settings setup is the <literal>ha.coordinators</literal> setting in neo4j.properties which must be set to the value the existing 1.8 instances are using.
You also have to make sure that all but one instance have the <literal>ha.allow_init_cluster</literal> setting to <literal>false</literal> - the machine that has it set to true should be the one that is to become
 the new master.
In addition, it is necessary that the last machine to be upgraded (the 1.8 master) does not have the <literal>ha.coordinators</literal> setting present in its configuration file.
Finally, don&#8217;t forget to copy over any server plugins you may have.
First, shutdown the neo4j instance with</simpara>
<programlisting language="plain" linenumbering="unnumbered">service neo4j-service stop</programlisting>
<simpara>Next, uninstall it</simpara>
<programlisting language="plain" linenumbering="unnumbered">service neo4j-service remove</programlisting>
<simpara>Now you can copy over the database. Assuming the old instance is at /opt/old-neo4j and the newly unpacked under /opt/neo4j-enterprise-1.9 the proper command would be</simpara>
<programlisting language="plain" linenumbering="unnumbered">cp -R /opt/old-neo4j/data/graph.db /opt/neo4j-enterprise-1.9/data/</programlisting>
<simpara>Next install the neo4j service, which also starts it</simpara>
<programlisting language="plain" linenumbering="unnumbered">/opt/neo4j-enterprise-1.9/bin/neo4j install</programlisting>
<simpara>Done. Now check that the services are running and that webadmin reports the version 1.9. Transactions should also be applied from the master as usual.</simpara>
</section>
<section id="_step_2_upgrade_the_master_complete_the_procedure">
<title>Step 2:  Upgrade the master, complete the procedure</title>
<warning><simpara>Make sure that the installation that will replace the current master instance does not have <literal>ha.coordinators</literal> setting present in the <literal>neo4j.properties</literal> file.</simpara></warning>
<simpara>Go to the current master and execute step 1 The moment it will be stopped another instance will take over (the one with the allow_init_cluster setting set to true), transitioning the cluster to 1.9. Finish Step 1 on this machine as well and you will have completed the process.</simpara>
</section>
<section id="_step_3_cleanup_removing_the_coordinator_services">
<title>Step 3:  Cleanup, removing the coordinator services</title>
<simpara>Each 1.8 installation still has a coordinator service installed and running. To have those removed you need to execute at every upgraded instance</simpara>
<programlisting language="plain" linenumbering="unnumbered">service neo4j-coordinator stop
service neo4j-coordinator remove</programlisting>
<simpara>After that, the 1.8 instances are no longer active or needed and can be removed or archived.</simpara>
</section>
</section>
<section id="_upgrading_within_the_1_9_x_series">
<title>Upgrading within the 1.9.x series</title>
<warning><simpara>Due to an bug in the HA code, it may not be possible to do a rolling (i.e. uninterrupted) upgrade to Neo4j 1.9.2 on 1.9 or 1.9.1 clusters. Attempting to do so may lead to an unstable cluster and data loss may occur.
It is suggested that upgrades to 1.9.2 happen offline, where all instances are shutdown, upgraded and restarted. Upgrading from 1.9.2 to any other version works as described elsewhere in this guide.</simpara></warning>
<simpara>Upgrading between 1.9.x versions follows the same general pattern as described in the first part of this guide, but is much simpler because of the compatibility of the configuration options between 1.9.x releases. We will describe a step by step
procedure, aimed at reducing the master switches to a single change.</simpara>
<section id="_step_1_on_each_slave_perform_the_upgrade_2">
<title>Step 1: On each slave perform the upgrade</title>
<simpara>Download and unpack the new version. Copy over any configuration settings, ensuring that newly introduced settings have proper values (see <xref linkend="ha-configuration"/>).
Don&#8217;t forget to copy over any server plugins you may have.</simpara>
<simpara>First, shutdown the neo4j instance with</simpara>
<programlisting language="plain" linenumbering="unnumbered">service neo4j-service stop</programlisting>
<simpara>Next, uninstall it</simpara>
<programlisting language="plain" linenumbering="unnumbered">service neo4j-service remove</programlisting>
<simpara>Now you can copy over the database. Assuming the old instance is at /opt/old-neo4j and the newly unpacked under /opt/neo4j-enterprise-1.9.x the proper command would be</simpara>
<programlisting language="plain" linenumbering="unnumbered">cp -R /opt/old-neo4j/data/graph.db /opt/neo4j-enterprise-1.9.x/data/</programlisting>
<simpara>Next install the neo4j service, which also starts it</simpara>
<programlisting language="plain" linenumbering="unnumbered">/opt/neo4j-enterprise-1.9.x/bin/neo4j install</programlisting>
<simpara>Now check that the services are running and that webadmin reports the version 1.9.x. Transactions should also be applied from the master as usual.</simpara>
</section>
<section id="_step_2_upgrade_the_master_complete_the_procedure_2">
<title>Step 2:  Upgrade the master, complete the procedure</title>
<simpara>Go to the current master and execute step 1 The moment it will be stopped another instance will take over, transitioning the cluster to the new 1.9.x version. Finish Step 1 on this machine as well and you will have completed the process.</simpara>
</section>
</section>
</section>
<section id="ha-setup-tutorial">
<title>High Availability setup tutorial</title>
<simpara>This guide will help you understand how to configure and deploy a Neo4j High Availability cluster.
Two scenarios will be considered:</simpara>
<itemizedlist>
<listitem>
<simpara>
Configuring 3 instances to be deployed on 3 separate machines, in a setting similar to what might be encountered in a production environment.
</simpara>
</listitem>
<listitem>
<simpara>
Modifying the former to make it possible to run a cluster of 3 instances on the same physical machine, which is particularly useful during development.
</simpara>
</listitem>
</itemizedlist>
<section id="_background_2">
<title>Background</title>
<simpara>Each instance in a Neo4j HA cluster must be assigned an integer ID, which serves as its unique identifier. At startup, a Neo4j
instance contacts the other instances specified in the <literal>ha.initial_hosts</literal> configuration option.</simpara>
<simpara>When an instance establishes a connection to any other, it determines the current state of the cluster and ensures that
it is eligible to join. To be eligible the Neo4j instance must host the same database store as other members of the
cluster (although it is allowed to be in an older state), or be a new deployment without a database store.</simpara>
<warning>
<title>Explicitly configure IP Addresses/Hostnames for a cluster</title>
<simpara>Neo4j will attempt to configure IP addresses for itself in the absence of explicit configuration. However in
typical operational environments where machines have multiple network cards and support IPv4 and IPv6 it is <emphasis role="strong">strongly</emphasis>
recommended that the operator explicitly sets the IP address/hostname configuration for each machine in the cluster.</simpara>
</warning>
<simpara>Let&#8217;s examine the available settings and the values they accept.</simpara>
<section id="_ha_server_id">
<title>ha.server_id</title>
<simpara><literal>ha.server_id</literal> is the cluster identifier for each instance. It must be a positive integer and must be unique among
all Neo4j instances in the cluster.</simpara>
<simpara>For example, <literal>ha.server_id=1</literal>.</simpara>
</section>
<section id="_ha_cluster_server">
<title>ha.cluster_server</title>
<simpara><literal>ha.cluster_server</literal> is an address/port setting that specifies where the Neo4j instance will listen for cluster
communications (like hearbeat messages). The default port is <literal>5001</literal>. In the absence of a specified IP address, Neo4j
will attempt to find a valid interface for binding. While this behavior typically results in a well-behaved server, it
is <emphasis role="strong">strongly</emphasis> recommended that users explicitly choose an IP address bound to the network interface of their choosing
to ensure a coherent cluster deployment.</simpara>
<simpara>For example, <literal>ha.cluster_server=192.168.33.22:5001</literal> will listen for cluster communications on the network interface
bound to the 192.168.33.0 subnet on port 5001.</simpara>
</section>
<section id="_ha_initial_hosts">
<title>ha.initial_hosts</title>
<simpara><literal>ha.initial_hosts</literal> is a comma separated list of address/port pairs, which specify how to reach other Neo4j instances
in the cluster (as configured via their <literal>ha.cluster_server</literal> option). These hostname/ports will be used when the Neo4j
instances starts, to allow it up to find and join the cluster. Specifying an instance&#8217;s own address is permitted.</simpara>
<warning>
<simpara>Do <emphasis role="strong">not</emphasis> use any whitespace in this configuration option.</simpara>
</warning>
<simpara>For example, <literal>ha.initial_hosts=192.168.33.22:5001,192.168.33.21:5001</literal> will attempt to reach Neo4j instances listening on
192.168.33.22 on port 5001 and 192.168.33.21 on port 5001 on the 192.168.33.0 subnet.</simpara>
</section>
<section id="_ha_server">
<title>ha.server</title>
<simpara><literal>ha.server</literal> is an address/port setting that specifies where the Neo4j instance will listen for transactions
(changes to the graph data) from the cluster master. The default port is <literal>6001</literal>. In the absence of a specified IP address, Neo4j will attempt
to find a valid interface for binding. While this behavior typically results in a well-behaved server, it is <emphasis role="strong">strongly</emphasis> recommended that
users explicitly choose an IP address bound to the network interface of their choosing to ensure a coherent cluster topology.</simpara>
<simpara><literal>ha.server</literal> must user a different port to <literal>ha.cluster_server</literal>.</simpara>
<simpara>For example, <literal>ha.server=192.168.33.22:6001</literal> will listen for cluster communications on the network interface
bound to the 192.168.33.0 subnet on port 6001.</simpara>
<tip>
<title>Address/port format</title>
<simpara>The <literal>ha.cluster_server</literal> and <literal>ha.server</literal> configuration options are specified as <literal>&lt;IP address&gt;:&lt;port&gt;</literal>.</simpara>
<simpara>For <literal>ha.server</literal> the IP address MUST be the address assigned to one of the host&#8217;s network interfaces.</simpara>
<simpara>For <literal>ha.cluster_server</literal> the IP address MUST be the address assigned to one of the host&#8217;s network interfaces,
or the value <literal>0.0.0.0</literal>, which will cause Neo4j to listen on every network interface.</simpara>
<simpara>Either the address or the port can be omitted, in which case the default for that part will be used. If the address
is omitted, then the port must be preceded with a colon (eg. <literal>:5001</literal>).</simpara>
<simpara>The syntax for setting the port range is: <literal>&lt;hostname&gt;:&lt;first port&gt;[-&lt;second port&gt;]</literal>. In this case, Neo4j will test
each port in sequence, and select the first that is unused. Note that this usage is not permitted when the hostname is specified
as <literal>0.0.0.0</literal> (the "all interfaces" address).</simpara>
</tip>
</section>
</section>
<section id="_getting_started_setting_up_a_production_cluster">
<title>Getting started: Setting up a production cluster</title>
<section id="package-download">
<title>Download and unpack Neo4j Enterprise</title>
<simpara>Download Neo4j Enterprise from <ulink url="http://neo4j.org/download">the Neo4j download site</ulink>, and unpack on 3 separate machines.</simpara>
</section>
<section id="_configure_ha_related_settings_for_each_installation">
<title>Configure HA related settings for each installation</title>
<simpara>The following settings should be configured for each Neo4j installation.
Note that all 3 installations have the same configuration, except for the <literal>ha.server_id</literal> property.</simpara>
<simpara><emphasis role="strong">Neo4j instance #1&#8201;&#8212;&#8201;neo4j-01.local</emphasis></simpara>
<simpara><literal>conf/neo4j.properties</literal>:</simpara>
<programlisting language="properties" linenumbering="unnumbered"># Unique server id for this Neo4j instance
# can not be negative id and must be unique
ha.server_id = 1

# List of other known instances in this cluster
ha.initial_hosts = neo4j-01.local:5001,neo4j-02.local:5001,neo4j-03.local:5001
# Alternatively, use IP addresses:
#ha.initial_hosts = 192.168.0.20:5001,192.168.0.21:5001,192.168.0.22:5001</programlisting>
<simpara><literal>conf/neo4j-server.properties</literal></simpara>
<programlisting language="properties" linenumbering="unnumbered"># Let the webserver only listen on the specified IP.
org.neo4j.server.webserver.address=0.0.0.0

# HA - High Availability
# SINGLE - Single mode, default.
org.neo4j.server.database.mode=HA</programlisting>
<simpara><emphasis role="strong">Neo4j instance #2&#8201;&#8212;&#8201;neo4j-02.local</emphasis></simpara>
<simpara><literal>conf/neo4j.properties</literal>:</simpara>
<programlisting language="properties" linenumbering="unnumbered"># Unique server id for this Neo4j instance
# can not be negative id and must be unique
ha.server_id = 2

# List of other known instances in this cluster
ha.initial_hosts = neo4j-01.local:5001,neo4j-02.local:5001,neo4j-03.local:5001
# Alternatively, use IP addresses:
#ha.initial_hosts = 192.168.0.20:5001,192.168.0.21:5001,192.168.0.22:5001</programlisting>
<simpara><literal>conf/neo4j-server.properties</literal></simpara>
<programlisting language="properties" linenumbering="unnumbered"># Let the webserver only listen on the specified IP.
org.neo4j.server.webserver.address=0.0.0.0

# HA - High Availability
# SINGLE - Single mode, default.
org.neo4j.server.database.mode=HA</programlisting>
<simpara><emphasis role="strong">Neo4j instance #3&#8201;&#8212;&#8201;neo4j-03.local</emphasis></simpara>
<simpara><literal>conf/neo4j.properties</literal>:</simpara>
<programlisting language="properties" linenumbering="unnumbered"># Unique server id for this Neo4j instance
# can not be negative id and must be unique
ha.server_id = 3

# List of other known instances in this cluster
ha.initial_hosts = neo4j-01.local:5001,neo4j-02.local:5001,neo4j-03.local:5001
# Alternatively, use IP addresses:
#ha.initial_hosts = 192.168.0.20:5001,192.168.0.21:5001,192.168.0.22:5001</programlisting>
<simpara><literal>conf/neo4j-server.properties</literal></simpara>
<programlisting language="properties" linenumbering="unnumbered"># Let the webserver only listen on the specified IP.
org.neo4j.server.webserver.address=0.0.0.0

# HA - High Availability
# SINGLE - Single mode, default.
org.neo4j.server.database.mode=HA</programlisting>
</section>
<section id="_start_the_neo4j_servers">
<title>Start the Neo4j Servers</title>
<simpara>Start the Neo4j servers as normal. Note the startup order does not matter.</simpara>
<programlisting language="shell" linenumbering="unnumbered">neo4j-01$ ./bin/neo4j start</programlisting>
<programlisting language="shell" linenumbering="unnumbered">neo4j-02$ ./bin/neo4j start</programlisting>
<programlisting language="shell" linenumbering="unnumbered">neo4j-03$ ./bin/neo4j start</programlisting>
<tip>
<title>Startup Time</title>
<simpara>When running in HA mode, the startup script returns immediately instead of waiting for the server to become available.
This is because the instance does not accept any requests until a cluster has been formed.
In the example above this happens when you startup the second instance.
To keep track of the startup state you can follow the messages in console.log - the path to that is printed before the startup script returns.</simpara>
</tip>
<simpara>Now, you should be able to access the 3 servers and check their HA status:</simpara>
<simpara><ulink url="http://neo4j-01.local:7474/webadmin/#/info/org.neo4j/High%20Availability/">http://neo4j-01.local:7474/webadmin/#/info/org.neo4j/High%20Availability/</ulink></simpara>
<simpara><ulink url="http://neo4j-02.local:7474/webadmin/#/info/org.neo4j/High%20Availability/">http://neo4j-02.local:7474/webadmin/#/info/org.neo4j/High%20Availability/</ulink></simpara>
<simpara><ulink url="http://neo4j-03.local:7474/webadmin/#/info/org.neo4j/High%20Availability/">http://neo4j-03.local:7474/webadmin/#/info/org.neo4j/High%20Availability/</ulink></simpara>
<tip><simpara>You can replace database #3 with an <emphasis>arbiter</emphasis> instance, see <link linkend="arbiter-instances">Arbiter Instances</link>.</simpara></tip>
<simpara>That&#8217;s it!
You now have a Neo4j HA cluster of 3 instances running.
You can start by making a change on any instance and those changes will be propagated between them.
For more HA related configuration options take a look at <link linkend="ha-configuration">HA Configuration</link>.</simpara>
</section>
</section>
<section id="ha-local-cluster">
<title>Alternative setup: Creating a local cluster for testing</title>
<simpara>If you want to start a cluster similar to the one described above, but for development and testing purposes, it is convenient to run all Neo4j instances on the same machine.
This is easy to achieve, although it requires some additional configuration as the defaults will conflict with each other.</simpara>
<section id="_download_and_unpack_neo4j_enterprise">
<title>Download and unpack Neo4j Enterprise</title>
<simpara>Download Neo4j Enterprise from <ulink url="http://neo4j.org/download">the Neo4j download site</ulink>, and unpack into 3 separate directories on your test machine.</simpara>
</section>
<section id="_configure_ha_related_settings_for_each_installation_2">
<title>Configure HA related settings for each installation</title>
<simpara>The following settings should be configured for each Neo4j installation.</simpara>
<simpara><emphasis role="strong">Neo4j instance #1&#8201;&#8212;&#8201;~/neo4j-01</emphasis></simpara>
<simpara><literal>conf/neo4j.properties</literal>:</simpara>
<programlisting language="properties" linenumbering="unnumbered"># Unique server id for this Neo4j instance
# can not be negative id and must be unique
ha.server_id = 1

# IP and port for this instance to bind to for communicating data with the
# other neo4j instances in the cluster.
ha.server = 127.0.0.1:6363
online_backup_server = 127.0.0.1:6366

# IP and port for this instance to bind to for communicating cluster information
# with the other neo4j instances in the cluster.
ha.cluster_server = 127.0.0.1:5001

# List of other known instances in this cluster
ha.initial_hosts = 127.0.0.1:5001,127.0.0.1:5002,127.0.0.1:5003</programlisting>
<simpara><literal>conf/neo4j-server.properties</literal></simpara>
<programlisting language="properties" linenumbering="unnumbered"># database location
org.neo4j.server.database.location=data/graph.db

# http port (for all data, administrative, and UI access)
org.neo4j.server.webserver.port=7474

# https port (for all data, administrative, and UI access)
org.neo4j.server.webserver.https.port=7484

# HA - High Availability
# SINGLE - Single mode, default.
org.neo4j.server.database.mode=HA</programlisting>
<simpara><emphasis role="strong">Neo4j instance #2&#8201;&#8212;&#8201;~/neo4j-02</emphasis></simpara>
<simpara><literal>conf/neo4j.properties</literal>:</simpara>
<programlisting language="properties" linenumbering="unnumbered"># Unique server id for this Neo4j instance
# can not be negative id and must be unique
ha.server_id = 2

# IP and port for this instance to bind to for communicating data with the
# other neo4j instances in the cluster.
ha.server = 127.0.0.1:6364
online_backup_server = 127.0.0.1:6367

# IP and port for this instance to bind to for communicating cluster information
# with the other neo4j instances in the cluster.
ha.cluster_server = 127.0.0.1:5002

# List of other known instances in this cluster
ha.initial_hosts = 127.0.0.1:5001,127.0.0.1:5002,127.0.0.1:5003</programlisting>
<simpara><literal>conf/neo4j-server.properties</literal></simpara>
<programlisting language="properties" linenumbering="unnumbered"># database location
org.neo4j.server.database.location=data/graph.db

# http port (for all data, administrative, and UI access)
org.neo4j.server.webserver.port=7475

# https port (for all data, administrative, and UI access)
org.neo4j.server.webserver.https.port=7485

# HA - High Availability
# SINGLE - Single mode, default.
org.neo4j.server.database.mode=HA</programlisting>
<simpara><emphasis role="strong">Neo4j instance #3&#8201;&#8212;&#8201;~/neo4j-03</emphasis></simpara>
<simpara><literal>conf/neo4j.properties</literal>:</simpara>
<programlisting language="properties" linenumbering="unnumbered"># Unique server id for this Neo4j instance
# can not be negative id and must be unique
ha.server_id = 3

# IP and port for this instance to bind to for communicating data with the
# other neo4j instances in the cluster.
ha.server = 127.0.0.1:6365
online_backup_server = 127.0.0.1:6368

# IP and port for this instance to bind to for communicating cluster information
# with the other neo4j instances in the cluster.
ha.cluster_server = 127.0.0.1:5003

# List of other known instances in this cluster
ha.initial_hosts = 127.0.0.1:5001,127.0.0.1:5002,127.0.0.1:5003</programlisting>
<simpara><literal>conf/neo4j-server.properties</literal></simpara>
<programlisting language="properties" linenumbering="unnumbered"># database location
org.neo4j.server.database.location=data/graph.db

# http port (for all data, administrative, and UI access)
org.neo4j.server.webserver.port=7476

# https port (for all data, administrative, and UI access)
org.neo4j.server.webserver.https.port=7486

# HA - High Availability
# SINGLE - Single mode, default.
org.neo4j.server.database.mode=HA</programlisting>
</section>
<section id="_start_the_neo4j_servers_2">
<title>Start the Neo4j Servers</title>
<simpara>Start the Neo4j servers as normal.
Note the startup order does not matter.</simpara>
<programlisting language="shell" linenumbering="unnumbered">localhost:~/neo4j-01$ ./bin/neo4j start</programlisting>
<programlisting language="shell" linenumbering="unnumbered">localhost:~/neo4j-02$ ./bin/neo4j start</programlisting>
<programlisting language="shell" linenumbering="unnumbered">localhost:~/neo4j-03$ ./bin/neo4j start</programlisting>
<simpara>Now, you should be able to access the 3 servers and check their HA status:</simpara>
<simpara><ulink url="http://127.0.0.1:7474/webadmin/#/info/org.neo4j/High%20Availability/">http://127.0.0.1:7474/webadmin/#/info/org.neo4j/High%20Availability/</ulink></simpara>
<simpara><ulink url="http://127.0.0.1:7475/webadmin/#/info/org.neo4j/High%20Availability/">http://127.0.0.1:7475/webadmin/#/info/org.neo4j/High%20Availability/</ulink></simpara>
<simpara><ulink url="http://127.0.0.1:7476/webadmin/#/info/org.neo4j/High%20Availability/">http://127.0.0.1:7476/webadmin/#/info/org.neo4j/High%20Availability/</ulink></simpara>
</section>
</section>
</section>
<section id="ha-rest-info">
<title>REST endpoint for HA status information</title>
<section id="_introduction_7">
<title>Introduction</title>
<simpara>A common use case for Neo4j HA clusters is to direct all write requests to the master while using slaves for read operations, distributing the read load across the cluster and and gain failover capabilities for your deployment.
The most common way to achieve this is to place a load balancer in front of the HA cluster, an example being shown with <link linkend="ha-haproxy">HA Proxy</link>.
As you can see in that guide, it makes use of a REST endpoint to discover which instance is the master and direct write load to it.
In this section, we&#8217;ll deal with this REST endpoint and explain its semantics.</simpara>
</section>
<section id="_the_endpoints">
<title>The endpoints</title>
<simpara>Each HA instance comes with 3 endpoints regarding its HA status.
They are complimentary but each may be used depending on your load balancing needs and your production setup.
Those are:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>/db/manage/server/ha/master</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>/db/manage/server/ha/slave</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>/db/manage/server/ha/available</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>/master</literal> and <literal>/slave</literal> endpoints can be used to direct write and non-write traffic respectively to specific
instances. This is the optimal way to take advantage of Neo4j&#8217;s scaling characteristics. The <literal>/available</literal> endpoint
exists for the general case of directing arbitrary request types to instances that are available for transaction
processing.</simpara>
<simpara>To use the endpoints, perform an HTTP GET operation on either and the following will be returned:</simpara>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>HA REST endpoint responses</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="28*"/>
<colspec colname="col_2" colwidth="14*"/>
<colspec colname="col_3" colwidth="28*"/>
<colspec colname="col_4" colwidth="28*"/>
<thead>
<row>
<entry align="left" valign="top"> Endpoint                              </entry>
<entry align="left" valign="top"> Instance State  </entry>
<entry align="left" valign="top"> Returned Code  </entry>
<entry align="left" valign="top"> Body text</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="middle" morerows="2"><simpara><literal>/db/manage/server/ha/master</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Master</simpara></entry>
<entry align="left" valign="top"><simpara><literal>200 OK</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Slave</simpara></entry>
<entry align="left" valign="top"><simpara><literal>404 Not Found</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Unknown</simpara></entry>
<entry align="left" valign="top"><simpara><literal>404 Not Found</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>UNKNOWN</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="middle" morerows="2"><simpara><literal>/db/manage/server/ha/slave</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Master</simpara></entry>
<entry align="left" valign="top"><simpara><literal>404 Not Found</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Slave</simpara></entry>
<entry align="left" valign="top"><simpara><literal>200 OK</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Unknown</simpara></entry>
<entry align="left" valign="top"><simpara><literal>404 Not Found</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>UNKNOWN</literal></simpara></entry>
</row>
<row>
<entry align="center" valign="middle" morerows="2"><simpara><literal>/db/manage/server/ha/available</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Master</simpara></entry>
<entry align="left" valign="top"><simpara><literal>200 OK</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>master</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Slave</simpara></entry>
<entry align="left" valign="top"><simpara><literal>200 OK</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>slave</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Unknown</simpara></entry>
<entry align="left" valign="top"><simpara><literal>404 Not Found</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>UNKNOWN</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="_examples">
<title>Examples</title>
<simpara>From the command line, a common way to ask those endpoints is to use <literal>curl</literal>.
With no arguments, <literal>curl</literal> will do an HTTP <literal>GET</literal> on the URI provided and will output the body text, if any.
If you also want to get the response code, just add the <literal>-v</literal> flag for verbose output. Here are some examples:</simpara>
<itemizedlist>
<listitem>
<simpara>
Requesting <literal>master</literal> endpoint on a running master with verbose output
</simpara>
</listitem>
</itemizedlist>
<programlisting language="shell" linenumbering="unnumbered">#&gt; curl -v localhost:7474/db/manage/server/ha/master
* About to connect() to localhost port 7474 (#0)
*   Trying ::1...
* connected
* Connected to localhost (::1) port 7474 (#0)
&gt; GET /db/manage/server/ha/master HTTP/1.1
&gt; User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5
&gt; Host: localhost:7474
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Access-Control-Allow-Origin: *
&lt; Transfer-Encoding: chunked
&lt; Server: Jetty(6.1.25)
&lt;
* Connection #0 to host localhost left intact
true* Closing connection #0</programlisting>
<itemizedlist>
<listitem>
<simpara>
Requesting <literal>slave</literal> endpoint on a running master without verbose output:
</simpara>
</listitem>
</itemizedlist>
<programlisting language="shell" linenumbering="unnumbered">#&gt; curl localhost:7474/db/manage/server/ha/slave
false</programlisting>
<itemizedlist>
<listitem>
<simpara>
Finally, requesting the <literal>master</literal> endpoint on a slave with verbose output
</simpara>
</listitem>
</itemizedlist>
<programlisting language="shell" linenumbering="unnumbered">#&gt; curl -v localhost:7475/db/manage/server/ha/master
* About to connect() to localhost port 7475 (#0)
*   Trying ::1...
* connected
* Connected to localhost (::1) port 7475 (#0)
&gt; GET /db/manage/server/ha/master HTTP/1.1
&gt; User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5
&gt; Host: localhost:7475
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 404 Not Found
&lt; Content-Type: text/plain
&lt; Access-Control-Allow-Origin: *
&lt; Transfer-Encoding: chunked
&lt; Server: Jetty(6.1.25)
&lt;
* Connection #0 to host localhost left intact
false* Closing connection #0</programlisting>
<note>
<title>Unknown status</title>
<simpara>The <literal>UNKNOWN</literal> status exists to describe when a Neo4j instance is neither master nor slave.
For example, the instance could be transitioning between states (master to slave in a recovery scenario or slave being promoted to master in the event of failure).
If the <literal>UNKNOWN</literal> status is returned, the client should not treat the instance as a master or a slave and should instead pick another instance in the cluster to use, wait for the instance to transit from the <literal>UNKNOWN</literal> state, or undertake restorative action via systems admin.</simpara>
</note>
</section>
</section>
<section id="ha-haproxy">
<title>Setting up HAProxy as a load balancer</title>
<simpara>In the Neo4j HA architecture, the cluster is typically fronted by a load balancer. In this section we will explore
how to set up HAProxy to perform load balancing across the HA cluster.</simpara>
<simpara>For this tutorial we will assume a Linux environment with HAProxy already installed.
See <ulink url="http://haproxy.1wt.eu/">http://haproxy.1wt.eu/</ulink> for downloads and installation instructions.</simpara>
<section id="_configuring_haproxy">
<title>Configuring HAProxy</title>
<simpara>HAProxy can be configured in many ways. The full documentation is available at their website.</simpara>
<simpara>For this example, we will configure HAProxy to load balance requests to three HA servers. Simply write the follow
configuration to <literal>/etc/haproxy.cfg</literal>:</simpara>
<programlisting language="plain" linenumbering="unnumbered">global
    daemon
    maxconn 256

defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

frontend http-in
    bind *:80
    default_backend neo4j

backend neo4j
    option httpchk GET /db/manage/server/ha/available
    server s1 10.0.1.10:7474 maxconn 32
    server s2 10.0.1.11:7474 maxconn 32
    server s3 10.0.1.12:7474 maxconn 32

listen admin
    bind *:8080
    stats enable</programlisting>
<simpara>HAProxy can now be started by running:</simpara>
<programlisting language="shell" linenumbering="unnumbered">/usr/sbin/haproxy -f /etc/haproxy.cfg</programlisting>
<simpara>You can connect to <ulink url="http://&lt;ha-proxy-ip&gt;:8080/haproxy?stats">http://&lt;ha-proxy-ip&gt;:8080/haproxy?stats</ulink> to view the status dashboard. This dashboard can
be moved to run on port 80, and authentication can also be added. See the HAProxy documentation for details on this.</simpara>
</section>
<section id="_optimizing_for_reads_and_writes">
<title>Optimizing for reads and writes</title>
<simpara>Neo4j provides a catalogue of <emphasis>health check URLs</emphasis> (see <xref linkend="ha-rest-info"/>) that HAProxy (or any load balancer for that matter) can use to distinguish machines using HTTP response codes.
In the example above we used the <literal>/available</literal> endpoint, which directs requests to machines that are generally available for transaction processing (they are alive!).</simpara>
<simpara>However, it is possible to have requests directed to slaves only, or to the master only.
If you are able to distinguish in your application between requests that write, and requests that only read, then you can take advantage of two (logical) load balancers: one that sends all your writes to the master, and one that sends all your read-only requests to a slave.
In HAProxy you build logical load balancers by adding multiple <literal>backend</literal>s.</simpara>
<simpara>The trade-off here is that while Neo4j allows slaves to proxy writes for you, this indirection unnecessarily ties up resources on the slave and adds latency to your write requests.
Conversely, you don&#8217;t particularly want read traffic to tie up resources on the master; Neo4j allows you to scale out for reads, but writes are still constrained to a single instance.
If possible, that instance should exclusively do writes to ensure maximum write performance.</simpara>
<simpara>The following example excludes the master from the set of machines using the <literal>/slave</literal> endpoint.</simpara>
<programlisting language="plain" linenumbering="unnumbered">global
    daemon
    maxconn 256

defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

frontend http-in
    bind *:80
    default_backend neo4j-slaves

backend neo4j-slaves
    option httpchk GET /db/manage/server/ha/slave
    server s1 10.0.1.10:7474 maxconn 32 check
    server s2 10.0.1.11:7474 maxconn 32 check
    server s3 10.0.1.12:7474 maxconn 32 check

listen admin
    bind *:8080
    stats enable</programlisting>
<note>
<simpara>In practice, writing to a slave is uncommon. While writing to slaves has the benefit of ensuring that data is
persisted in two places (the slave and the master), it comes at a cost. The cost is that the slave must immediately
become consistent with the master by applying any missing transactions and then synchronously apply the new transaction
with the master. This is a more expensive operation than writing to the master and having the master push changes to
one or more slaves.</simpara>
</note>
</section>
<section id="_cache_based_sharding_with_haproxy">
<title>Cache-based sharding with HAProxy</title>
<simpara>Neo4j HA enables what is called cache-based sharding. If the dataset is too big to fit into the cache of any
single machine, then by applying a consistent routing algorithm to requests, the caches on each machine will
actually cache different parts of the graph. A typical routing key could be user ID.</simpara>
<simpara>In this example, the user ID is a query parameter in the URL being requested. This will route the same user
to the same machine for each request.</simpara>
<programlisting language="plain" linenumbering="unnumbered">global
    daemon
    maxconn 256

defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

frontend http-in
    bind *:80
    default_backend neo4j-slaves

backend neo4j-slaves
    balance url_param user_id
    server s1 10.0.1.10:7474 maxconn 32
    server s2 10.0.1.11:7474 maxconn 32
    server s3 10.0.1.12:7474 maxconn 32

listen admin
    bind *:8080
    stats enable</programlisting>
<simpara>Naturally the health check and query parameter-based routing can be combined to only route requests to slaves
by user ID. Other load balancing algorithms are also available, such as routing by source IP (<literal>source</literal>),
the URI (<literal>uri</literal>) or HTTP headers(<literal>hdr()</literal>).</simpara>
</section>
</section>
</chapter>
<chapter id="operations-backup">
<title>Backup</title>
<note><simpara>The Backup features are only available in the Neo4j Enterprise Edition.</simpara></note>
<section id="backup-introduction">
<title>Introducing Backup</title>
<simpara>Backups are performed over the network live from a running graph database onto a local copy.
There are two types of backup: full and incremental.</simpara>
<simpara>A <emphasis>full backup</emphasis> copies the database files without acquiring any locks, allowing for continued operations on the target instance. This of course means that
while copying, transactions will continue and the store will change. For this reason, the transaction that was running when the backup operation started
is noted and, when the copy operation completes, all transactions from the latter down to the one happening at the end of the copy are replayed on the backup
files. This ensures that the backed up data represent a consistent and up-to-date snapshot of the database storage.</simpara>
<simpara>In contrast, an <emphasis>incremental backup</emphasis> does not copy store files&#8201;&#8212;&#8201;instead it copies the logs of the transactions that have taken place since the last full or
incremental backup which are then replayed over an existing backup store. This makes incremental backups far more efficient than doing full backups every
time but they also require that a <emphasis>full backup</emphasis> has taken place before they are executed.</simpara>
<simpara>The backup tool will detect whether you are trying to run a full backup or an incremental one by inspecting the target directory.
Regardless of the mode a backup is created with, the resulting files represent a consistent database snapshot and they can be used to boot up a Neo4j instance.</simpara>
<simpara>The database to be backed up is specified using a URI with syntax</simpara>
<simpara>&lt;running mode&gt;://&lt;host&gt;[:port]{,&lt;host&gt;[:port]*}</simpara>
<simpara>Running mode must be defined and is either <emphasis>single</emphasis> for non-HA or <emphasis>ha</emphasis> for HA clusters. The &lt;host&gt;[:port] part
points to a host running the database, on port <emphasis>port</emphasis> if not the default. The additional <emphasis>host:port</emphasis> arguments
are useful for passing multiple cluster members.</simpara>
<important><simpara>As of version 1.9, backups are enabled by default. That means that the configuration parameter <literal>online_backup_enabled</literal> defaults to true and that
makes the backup service available on the default port (6362).
To enable the backup service on a different port use <literal>online_backup_server=:9999</literal>.</simpara></important>
</section>
<section id="backup-embedded-and-server">
<title>Server and Embedded</title>
<simpara>To perform a backup from a running embedded or server database run:</simpara>
<programlisting language="shell" linenumbering="unnumbered"># Performing a full backup: create a blank directory and run the backup tool
mkdir /mnt/backup/neo4j-backup
./neo4j-backup -from single://192.168.1.34 -to /mnt/backup/neo4j-backup

# Performing an incremental backup: just specify the location of your previous backup
./neo4j-backup -from single://192.168.1.34 -to /mnt/backup/neo4j-backup

# Performing an incremental backup where the service is registered on a custom port
./neo4j-backup -from single://192.168.1.34:9999 -to /mnt/backup/neo4j-backup</programlisting>
</section>
<section id="backup-java">
<title>Online Backup from Java</title>
<simpara>In order to programmatically backup your data full or subsequently incremental from a
JVM based program, you need to write Java code like</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[OnlineBackup backup = OnlineBackup.from( "127.0.0.1" );
backup.full( backupPath.getPath() );
backup.incremental( backupPath.getPath() );
]]></programlisting>
<simpara>For more information, please see <ulink url="http://components.neo4j.org/neo4j-enterprise/2.0-SNAPSHOT/apidocs/org/neo4j/backup/OnlineBackup.html">the Javadocs for
OnlineBackup</ulink></simpara>
</section>
<section id="backup-ha">
<title>High Availability</title>
<simpara>To perform a backup on an HA cluster you specify one or more members of the target HA cluster.
Note that the addresses you must provide are the cluster server addresses and not the HA server addresses.
That is, use the value of the <literal>ha.cluster_server</literal> setting in the configuration.</simpara>
<programlisting language="shell" linenumbering="unnumbered"># Performing a backup from HA cluster, specifying only one cluster member
./neo4j-backup -from ha://192.168.1.15:5001 -to /mnt/backup/neo4j-backup

# Performing a backup from HA cluster, specifying two possible cluster members
./neo4j-backup -from ha://192.168.1.15:5001,192.168.1.16:5002 -to /mnt/backup/neo4j-backup</programlisting>
</section>
<section id="backup-restoring">
<title>Restoring Your Data</title>
<simpara>The Neo4j backups are fully functional databases.
To use a backup, all you need to do replace your database folder with the backup.
Just make sure the database isn&#8217;t running while replacing the folder.</simpara>
</section>
</chapter>
<chapter id="operations-security">
<title>Security</title>
<simpara>Neo4j in itself does not enforce security on the data level.
However, there are different aspects that should be considered when using Neo4j in different scenarios.
See <xref linkend="security-server"/> for details.</simpara>
<section id="security-server">
<title>Securing access to the Neo4j Server</title>
<section id="_secure_the_port_and_remote_client_connection_accepts">
<title>Secure the port and remote client connection accepts</title>
<simpara>By default, the Neo4j Server is bundled with a Web server that binds to host <literal>localhost</literal> on port <literal>7474</literal>, answering only requests from the local machine.</simpara>
<simpara>This is configured in the <emphasis>conf/neo4j-server.properties</emphasis> file:</simpara>
<programlisting language="plain" linenumbering="unnumbered"># http port (for all data, administrative, and UI access)
org.neo4j.server.webserver.port=7474

#let the webserver only listen on the specified IP. Default
#is localhost (only accept local connections). Uncomment to allow
#any connection.
#org.neo4j.server.webserver.address=0.0.0.0</programlisting>
<simpara>If you need to enable access from external hosts, configure the Web server in the <emphasis>conf/neo4j-server.properties</emphasis> by setting the property <literal>org.neo4j.server.webserver.address=0.0.0.0</literal> to enable access from any host.</simpara>
</section>
<section id="_arbitrary_code_execution">
<title>Arbitrary code execution</title>
<simpara>By default, the Neo4j Server comes with some places where arbitrary code code execution can happen. These are the <xref linkend="rest-api-traverse"/> REST endpoints.
To secure these, either disable them completely by removing offending plugins from the server classpath, or secure access to these URLs through proxies or Authorization Rules.
Also, the Java Security Manager, see <ulink url="http://docs.oracle.com/javase/7/docs/technotes/guides/security/index.html">http://docs.oracle.com/javase/7/docs/technotes/guides/security/index.html</ulink> can be used to secure parts of the codebase.</simpara>
</section>
<section id="_https_support">
<title>HTTPS support</title>
<simpara>The Neo4j server includes built in support for SSL encrypted communication over HTTPS.
The first time the server starts, it automatically generates a self-signed SSL certificate and a private key.
Because the certificate is self signed, it is not safe to rely on for production use, instead, you should provide your own key and certificate for the server to use.</simpara>
<simpara>To provide your own key and certificate, replace the generated key and certificate, or change the neo4j-server.properties file to set the location of your certificate and key:</simpara>
<programlisting language="plain" linenumbering="unnumbered"># Certificate location (auto generated if the file does not exist)
org.neo4j.server.webserver.https.cert.location=ssl/snakeoil.cert

# Private key location (auto generated if the file does not exist)
org.neo4j.server.webserver.https.key.location=ssl/snakeoil.key</programlisting>
<simpara>Note that the key should be unencrypted.
Make sure you set correct permissions on the private key, so that only the Neo4j server user can read/write it.</simpara>
<simpara>Neo4j also supports chained SSL certificates.
This requires to have all certificates in PEM format combined in one file and the private key needs to be in DER format.</simpara>
<simpara>You can set what port the HTTPS connector should bind to in the same configuration file, as well as turn HTTPS off:</simpara>
<programlisting language="plain" linenumbering="unnumbered"># Turn https-support on/off
org.neo4j.server.webserver.https.enabled=true

# https port (for all data, administrative, and UI access)
org.neo4j.server.webserver.https.port=443</programlisting>
</section>
<section id="_server_authorization_rules">
<title>Server Authorization Rules</title>
<simpara>Administrators may require more fine-grained security policies in addition to IP-level restrictions on the Web server.  Neo4j server supports
administrators in allowing or disallowing access the specific aspects of the database based on credentials that users or applications provide.</simpara>
<simpara>To facilitate domain-specific authorization policies in Neo4j Server, <literal><ulink url="http://components.neo4j.org/neo4j-server/2.0-SNAPSHOT/apidocs/org/neo4j/server/rest/security/SecurityRule.html">SecurityRules</ulink></literal> can be implemented and
registered with the server. This makes scenarios like user and role based security and
authentication against external lookup services possible.</simpara>
<section id="ops-enforcing-server-authorization-rules">
<title>Enforcing Server Authorization Rules</title>
<simpara>In this example, a (dummy) failing security rule is registered to deny
access to all URIs to the server by listing the rules class in
<emphasis>neo4j-server.properties</emphasis>:</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.rest.security_rules=my.rules.PermanentlyFailingSecurityRule</programlisting>
<simpara>with the rule source code of:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[public class PermanentlyFailingSecurityRule implements SecurityRule
{

    public static final String REALM = "WallyWorld"; // as per RFC2617 :-)

    @Override
    public boolean isAuthorized( HttpServletRequest request )
    {
        return false; // always fails - a production implementation performs
                      // deployment-specific authorization logic here
    }

    @Override
    public String forUriPath()
    {
        return "/*";
    }

    @Override
    public String wwwAuthenticateHeader()
    {
        return SecurityFilter.basicAuthenticationResponse(REALM);
    }
}
]]></programlisting>
<simpara>With this rule registered, any access to the server will be
denied. In a production-quality implementation the rule
will likely lookup credentials/claims in a 3rd-party
directory service (e.g. LDAP) or in a local database of
authorized users.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>POST</literal></emphasis>  <literal>http://localhost:7474/db/data/node</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json; charset=UTF-8</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>401:</literal></emphasis> <literal>Unauthorized</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>WWW-Authenticate:</literal></emphasis> <literal>Basic realm="WallyWorld"</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="ops-using-wildcards-to-target-security-rules">
<title>Using Wildcards to Target Security Rules</title>
<simpara>In this example, a security rule is registered to deny
access to all URIs to the server by listing the rule(s) class(es) in
<emphasis>neo4j-server.properties</emphasis>.
In this case, the rule is registered
using a wildcard URI path (where <literal>*</literal> characters can be used to signify
any part of the path). For example <literal>/users*</literal> means the rule
will be bound to any resources under the <literal>/users</literal> root path. Similarly
<literal>/users*type*</literal> will bind the rule to resources matching
URIs like <literal>/users/fred/type/premium</literal>.</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.rest.security_rules=my.rules.PermanentlyFailingSecurityRuleWithWildcardPath</programlisting>
<simpara>with the rule source code of:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[public String forUriPath()
{
    return "/protected/*";
}
]]></programlisting>
<simpara>With this rule registered, any access to URIs under /protected/ will be
denied by the server. Using wildcards allows flexible targeting of security rules to
arbitrary parts of the server&#8217;s API, including any unmanaged extensions or managed
plugins that have been registered.</simpara>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/protected/tree/starts/here/dummy/more/stuff</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>401:</literal></emphasis> <literal>Unauthorized</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>WWW-Authenticate:</literal></emphasis> <literal>Basic realm="WallyWorld"</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
<section id="ops-using-complex-wildcards-to-target-security-rules">
<title>Using Complex Wildcards to Target Security Rules</title>
<simpara>In this example, a security rule is registered to deny
access to all URIs matching a complex pattern.
The config looks like this:</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.server.rest.security_rules=my.rules.PermanentlyFailingSecurityRuleWithComplexWildcardPath</programlisting>
<simpara>with the rule source code of:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[public class PermanentlyFailingSecurityRuleWithComplexWildcardPath implements SecurityRule
{

    public static final String REALM = "WallyWorld"; // as per RFC2617 :-)

    @Override
    public boolean isAuthorized( HttpServletRequest request )
    {
        return false;
    }

    @Override
    public String forUriPath()
    {
        return "/protected/*/something/else/*/final/bit";
    }

    @Override
    public String wwwAuthenticateHeader()
    {
        return SecurityFilter.basicAuthenticationResponse(REALM);
    }
}
]]></programlisting>
<simpara><emphasis>Example request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>GET</literal></emphasis>  <literal>http://localhost:7474/protected/wildcard_replacement/x/y/z/something/else/more_wildcard_replacement/a/b/c/final/bit/more/stuff</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>Accept:</literal></emphasis> <literal>application/json</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Example response</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><literal>401:</literal></emphasis> <literal>Unauthorized</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><literal>WWW-Authenticate:</literal></emphasis> <literal>Basic realm="WallyWorld"</literal>
</simpara>
</listitem>
</itemizedlist>
<programlisting language="javascript" linenumbering="unnumbered"></programlisting>
</section>
</section>
<section id="_hosted_scripting">
<title>Hosted Scripting</title>
<important><simpara>The neo4j server exposes remote scripting functionality by default that allow full access to the underlying system.
Exposing your server without implementing a security layer poses a substantial security vulnerability.</simpara></important>
</section>
<section id="_security_in_depth">
<title>Security in Depth</title>
<simpara>Although the Neo4j server has a number of security features built-in (see the above chapters), for sensitive deployments it is often sensible to front against the outside world it with a proxy like Apache <literal>mod_proxy</literal> <footnote><simpara><ulink url="http://httpd.apache.org/docs/2.2/mod/mod_proxy.html">http://httpd.apache.org/docs/2.2/mod/mod_proxy.html</ulink></simpara></footnote>.</simpara>
<simpara>This provides a number of advantages:</simpara>
<itemizedlist>
<listitem>
<simpara>
Control access to the Neo4j server to specific IP addresses, URL patterns and IP ranges. This can be used to make for instance only the <emphasis>/db/data</emphasis> namespace accessible to non-local clients, while the <emphasis>/db/admin</emphasis> URLs only respond to a specific IP address.
</simpara>
<programlisting language="plain" linenumbering="unnumbered">&lt;Proxy *&gt;
  Order Deny,Allow
  Deny from all
  Allow from 192.168.0
&lt;/Proxy&gt;</programlisting>
</listitem>
</itemizedlist>
<simpara>While equivalent functionality can be implemented with Neo4j&#8217;s <literal>SecurityRule</literal> plugins (see above), for operations professionals configuring servers like Apache is often preferable to developing plugins. However it should be noted that where both approaches are used, they will work harmoniously providing the behavior is consistent across proxy server and <literal>SecurityRule</literal> plugins.</simpara>
<itemizedlist>
<listitem>
<simpara>
Run Neo4j Server as a non-root user on a Linux/Unix system on a port &lt; 1000 (e.g. port 80) using
</simpara>
<programlisting language="plain" linenumbering="unnumbered">ProxyPass /neo4jdb/data http://localhost:7474/db/data
ProxyPassReverse /neo4jdb/data http://localhost:7474/db/data</programlisting>
</listitem>
<listitem>
<simpara>
Simple load balancing in a clustered environment to load-balance read load using the Apache <literal>mod_proxy_balancer</literal> <footnote><simpara><ulink url="http://httpd.apache.org/docs/2.2/mod/mod_proxy_balancer.html">http://httpd.apache.org/docs/2.2/mod/mod_proxy_balancer.html</ulink></simpara></footnote> plugin
</simpara>
<programlisting language="plain" linenumbering="unnumbered">&lt;Proxy balancer://mycluster&gt;
BalancerMember http://192.168.1.50:80
BalancerMember http://192.168.1.51:80
&lt;/Proxy&gt;
ProxyPass /test balancer://mycluster</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter id="operations-monitoring">
<title>Monitoring</title>
<note><simpara>Most of the monitoring features are only available in the Enterprise edition of Neo4j.</simpara></note>
<simpara>In order to be able to continuously get an overview of the health of a Neo4j database, there are different levels of monitoring facilities available.
Most of these are exposed through <ulink url="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">JMX</ulink>.</simpara>
<section id="jmx-remote">
<title>Adjusting remote JMX access to the Neo4j Server</title>
<simpara>Per default, the Neo4j Enterprise Server edition do not allow remote JMX connections, since the relevant options in the <emphasis>conf/neo4j-wrapper.conf</emphasis> configuration file are commented out.
To enable this feature, you have to remove the <literal>#</literal> characters from the various <literal>com.sun.management.jmxremote</literal> options there.</simpara>
<simpara>When commented in, the default values are set up to allow remote JMX connections with certain roles, refer to the <emphasis>conf/jmx.password</emphasis>, <emphasis>conf/jmx.access</emphasis> and <emphasis>conf/neo4j-wrapper.conf</emphasis> files for details.</simpara>
<simpara>Make sure that <emphasis>conf/jmx.password</emphasis> has the correct file permissions.
The owner of the file has to be the user that will run the service, and the permissions should be read only for that user.
On Unix systems, this is <literal>0600</literal>.</simpara>
<simpara>On Windows, follow the tutorial at <ulink url="http://docs.oracle.com/javase/7/docs/technotes/guides/management/security-windows.html">http://docs.oracle.com/javase/7/docs/technotes/guides/management/security-windows.html</ulink> to set the correct permissions.
If you are running the service under the Local System Account, the user that owns the file and has access to it should be SYSTEM.</simpara>
<simpara>With this setup, you should be able to connect to JMX monitoring of the Neo4j server using <literal>&lt;IP-OF-SERVER&gt;:3637</literal>, with the username <literal>monitor</literal> and the password <literal>Neo4j</literal>.</simpara>
<simpara>Note that it is possible that you have to update the permissions and/or ownership of the <emphasis>conf/jmx.password</emphasis> and <emphasis>conf/jmx.access</emphasis> files&#8201;&#8212;&#8201;refer to the relevant section in <emphasis>conf/neo4j-wrapper.conf</emphasis> for details.</simpara>
<warning><simpara>For maximum security, please adjust at least the password settings in <emphasis>conf/jmx.password</emphasis> for a production installation.</simpara></warning>
<simpara>For more details, see: <ulink url="http://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html">http://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html</ulink>.</simpara>
</section>
<section id="jmx-connect-jconsole">
<title>How to connect to a Neo4j instance using JMX and JConsole</title>
<simpara>First, start your embedded database or the Neo4j Server, for instance using</simpara>
<programlisting language="shell" linenumbering="unnumbered">$NEO4j_HOME/bin/neo4j start</programlisting>
<simpara>Now, start JConsole with</simpara>
<programlisting language="shell" linenumbering="unnumbered">$JAVA_HOME/bin/jconsole</programlisting>
<simpara>Connect to the process running your Neo4j database instance:</simpara>
<figure><title>Connecting JConsole to the Neo4j Java process</title>
<ulink url="images/jconsole_connect.png">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/jconsole_connect.png" width="50%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>Connecting with JConsole</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara>Now, beside the MBeans exposed by the JVM, you will see an <literal>org.neo4j</literal> section in the MBeans tab.
Under that, you will have access to all the monitoring information exposed by Neo4j.</simpara>
<simpara>For opening JMX to remote monitoring access, please see <xref linkend="jmx-remote"/> and <ulink url="http://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html">the JMX documention</ulink>.
When using Neo4j in embedded mode, make sure to pass the <literal>com.sun.management.jmxremote.port=portNum</literal> or other configuration as JVM parameters to your running Java process.</simpara>
<figure><title>Neo4j MBeans View</title>
<ulink url="images/jconsole_beans.png">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/jconsole_beans.png" width="100%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>Neo4j MBeans view</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
<section id="jmx-connect-programmatic">
<title>How to connect to the JMX monitoring programmatically</title>
<simpara>In order to programmatically connect to the Neo4j JMX server, there are some convenience methods in the Neo4j Management component to help you find out the most commonly used monitoring attributes of Neo4j.
See <xref linkend="tutorials-java-embedded-jmx"/> for an example.</simpara>
<simpara>Once you have access to this information, you can use it to for instance expose the values to <ulink url="http://en.wikipedia.org/wiki/Simple_Network_Management_Protocol">SNMP</ulink> or other monitoring systems.</simpara>
</section>
<section id="jmx-mxbeans">
<title>Reference of supported JMX MBeans</title>
<table id="jmx-list"
frame="none"
rowsep="1" colsep="1"
>
<title>MBeans exposed by Neo4j</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-branched-store">Branched Store</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Information about the branched stores present in this HA cluster member</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-cache-nodecache">Cache/NodeCache</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Information about the caching in Neo4j</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-cache-relationshipcache">Cache/RelationshipCache</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Information about the caching in Neo4j</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-configuration">Configuration</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The configuration parameters used to configure Neo4j</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-diagnostics">Diagnostics</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Diagnostics provided by Neo4j</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-high-availability">High Availability</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Information about an instance participating in a HA cluster</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-kernel">Kernel</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Information about the Neo4j kernel</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-locking">Locking</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Information about the Neo4j lock status</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-memory-mapping">Memory Mapping</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The status of Neo4j memory mapping</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-primitive-count">Primitive count</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Estimates of the numbers of different kinds of Neo4j primitives</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-store-file-sizes">Store file sizes</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Information about the sizes of the different parts of the Neo4j graph store</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-transactions">Transactions</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Information about the Neo4j transaction manager</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><link linkend="jmx-xa-resources">XA Resources</link></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Information about the XA transaction manager</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note><simpara>For additional information on the primitive datatypes (<literal>int</literal>, <literal>long</literal> etc.) used in the JMX attributes,
please see <xref linkend="property-value-types"/> in <xref linkend="graphdb-neo4j-properties"/>.</simpara></note>
<table id="jmx-branched-store"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Branched Store (org.neo4j.management.BranchedStore) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>Information about the branched stores present in this HA cluster member</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>BranchedStores</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A list of the branched stores</simpara></entry>
<entry align="left" valign="top"><simpara><literal><ulink url="http://components.neo4j.org/neo4j-enterprise/2.0-SNAPSHOT/apidocs/org/neo4j/management/BranchedStoreInfo.html">org.neo4j.management.BranchedStoreInfo</ulink>[] as <ulink url="http://docs.oracle.com/javase/7/docs/api/javax/management/openmbean/CompositeData.html">CompositeData</ulink>[]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="jmx-cache-nodecache"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Cache/NodeCache (org.neo4j.management.Cache) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>Information about the caching in Neo4j</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CacheSize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The size of this cache (nr of entities or total size in bytes)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CacheType</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The type of cache used by Neo4j</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HitCount</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of times a cache query returned a result</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MissCount</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of times a cache query did not return a result</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Cache/NodeCache (org.neo4j.management.Cache) Operations</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">ReturnType</entry>
<entry align="left" valign="top">Signature</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>clear</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clears the Neo4j caches</simpara></entry>
<entry align="left" valign="top"><simpara><literal>void</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>(no parameters)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="jmx-cache-relationshipcache"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Cache/RelationshipCache (org.neo4j.management.Cache) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>Information about the caching in Neo4j</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CacheSize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The size of this cache (nr of entities or total size in bytes)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CacheType</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The type of cache used by Neo4j</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HitCount</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of times a cache query returned a result</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MissCount</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of times a cache query did not return a result</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Cache/RelationshipCache (org.neo4j.management.Cache) Operations</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">ReturnType</entry>
<entry align="left" valign="top">Signature</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>clear</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clears the Neo4j caches</simpara></entry>
<entry align="left" valign="top"><simpara><literal>void</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>(no parameters)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="jmx-configuration"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Configuration (org.neo4j.jmx.impl.ConfigurationBean) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>The configuration parameters used to configure Neo4j</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>all_stores_total_mapped_memory_size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The size to allocate for a memory mapping pool to be shared between all stores.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>allow_store_upgrade</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to allow a store upgrade in case the current version of the database starts against an older store version. Setting this to true does not guarantee successful upgrade, just that it allows an attempt at it.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>array_block_size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the block size for storing arrays. This parameter is only honored when the store is created, otherwise it is ignored. The default block size is 120 bytes, and the overhead of each block is the same as for string blocks, i.e., 8 bytes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>backup_slave</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Mark this database as a backup slave.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cache_type</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The type of cache to use for nodes and relationships. Note that the Neo4j Enterprise Edition has the additional <emphasis>hpc</emphasis> cache type (High-Performance Cache). See the chapter on caches in the manual for more information.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cypher_parser_version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enable this to specify a parser other than the default one.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>dump_configuration</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print out the effective Neo4j configuration after startup.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ephemeral</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configuration attribute</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>forced_kernel_id</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An identifier that uniquely identifies this graph database instance within this JVM. Defaults to an auto-generated number depending on how many instance are started in this JVM.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>gc_monitor_threshold</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of time in ms the monitor thread has to be blocked before logging a message it was blocked.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>gc_monitor_wait_time</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Amount of time in ms the GC monitor thread will wait before taking another measurement.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.allow_init_cluster</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to allow this instance to create a cluster if unable to join.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.branched_data_policy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Policy for how to handle branched data.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.broadcast_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for broadcasting values in cluster. Must consider end-to-end duration of Paxos algorithm. This value is the default value for settings ha.join_timeout and ha.leave_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.cluster_name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of a cluster.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.cluster_server</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Host &amp; port to bind the cluster management communication.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.com_chunk_size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Max size of the data chunks that flows between master and slaves in HA. Bigger size may increase throughput, but may be more sensitive to variations in bandwidth, whereas lower size increases tolerance for bandwidth variations.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.configuration_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for waiting for configuration from an existing cluster member during cluster join.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.default_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Default timeout used for clustering timeouts. Override  specific timeout settings with proper values if necessary. This value is the default value for settings ha.heartbeat_interval, ha.paxos_timeout and ha.learn_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.election_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for waiting for other members to finish a role election. Defaults to ha.paxos_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.heartbeat_interval</literal></simpara></entry>
<entry align="left" valign="top"><simpara>How often heartbeat messages should be sent. Defaults to ha.default_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.heartbeat_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for heartbeats between cluster members. Should be at least twice that of ha.heartbeat_interval.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.initial_hosts</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A comma-separated list of other members of the cluster to join.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.join_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for joining a cluster. Defaults to ha.broadcast_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.learn_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for learning values. Defaults to ha.default_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.leave_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for waiting for cluster leave to finish. Defaults to ha.broadcast_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.lock_read_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for taking remote (write) locks on slaves. Defaults to ha.read_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.max_concurrent_channels_per_slave</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Maximum number of connections a slave can have to the master.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.paxos_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Default timeout for all Paxos timeouts. Defaults to ha.default_timeout. This value is the default value for settings ha.phase1_timeout, ha.phase2_timeout and ha.election_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.phase1_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for Paxos phase 1. Defaults to ha.paxos_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.phase2_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for Paxos phase 2. Defaults to ha.paxos_timeout.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.pull_interval</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Interval of pulling updates from master.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.read_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>How long a slave will wait for response from master before giving up.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.server_id</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Id for a cluster instance. Must be unique within the cluster.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.server</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Hostname and port to bind the HA server.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.slave_only</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether this instance should only participate as slave in cluster. If set to true, it will never be elected as master.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.state_switch_timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout for waiting for instance to become master or slave.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.tx_push_factor</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of slaves the master will ask to replicate a committed transaction.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ha.tx_push_strategy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Push strategy of a transaction to a slave during commit.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>intercept_committing_transactions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Determines whether any TransactionInterceptors loaded will intercept prepared transactions before they reach the logical log.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>intercept_deserialized_transactions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Determines whether any TransactionInterceptors loaded will intercept externally received transactions (e.g. in HA) before they reach the logical log and are applied to the store.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>jmx.port</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configuration attribute</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>keep_logical_logs</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Make Neo4j keep the logical transaction logs for being able to backup the database.Can be used for specifying the threshold to prune logical logs after. For example "10 days" will prune logical logs that only contains transactions older than 10 days from the current time, or "100k txs" will keep the 100k latest transactions and prune any older transactions.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>label_block_size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the block size for storing labels exceeding in-lined space in node record. This parameter is only honored when the store is created, otherwise it is ignored. The default block size is 60 bytes, and the overhead of each block is the same as for string blocks, i.e., 8 bytes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>log_mapped_memory_stats_filename</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The file where Neo4j will record memory mapping statistics.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>log_mapped_memory_stats_interval</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of records to be loaded between regular logging of memory mapping statistics.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>log_mapped_memory_stats</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Tell Neo4j to regularly log memory mapping statistics.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>logging.threshold_for_rotation</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Threshold in bytes for when database logs (text logs, for debugging, that is) are rotated.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>logical_log_rotation_threshold</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies at which file size the logical log will auto-rotate. 0 means that no rotation will automatically occur based on file size. Default is 25M</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>logical_log</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The base name for the logical log files, either an absolute path or relative to the store_dir setting. This should generally not be changed.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mapped_memory_page_size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Target size for pages of mapped memory.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neo_store</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The base name for the Neo4j Store files, either an absolute path or relative to the store_dir setting. This should generally not be changed.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.nodestore.db.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The size to allocate for memory mapping the node store.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.propertystore.db.arrays.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The size to allocate for memory mapping the array property store.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.propertystore.db.index.keys.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The size to allocate for memory mapping the store for property key strings.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.propertystore.db.index.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The size to allocate for memory mapping the store for property key indexes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.propertystore.db.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The size to allocate for memory mapping the property value store.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.propertystore.db.strings.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The size to allocate for memory mapping the string property store.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>neostore.relationshipstore.db.mapped_memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The size to allocate for memory mapping the relationship store.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>node_auto_indexing</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Controls the auto indexing feature for nodes. Setting to false shuts it down, while true enables it by default for properties listed in the node_keys_indexable setting.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>node_keys_indexable</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A list of property names (comma separated) that will be indexed by default. This applies to Nodes only.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>online_backup_enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enable support for running online backups</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>online_backup_server</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Listening server for online backups</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>read_only</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Only allow read operations from this Neo4j instance. This mode still requires write access to the directory for lock purposes</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>rebuild_idgenerators_fast</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Use a quick approach for rebuilding the ID generators. This give quicker recovery time, but will limit the ability to reuse the space of deleted entities.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>relationship_auto_indexing</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Controls the auto indexing feature for relationships. Setting to false shuts it down, while true enables it by default for properties listed in the relationship_keys_indexable setting.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>relationship_grab_size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>How many relationships to read at a time during iteration</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>relationship_keys_indexable</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A list of property names (comma separated) that will be indexed by default. This applies to Relationships only.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>remote_logging_enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to enable logging to a remote server or not.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>remote_logging_host</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Host for remote logging using LogBack SocketAppender.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>remote_logging_port</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Port for remote logging using LogBack SocketAppender.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>remote_shell_enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enable a remote shell server which shell clients can log in to</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>store_dir</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The directory where the database files are located.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>string_block_size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the block size for storing strings. This parameter is only honored when the store is created, otherwise it is ignored. Note that each character in a string occupies two bytes, meaning that a block size of 120 (the default size) will hold a 60 character long string before overflowing into a second block. Also note that each block carries an overhead of 8 bytes. This means that if the block size is 120, the size of the stored records will be 128 bytes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tx_manager_impl</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of the Transaction Manager service to use as defined in the TM service provider constructor.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>use_memory_mapped_buffers</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Tell Neo4j to use memory mapped buffers for accessing the native storage layer.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Configuration (org.neo4j.jmx.impl.ConfigurationBean) Operations</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">ReturnType</entry>
<entry align="left" valign="top">Signature</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>apply</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Apply settings</simpara></entry>
<entry align="left" valign="top"><simpara><literal>void</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>(no parameters)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="jmx-diagnostics"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Diagnostics (org.neo4j.management.Diagnostics) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>Diagnostics provided by Neo4j</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DiagnosticsProviders</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A list of the ids for the registered diagnostics providers.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>List (java.util.List)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Diagnostics (org.neo4j.management.Diagnostics) Operations</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">ReturnType</entry>
<entry align="left" valign="top">Signature</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>dumpAll</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Dump diagnostics information to JMX</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>(no parameters)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>dumpToLog</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Dump diagnostics information to the log.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>void</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>(no parameters)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>dumpToLog</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Dump diagnostics information to the log.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>void</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>java.lang.String</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>extract</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operation exposed for management</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>java.lang.String</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="jmx-high-availability"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean High Availability (org.neo4j.management.HighAvailability) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>Information about an instance participating in a HA cluster</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Alive</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether this instance is alive or not</simpara></entry>
<entry align="left" valign="top"><simpara><literal>boolean</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Available</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether this instance is available or not</simpara></entry>
<entry align="left" valign="top"><simpara><literal>boolean</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InstanceId</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The identifier used to identify this server in the HA cluster</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InstancesInCluster</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Information about all instances in this cluster</simpara></entry>
<entry align="left" valign="top"><simpara><literal><ulink url="http://components.neo4j.org/neo4j-enterprise/2.0-SNAPSHOT/apidocs/org/neo4j/management/ClusterMemberInfo.html">org.neo4j.management.ClusterMemberInfo</ulink>[] as <ulink url="http://docs.oracle.com/javase/7/docs/api/javax/management/openmbean/CompositeData.html">CompositeData</ulink>[]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LastCommittedTxId</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The latest transaction id present in this instance&#8217;s store</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LastUpdateTime</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The time when the data on this instance was last updated from the master</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Role</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The role this instance has in the cluster</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>MBean High Availability (org.neo4j.management.HighAvailability) Operations</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">ReturnType</entry>
<entry align="left" valign="top">Signature</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>update</literal></simpara></entry>
<entry align="left" valign="top"><simpara>(If this is a slave) Update the database on this instance with the latest transactions from the master</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>(no parameters)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="jmx-kernel"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Kernel (org.neo4j.jmx.Kernel) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>Information about the Neo4j kernel</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KernelStartTime</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The time from which this Neo4j instance was in operational mode.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Date (java.util.Date)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KernelVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The version of Neo4j</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MBeanQuery</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An ObjectName that can be used as a query for getting all management beans for this Neo4j instance.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>javax.management.ObjectName</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ReadOnly</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether this is a read only instance</simpara></entry>
<entry align="left" valign="top"><simpara><literal>boolean</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StoreCreationDate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The time when this Neo4j graph store was created.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Date (java.util.Date)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StoreDirectory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The location where the Neo4j store is located</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StoreId</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An identifier that, together with store creation time, uniquely identifies this Neo4j graph store.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>String</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StoreLogVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The current version of the Neo4j store logical log.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="jmx-locking"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Locking (org.neo4j.management.LockManager) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>Information about the Neo4j lock status</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Locks</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Information about all locks held by Neo4j</simpara></entry>
<entry align="left" valign="top"><simpara><literal>java.util.List&lt;<ulink url="http://components.neo4j.org/neo4j-enterprise/2.0-SNAPSHOT/apidocs/org/neo4j/kernel/info/LockInfo.html">org.neo4j.kernel.info.LockInfo</ulink>&gt; as <ulink url="http://docs.oracle.com/javase/7/docs/api/javax/management/openmbean/CompositeData.html">CompositeData</ulink>[]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NumberOfAvertedDeadlocks</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of lock sequences that would have lead to a deadlock situation that Neo4j has detected and averted (by throwing DeadlockDetectedException).</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Locking (org.neo4j.management.LockManager) Operations</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">ReturnType</entry>
<entry align="left" valign="top">Signature</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>getContendedLocks</literal></simpara></entry>
<entry align="left" valign="top"><simpara>getContendedLocks</simpara></entry>
<entry align="left" valign="top"><simpara><literal>java.util.List&lt;<ulink url="http://components.neo4j.org/neo4j-enterprise/2.0-SNAPSHOT/apidocs/org/neo4j/kernel/info/LockInfo.html">org.neo4j.kernel.info.LockInfo</ulink>&gt; as <ulink url="http://docs.oracle.com/javase/7/docs/api/javax/management/openmbean/CompositeData.html">CompositeData</ulink>[]</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="jmx-memory-mapping"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Memory Mapping (org.neo4j.management.MemoryMapping) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>The status of Neo4j memory mapping</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MemoryPools</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Get information about each pool of memory mapped regions from store files with memory mapping enabled</simpara></entry>
<entry align="left" valign="top"><simpara><literal><ulink url="http://components.neo4j.org/neo4j-enterprise/2.0-SNAPSHOT/apidocs/org/neo4j/management/WindowPoolInfo.html">org.neo4j.management.WindowPoolInfo</ulink>[] as <ulink url="http://docs.oracle.com/javase/7/docs/api/javax/management/openmbean/CompositeData.html">CompositeData</ulink>[]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="jmx-primitive-count"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Primitive count (org.neo4j.jmx.Primitives) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>Estimates of the numbers of different kinds of Neo4j primitives</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NumberOfNodeIdsInUse</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An estimation of the number of nodes used in this Neo4j instance</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NumberOfPropertyIdsInUse</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An estimation of the number of properties used in this Neo4j instance</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NumberOfRelationshipIdsInUse</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An estimation of the number of relationships used in this Neo4j instance</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NumberOfRelationshipTypeIdsInUse</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of relationship types used in this Neo4j instance</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="jmx-store-file-sizes"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Store file sizes (org.neo4j.jmx.StoreFile) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>Information about the sizes of the different parts of the Neo4j graph store</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ArrayStoreSize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of disk space used to store array properties, in bytes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LogicalLogSize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of disk space used by the current Neo4j logical log, in bytes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NodeStoreSize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of disk space used to store nodes, in bytes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PropertyStoreSize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of disk space used to store properties (excluding string values and array values), in bytes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>RelationshipStoreSize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of disk space used to store relationships, in bytes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StringStoreSize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of disk space used to store string properties, in bytes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>TotalStoreSize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The total disk space used by this Neo4j instance, in bytes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="jmx-transactions"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean Transactions (org.neo4j.management.TransactionManager) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>Information about the Neo4j transaction manager</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LastCommittedTxId</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The id of the latest committed transaction</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NumberOfCommittedTransactions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The total number of committed transactions</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NumberOfOpenedTransactions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The total number started transactions</simpara></entry>
<entry align="left" valign="top"><simpara><literal>int</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NumberOfOpenTransactions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of currently open transactions</simpara></entry>
<entry align="left" valign="top"><simpara><literal>int</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NumberOfRolledBackTransactions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The total number of rolled back transactions</simpara></entry>
<entry align="left" valign="top"><simpara><literal>long</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PeakNumberOfConcurrentTransactions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The highest number of transactions ever opened concurrently</simpara></entry>
<entry align="left" valign="top"><simpara><literal>int</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table id="jmx-xa-resources"
frame="none"
rowsep="1" colsep="1"
>
<title>MBean XA Resources (org.neo4j.management.XaManager) Attributes</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="22*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="22*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top" namest="col_1" nameend="col_5"><simpara><emphasis>Information about the XA transaction manager</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>XaResources</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Information about all XA resources managed by the transaction manager</simpara></entry>
<entry align="left" valign="top"><simpara><literal><ulink url="http://components.neo4j.org/neo4j-enterprise/2.0-SNAPSHOT/apidocs/org/neo4j/management/XaResourceInfo.html">org.neo4j.management.XaResourceInfo</ulink>[] as <ulink url="http://docs.oracle.com/javase/7/docs/api/javax/management/openmbean/CompositeData.html">CompositeData</ulink>[]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</chapter>
</part>
<part id="tools">
<title>Tools</title>
<partintro>
<simpara>The Tools part describes available Neo4j tools and how to use them.</simpara>
</partintro>
<chapter id="tools-webadmin">
<title>Web Interface</title>
<simpara>The Neo4j Web Interface is the primary user interface for Neo4j.</simpara>
<simpara>The tool is available at <ulink url="http://127.0.0.1:7474/">http://127.0.0.1:7474/</ulink> after you have installed the <link linkend="server-installation">Neo4j Server</link>.</simpara>
<simpara>See the tool itself for more information!</simpara>
</chapter>
<chapter id="shell">
<title>Neo4j Shell</title>
<simpara>Neo4j shell is a command-line shell for running Cypher queries.
There&#8217;s also commands to get information about the database.
In addition, you can browse the graph, much like how the Unix shell along with commands like <literal>cd</literal>, <literal>ls</literal> and <literal>pwd</literal> can be used to browse your local file system.</simpara>
<simpara>It&#8217;s a nice tool for development and debugging.
This guide will show you how to get it going!</simpara>
<section id="shell-starting">
<title>Starting the shell</title>
<simpara>When used together with a Neo4j server, simply issue the following at the command line:</simpara>
<programlisting language="shell" linenumbering="unnumbered">./bin/neo4j-shell</programlisting>
<simpara>For the full list of options, see the reference in the <link linkend="shell-manpage">Shell manual page</link>.</simpara>
<simpara>To connect to a running Neo4j database, use <xref linkend="read-only-mode"/> for local databases
and see <xref linkend="shell-enabling-remote"/> for remote databases.</simpara>
<simpara>You need to make sure that the shell jar file is on the classpath when you start up your Neo4j instance.</simpara>
<section id="shell-enabling-remote">
<title>Enabling the shell server</title>
<simpara>Shell is enabled from the configuration of the Neo4j kernel, see <xref linkend="server-configuration"/>.
Here&#8217;s some sample configurations:</simpara>
<programlisting language="plain" linenumbering="unnumbered"># Enable the remote shell feature
remote_shell_enabled = true

# The default port is 1337, but you can specify something else if you like
remote_shell_port = 1337

# If you want to be a little protective of your data,
# you can also tell the shell to only support read operations
remote_shell_read_only = true</programlisting>
<simpara>When using the Neo4j server, see <xref linkend="server-configuration"/> for how to add configuration settings in that case.</simpara>
<simpara>There are two ways to start the shell, either by connecting to a remote shell server or by pointing it to a Neo4j store path.</simpara>
</section>
<section id="_connecting_to_a_shell_server">
<title>Connecting to a shell server</title>
<simpara>To start the shell and connect to a running server, run:</simpara>
<programlisting language="plain" linenumbering="unnumbered">neo4j-shell</programlisting>
<simpara>Alternatively supply <literal>-port</literal> and <literal>-name</literal> options depending on how the remote shell server was enabled.
Then you&#8217;ll get the shell prompt like this:</simpara>
<programlisting language="plain" linenumbering="unnumbered">neo4j-sh (0)$</programlisting>
</section>
<section id="_pointing_the_shell_to_a_path">
<title>Pointing the shell to a path</title>
<simpara>To start the shell by just pointing it to a Neo4j store path you run the shell jar file.
Given that the right neo4j-kernel-&lt;version&gt;.jar and jta jar files are in the same path as your neo4j-shell-&lt;version&gt;.jar file you run it with:</simpara>
<programlisting language="plain" linenumbering="unnumbered">$ neo4j-shell -path path/to/neo4j-db</programlisting>
</section>
<section id="read-only-mode">
<title>Read-only mode</title>
<simpara>By issuing the <literal>-readonly</literal> switch when starting the shell with a store path,
changes cannot be made to the database during the session.</simpara>
<programlisting language="plain" linenumbering="unnumbered">$ neo4j-shell -readonly -path path/to/neo4j-db</programlisting>
</section>
<section id="_run_a_command_and_then_exit">
<title>Run a command and then exit</title>
<simpara>It is possible to tell the shell to just start, execute a command and then exit.
This opens up for uses of background jobs and also handling of huge output of f.ex. an <literal>ls</literal> command where you then could pipe the output to <literal>less</literal> or another reader of your choice, or even to a file.</simpara>
<simpara>And even to another neo4j-shell, e.g. for importing a <literal>dump</literal> of another database or cypher result. When used with command mode the shell will not output a welcome message.
So some examples of usage:</simpara>
<programlisting language="plain" linenumbering="unnumbered">$ neo4j-shell -c "cd -a 24 &amp;&amp; set name Mattias"
$ neo4j-shell -c "trav -r KNOWS" | less</programlisting>
</section>
<section id="_pass_neo4j_configuration_options">
<title>Pass Neo4j configuration options</title>
<simpara>By setting the <literal>-config</literal> switch, you can provide a properties file that will be used to configure your Neo4j instance,
if started in embedded mode.</simpara>
<programlisting language="plain" linenumbering="unnumbered">$ neo4j-shell -config conf/neo4j.properties -path mydb</programlisting>
</section>
<section id="_execute_a_file_and_then_exit">
<title>Execute a file and then exit</title>
<simpara>To execute commands from a file  and then exit just provide a <literal>-file
filename</literal>. This is faster than piping to the shell which still handles
the input as if it was user input.</simpara>
<simpara>For example reading a dump file directly from the command line and executing
it against the given database. For example:</simpara>
<programlisting language="plain" linenumbering="unnumbered">$ neo4j-shell -file export.cql &gt; result.txt</programlisting>
<simpara>Supplying <literal>-</literal> as the filename reads from <literal>stdin</literal> instead.</simpara>
</section>
</section>
<section id="shell-options">
<title>Passing options and arguments</title>
<simpara>Passing options and arguments to your commands is very similar to many CLI commands in an *nix environment.
Options are prefixed with a <literal>-</literal> and can contain one or more options.
Some options expect a value to be associated with it.
Arguments are string values which aren&#8217;t prefixed with <literal>-</literal>.
Let&#8217;s look at <literal>ls</literal> as an example:</simpara>
<simpara><literal>ls -r -f KNOWS:out -v 12345</literal> will make a verbose listing of node <literal>12345</literal>'s outgoing relationships of type <literal>KNOWS</literal>.
The node id, <literal>12345</literal>, is an argument to <literal>ls</literal> which tells it to do the listing on that node instead of the current node (see <literal>pwd</literal> command).
However a shorter version of this can be written:</simpara>
<simpara><literal>ls -rfv KNOWS:out 12345</literal>. Here all three options are written together after a single <emphasis><literal>-</literal></emphasis> prefix.
Even though <literal>f</literal> is in the middle it gets associated with the <literal>KNOWS:out</literal> value.
The reason for this is that the <literal>ls</literal> command doesn&#8217;t expect any values associated with the <literal>r</literal> or <literal>v</literal> options.
So, it can infer the right values for the rights options.</simpara>
</section>
<section id="shell-options-enum">
<title>Enum options</title>
<simpara>Some options expects a value which is one of the values in an enum, f.ex. direction part of relationship type filtering where there&#8217;s <literal>INCOMING</literal>, <literal>OUTGOING</literal> and <literal>BOTH</literal>.
All such values can be supplied in an easier way.
It&#8217;s enough that you write the start of the value and the interpreter will find what you really meant.
F.ex. <literal>out</literal>, <literal>in</literal>, <literal>i</literal> or even <literal>INCOMING</literal>.</simpara>
</section>
<section id="shell-filters">
<title>Filters</title>
<simpara>Some commands makes use of filters for varying purposes.
F.ex. <literal>-f</literal> in <literal>ls</literal> and in <literal>trav</literal>.
A filter is supplied as a <ulink url="http://www.json.org/">json</ulink> object (w/ or w/o the surrounding <literal>{}</literal> brackets.
Both keys and values can contain regular expressions for a more flexible matching.
An example of a filter could be <literal>.*url.*:http.*neo4j.*,name:Neo4j</literal>.
The filter option is also accompanied by the options <literal>-i</literal> and <literal>-l</literal> which stands for <literal>ignore case</literal> (ignore casing of the characters) and <literal>loose matching</literal> (it&#8217;s considered a match even if the filter value just matches a part of the compared value, not necessarily the entire value).
So for a case-insensitive, loose filter you can supply a filter with <literal>-f -i -l</literal> or <literal>-fil</literal> for short.</simpara>
</section>
<section id="shell-titles">
<title>Node titles</title>
<simpara>To make it easier to navigate your graph the shell can display a title for each node, f.ex. in <literal>ls -r</literal>.
It will display the relationships as well as the nodes on the other side of the relationships.
The title is displayed together with each node and its best suited property value from a list of property keys.</simpara>
<simpara>If you&#8217;re standing on a node which has two <literal>KNOWS</literal> relationships to other nodes it&#8217;d be difficult to know which friend is which.
The title feature addresses this by reading a list of property keys and grabbing the first existing property value of those keys and displays it as a title for the node.
So you may specify a list (with or without regular expressions), f.ex: <literal>name,title.*,caption</literal> and the title for each node will be the property value of the first existing key in that list.
The list is defined by the client (you) using the <literal>TITLE_KEYS</literal> environment variable (see <xref linkend="shell-env-vars"/>) and the default being <literal>.*name.*,.*title.*</literal></simpara>
</section>
<section id="shell-commands">
<title>How to use (individual commands)</title>
<simpara>The shell is modeled after Unix shells like bash that you use to walk around your local file system.
It has some of the same commands, like <literal>cd</literal> and <literal>ls</literal>.
When you first start the shell (see instructions above), you will get a list of all the available commands.
Use <literal>man &lt;command&gt;</literal> to get more info about a particular command. Some notes:</simpara>
<section id="comments">
<title>Comments</title>
<simpara>Single line comments, which will be ignored, can be made by using the prefix <literal>//</literal>. Example:</simpara>
<programlisting language="plain" linenumbering="unnumbered">// This is a comment</programlisting>
</section>
<section id="shell-current-pos">
<title>Current node/relationship and path</title>
<simpara>You have a current node/relationship and a "current path" (like a current working directory in bash) that you&#8217;ve traversed so far.
When the shell first starts you are not positioned on any entity, but you can <literal>cd</literal> your way through the graph (check your current path at any time with the <literal>pwd</literal> command).
<literal>cd</literal> can be used in different ways:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>cd &lt;node-id&gt;</literal> will traverse one relationship to the supplied node id. The node must have a direct relationship to the current node.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>cd -a &lt;node-id&gt;</literal> will do an absolute path change, which means the supplied node doesn&#8217;t have to have a direct relationship to the current node.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>cd -r &lt;relationship-id&gt;</literal> will traverse to a relationship instead of a node. The relationship must have the current node as either start or end point. To see the relationship ids use the <literal>ls -vr</literal> command on nodes.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>cd -ar &lt;relationship-id&gt;</literal> will do an absolute path change which means the relationship can be any relationship in the graph.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>cd ..</literal> will traverse back one step to the previous location, removing the last path item from your current path (<literal>pwd</literal>).
</simpara>
</listitem>
<listitem>
<simpara>
<literal>cd start</literal> <emphasis>(only if your current location is a relationship)</emphasis>. Traverses to the start node of the relationship.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>cd end</literal> <emphasis>(only if your current location is a relationship)</emphasis>. Traverses to the end node of the relationship.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="shell-listing">
<title>Listing the contents of a node/relationship</title>
<simpara>List contents of the current node/relationship (or any other node) with the <literal>ls</literal> command.
Please note that it will give an empty output if the current node/relationship has no properties or relationships (for example in the case of a brand new graph).
<literal>ls</literal> can take a node id as argument as well as filters, see <xref linkend="shell-filters"/> and for information about how to specify direction see <xref linkend="shell-options-enum"/>.
Use <literal>man ls</literal> for more info.</simpara>
</section>
<section id="_creating_nodes_and_relationships">
<title>Creating nodes and relationships</title>
<simpara>You create new nodes by connecting them with relationships to the current node.
For example, <literal>mkrel -t A_RELATIONSHIP_TYPE -d OUTGOING -c</literal> will create a new node (<literal>-c</literal>) and draw to it an <literal>OUTGOING</literal> relationship of type <literal>A_RELATIONSHIP_TYPE</literal> from the current node.
If you already have two nodes which you&#8217;d like to draw a relationship between (without creating a new node) you can do for example, <literal>mkrel -t A_RELATIONSHIP_TYPE -d OUTGOING -n &lt;other-node-id&gt;</literal> and it will just create a new relationship between the current node and that other node.</simpara>
</section>
<section id="_setting_renaming_and_removing_properties">
<title>Setting, renaming and removing properties</title>
<simpara>Property operations are done with the <literal>set</literal>, <literal>mv</literal> and <literal>rm</literal> commands.
These commands operates on the current node/relationship.</simpara>
<simpara>Use <literal>set &lt;key&gt; &lt;value&gt;</literal>, optionally with the <literal>-t</literal> option (for value type), to set a property.
Supports every type of value that Neo4j supports. Examples of a property of type <literal>int</literal>:</simpara>
<programlisting language="plain" linenumbering="unnumbered">$ set -t int age 29</programlisting>
<simpara>And an example of setting a <literal>double[]</literal> property:</simpara>
<programlisting language="plain" linenumbering="unnumbered">$ set -t double[] my_values [1.4,12.2,13]</programlisting>
<simpara>Example of setting a <literal>String</literal> property containing a JSON string:</simpara>
<programlisting language="plain" linenumbering="unnumbered">mkrel -c -d i -t DOMAIN_OF --np "{'app':'foobar'}"</programlisting>
<itemizedlist>
<listitem>
<simpara>
<literal>rm &lt;key&gt;</literal> removes a property.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>mv &lt;key&gt; &lt;new-key&gt;</literal> renames a property from one key to another.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_deleting_nodes_and_relationships">
<title>Deleting nodes and relationships</title>
<simpara>Deletion of nodes and relationships is done with the <literal>rmnode</literal> and <literal>rmrel</literal> commands.
<literal>rmnode</literal> can delete nodes, if the node to be deleted still has relationships they can also be deleted by supplying -f option.
<literal>rmrel</literal> can delete relationships, it tries to ensure connectedness in the graph, but relationships can be deleted regardless with the -f option.
<literal>rmrel</literal> can also delete the node on the other side of the deleted relationship if it&#8217;s left with no more relationships, see -d option.</simpara>
</section>
<section id="shell-env-vars">
<title>Environment variables</title>
<simpara>The shell uses environment variables a-la bash to keep session information, such as the current path and more.
The commands for this mimics the bash commands <literal>export</literal> and <literal>env</literal>. For example you can at anytime issue a <literal>export STACKTRACES=true</literal> command to set the <literal>STACKTRACES</literal> environment variable to <literal>true</literal>. This will then result in stacktraces being printed if an exception or error should occur.
Allowed values are all parseable JSON strings, so maps <literal>{age:10,name:"Mattias"}</literal> and arrays <literal>[1,2,3]</literal> are also supported.</simpara>
<simpara>Variables can also be assigned to each other. E.g. <literal>a=b</literal> will result in <literal>a</literal> containing the value of <literal>b</literal>.</simpara>
<simpara>This becomes especially interesting as all shell variables are automatically passed to cypher statements as parameters. That makes it easy to query for certain start nodes or
 create nodes and relationships with certain provided properties (as maps).</simpara>
<simpara>Values are removed by setting them to <literal>null</literal> or an empty value. List environment variables using <literal>env</literal></simpara>
</section>
<section id="_executing_groovy_python_scripts">
<title>Executing groovy/python scripts</title>
<simpara>The shell has support for executing scripts, such as <ulink url="http://groovy.codehaus.org">Groovy</ulink> and <ulink url="http://www.python.org">Python</ulink> (via <ulink url="http://www.jython.org">Jython</ulink>).
As of now the scripts (*.groovy, *.py) must exist on the server side and gets called from a client with for example, <literal>gsh --renamePerson 1234 "Mathias" "Mattias" --doSomethingElse</literal> where the scripts renamePerson.groovy and doSomethingElse.groovy must exist on the server side in any of the paths given by the <literal>GSH_PATH</literal> environment variable (defaults to .:src:src/script). This variable is like the java classpath, separated by a <literal>:</literal>. The python/jython scripts can be executed with the <literal>jsh</literal> in a similar fashion, however the scripts have the .py extension and the environment variable for the paths is <literal>JSH_PATH</literal>.</simpara>
<simpara>When writing the scripts assume that there&#8217;s made available an <literal>args</literal> variable (a String[]) which contains the supplied arguments.
In the case of the <literal>renamePerson</literal> example above the array would contain <literal>["1234", "Mathias", "Mattias"]</literal>.
Also please write your outputs to the <literal>out</literal> variable, such as <literal>out.println( "My tracing text" )</literal> so that it will be printed at the shell client instead of the server.</simpara>
</section>
<section id="_traverse">
<title>Traverse</title>
<simpara>You can traverse the graph with the <literal>trav</literal> command which allows for simple traversing from the current node.
You can supply which relationship types (w/ regex matching) and optionally direction as well as property filters for matching nodes.
In addition to that you can supply a command line to execute for each match.
An example: <literal>trav -o depth -r KNOWS:both,HAS_.*:incoming -c "ls $n"</literal>.
Which means traverse depth first for relationships with type <literal>KNOWS</literal> disregarding direction and incoming relationships with type matching <literal>HAS_.\*</literal> and do a <literal>ls &lt;matching node&gt;</literal> for each match. The node filtering is supplied with the <literal>-f</literal> option, see <xref linkend="shell-filters"/>.
See <xref linkend="shell-options-enum"/> for the traversal order option. Even relationship types/directions are supplied using the same format as filters.</simpara>
</section>
<section id="_query_with_cypher">
<title>Query with Cypher</title>
<simpara>You can use Cypher to query the graph. For that, use the <literal>match</literal> or <literal>start</literal> command.
You can also use <literal>create</literal> statements to create nodes and relationships and use the <literal>cypher VERSION</literal> prefix to select a certain cypher version.</simpara>
<tip><simpara>Cypher queries need to be terminated by a semicolon <literal>;</literal>.</simpara></tip>
<simpara>Cypher commands are given all shell variables as parameters and the special <literal>self</literal> parameter for the current node or relationship.</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>start n = node(0) return n;</literal> will give you a listing of the node with ID 0
</simpara>
</listitem>
<listitem>
<simpara>
<literal>cypher 1.9 start n = node(0) return n;</literal> will execute the query with Cypher version 1.9
</simpara>
</listitem>
<listitem>
<simpara>
<literal>START n = node({self}) MATCH (n)-[:KNOWS]-&gt;(friend) RETURN friend;</literal> will
return the nodes connected to the current node.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>START n=node({me}) CREATE friend={props}, (me)-[r:KNOWS]-&gt;(friend);</literal> will
create the friend and the relationship according to the variables available.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="shell-listing-indexes-and-constraints">
<title>Listing Indexes and Constraints</title>
<simpara>The <literal>schema</literal> command allows to list all existing indexes and constraints together with their current status.</simpara>
<note><simpara>This command does not list legacy indexes. For working with legacy indexes, please see <xref linkend="shell-legacy-indexing"/>.</simpara></note>
<simpara>List all indexes and constraints:</simpara>
<programlisting language="plain" linenumbering="unnumbered">schema</programlisting>
<simpara>List indexes or constraints on <literal>:Person</literal> nodes for the property <literal>name</literal>:</simpara>
<programlisting language="plain" linenumbering="unnumbered">schema -l :Person -p name</programlisting>
<simpara>The <literal>schema</literal> command supports the following parameters:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>-l :Label</literal> only list indexes or constraints for the given label <literal>:Label</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>-p propertyKey</literal> only list indexes or constraints for the given property key <literal>propertyKey</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>-v</literal> if an index is in the <literal>FAILED</literal> state, print a verbose error cause if available
</simpara>
</listitem>
</itemizedlist>
<simpara>Indexes and constraints can be created or removed using Cypher or the Java Core API. They are updated automatically
whenever the graph is changed.  See <xref linkend="graphdb-neo4j-schema"/> for more information.</simpara>
</section>
<section id="shell-legacy-indexing">
<title>Legacy Indexing</title>
<simpara>It&#8217;s possible to query and manipulate legacy indexes via the index command.</simpara>
<simpara>Example: <literal>index -i persons name</literal> (will index the name for the current node or relationship in the "persons" legacy index).</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>-g</literal> will do exact lookup in the legacy index and display hits. You can supply <literal>-c</literal> with a command to be executed for each hit.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>-q</literal> will ask the legacy index a query and display hits. You can supply <literal>-c</literal> with a command to be executed for each hit.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>--cd</literal> will change current location to the hit from the query. It&#8217;s just a convenience for using the <literal>-c</literal> option.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>--ls</literal> will do a listing of the contents for each hit. It&#8217;s just a convenience for using the <literal>-c</literal> option.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>-i</literal> will index a key-value pair into a legacy index for the current node/relationship. If no value is given the property value for that key for the current node is used as value.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>-r</literal> will remove a key-value pair (if it exists) from a legacy index for the current node/relationship. Key and value are optional.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>-t</literal> will set the legacy index type to work with, for example <literal>index -t Relationship --delete friends</literal> will delete the <literal>friends</literal> relationship index.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_transactions">
<title>Transactions</title>
<simpara>It is useful to be able to test changes, and then being able to commit or rollback said changes.</simpara>
<simpara>Transactions can be nested. With a nested transaction, a commit does not write any changes to disk, except for the
top level transaction. A rollback, however works regardless of the level of the transaction. It will roll back
all open transactions.</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>begin transaction</literal>  Starts a transaction.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>commit</literal> Commits a transaction.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>rollback</literal> Rollbacks all open transactions.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_dumping_the_database_or_a_cypher_result_to_cypher_statements">
<title>Dumping the database or a cypher result to Cypher statements</title>
<simpara>As a simple way of exporting a database or a subset of it, the <literal>dump</literal> command converts the graph of a Cypher result or the whole database into a single Cypher <literal>create</literal> statement.</simpara>
<simpara>Examples:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>dump</literal> dumps the whole database as single cypher create statement
</simpara>
</listitem>
<listitem>
<simpara>
<literal>dump START n=node({self}) MATCH p=(n)-[r:KNOWS*]-&gt;(m) RETURN n,r,m;</literal> dumps the transitive friendship graph of the current node.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>neo4j-shell -path db1 -c 'dump MATCH p=(n:Person {name:"Mattias"})-[r:KNOWS]-&gt;(m) RETURN p;' | neo4j-shell -path db2 -file -</literal>
  imports the subgraph of the first database (db1) into the second (db2)
</simpara>
</listitem>
</itemizedlist>
<section id="_example_dump_scripts">
<title>Example Dump Scripts</title>
<programlisting language="bash" linenumbering="unnumbered"> # create a new node and go to it
 neo4j-sh (?)$ mknode --cd --np "{'name':'Neo'}"

 # create a relationship
 neo4j-sh (Neo,0)$ mkrel -c -d i -t LIKES --np "{'app':'foobar'}"

 # Export the cypher statement results
 neo4j-sh (Neo,0)$ dump START n=node({self}) MATCH (n)-[r]-(m) return n,r,m;
 begin
 create (_0 {`name`:"Neo"})
 create (_1 {`app`:"foobar"})
 create _1-[:`LIKES`]-&gt;_0
 ;
 commit</programlisting>
<programlisting language="bash" linenumbering="unnumbered"> # create an index
 neo4j-sh (?)$ create index on :Person(name);
 +-------------------+
 | No data returned. |
 +-------------------+
 Indexes added: 1
 1032 ms


 # create one labeled node and a relationship
 neo4j-sh (?)$ create (m:Person:Hacker {name:'Mattias'}), (m)-[:KNOWS]-&gt;(m);
 +-------------------+
 | No data returned. |
 +-------------------+
 Nodes created: 1
 Relationships created: 1
 Properties set: 1
 Labels added: 2
 354 ms


 # Export the whole database including indexes
 neo4j-sh (?)$ dump
 begin
 create index on :`Person`(`name`)
 create (_0:`Person`:`Hacker` {`name`:"Mattias"})
 create _0-[:`KNOWS`]-&gt;_0
 ;
 commit</programlisting>
</section>
</section>
</section>
<section id="shell-sample-session">
<title>An example shell session</title>
<programlisting language="bash" linenumbering="unnumbered"> # Create a node
 neo4j-sh (?)$ mknode --cd

 # where are we?
 neo4j-sh (0)$ pwd
 Current is (0)
 (0)


 # On the current node, set the key "name" to value "Jon"
 neo4j-sh (0)$ set name "Jon"

 # send a cypher query
 neo4j-sh (Jon,0)$ start n=node(0) return n;
 +---------------------+
 | n                   |
 +---------------------+
 | Node[0]{name:"Jon"} |
 +---------------------+
 1 row
 331 ms


 # make an incoming relationship of type LIKES, create the end node with the node properties specified.
 neo4j-sh (Jon,0)$ mkrel -c -d i -t LIKES --np "{'app':'foobar'}"

 # where are we?
 neo4j-sh (Jon,0)$ ls
 *name =[Jon]
 (me)&lt;-[:LIKES]-(1)


 # change to the newly created node
 neo4j-sh (Jon,0)$ cd 1

 # list relationships, including relationship id
 neo4j-sh (1)$ ls -avr
 (me)-[:LIKES,0]-&gt;(Jon,0)


 # create one more KNOWS relationship and the end node
 neo4j-sh (1)$ mkrel -c -d i -t KNOWS --np "{'name':'Bob'}"

 # print current history stack
 neo4j-sh (1)$ pwd
 Current is (1)
 (Jon,0)--&gt;(1)


 # verbose list relationships
 neo4j-sh (1)$ ls -avr
 (me)-[:LIKES,0]-&gt;(Jon,0)
 (me)&lt;-[:KNOWS,1]-(Bob,2)</programlisting>
</section>
<section id="shell-matrix-example">
<title>A Matrix example</title>
<simpara>This example is creating a graph of the characters in the Matrix via the shell and then executing Cypher queries against it:</simpara>
<figure><title>Shell Matrix Example</title>
<ulink url="images/Shell-Matrix-Example-graph.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Shell-Matrix-Example-graph.svg"/>
  </imageobject>
  <textobject><phrase>Shell-Matrix-Example-graph.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara>Neo4j is configured for autoindexing, in this case with the following in the Neo4j configuration file:</simpara>
<programlisting language="plain" linenumbering="unnumbered">node_auto_indexing=true
node_keys_indexable=name,age

relationship_auto_indexing=true
relationship_keys_indexable=ROOT,KNOWS,CODED_BY</programlisting>
<simpara>The following is a sample shell session creating the Matrix graph and querying it.</simpara>
<programlisting language="bash" linenumbering="unnumbered"> # Create a reference node
 neo4j-sh (?)$ mknode --cd

 # create the Thomas Andersson node
 neo4j-sh (0)$ mkrel -t ROOT -c -v
 Node (1) created
 Relationship [:ROOT,0] created


 # go to the new node
 neo4j-sh (0)$ cd 1

 # set the name property
 neo4j-sh (1)$ set name "Thomas Andersson"

 # create Thomas direct friends
 neo4j-sh (Thomas Andersson,1)$ mkrel -t KNOWS -cv
 Node (2) created
 Relationship [:KNOWS,1] created


 # go to the new node
 neo4j-sh (Thomas Andersson,1)$ cd 2

 # set the name property
 neo4j-sh (2)$ set name "Trinity"

 # go back in the history stack
 neo4j-sh (Trinity,2)$ cd ..

 # create Thomas direct friends
 neo4j-sh (Thomas Andersson,1)$ mkrel -t KNOWS -cv
 Node (3) created
 Relationship [:KNOWS,2] created


 # go to the new node
 neo4j-sh (Thomas Andersson,1)$ cd 3

 # set the name property
 neo4j-sh (3)$ set name "Morpheus"

 # create relationship to Trinity
 neo4j-sh (Morpheus,3)$ mkrel -t KNOWS 2

 # list the relationships of node 3
 neo4j-sh (Morpheus,3)$ ls -rv
 (me)-[:KNOWS,3]-&gt;(Trinity,2)
 (me)&lt;-[:KNOWS,2]-(Thomas Andersson,1)


 # change the current position to relationship #2
 neo4j-sh (Morpheus,3)$ cd -r 2

 # set the age property on the relationship
 neo4j-sh [:KNOWS,2]$ set -t int age 3

 # back to Morpheus
 neo4j-sh [:KNOWS,2]$ cd ..

 # next relationship
 neo4j-sh (Morpheus,3)$ cd -r 3

 # set the age property on the relationship
 neo4j-sh [:KNOWS,3]$ set -t int age 90

 # position to the start node of the current relationship
 neo4j-sh [:KNOWS,3]$ cd start

 # new node
 neo4j-sh (Morpheus,3)$ mkrel -t KNOWS -c

 # list relationships on the current node
 neo4j-sh (Morpheus,3)$ ls -r
 (me)-[:KNOWS]-&gt;(Trinity,2)
 (me)-[:KNOWS]-&gt;(4)
 (me)&lt;-[:KNOWS]-(Thomas Andersson,1)


 # go to Cypher
 neo4j-sh (Morpheus,3)$ cd 4

 # set the name
 neo4j-sh (4)$ set name Cypher

 # create new node from Cypher
 neo4j-sh (Cypher,4)$ mkrel -ct KNOWS

 # list relationships
 neo4j-sh (Cypher,4)$ ls -r
 (me)-[:KNOWS]-&gt;(5)
 (me)&lt;-[:KNOWS]-(Morpheus,3)


 # go to the Agent Smith node
 neo4j-sh (Cypher,4)$ cd 5

 # set the name
 neo4j-sh (5)$ set name "Agent Smith"

 # outgoing relationship and new node
 neo4j-sh (Agent Smith,5)$ mkrel -cvt CODED_BY
 Node (6) created
 Relationship [:CODED_BY,6] created


 # go there
 neo4j-sh (Agent Smith,5)$ cd 6

 # set the name
 neo4j-sh (6)$ set name "The Architect"

 # go to the first node in the history stack
 neo4j-sh (The Architect,6)$ cd

 # Morpheus' friends, looking up Morpheus by name in the Neo4j autoindex
 neo4j-sh (?)$ start morpheus = node:node_auto_index(name='Morpheus') match morpheus-[:KNOWS]-zionist return zionist.name;
 +--------------------+
 | zionist.name       |
 +--------------------+
 | "Trinity"          |
 | "Cypher"           |
 | "Thomas Andersson" |
 +--------------------+
 3 rows
 279 ms


 # Morpheus' friends, looking up Morpheus by name in the Neo4j autoindex
 neo4j-sh (?)$ cypher 2.0 start morpheus = node:node_auto_index(name='Morpheus') match morpheus-[:KNOWS]-zionist return zionist.name;
 +--------------------+
 | zionist.name       |
 +--------------------+
 | "Trinity"          |
 | "Cypher"           |
 | "Thomas Andersson" |
 +--------------------+
 3 rows
 245 ms</programlisting>
</section>
</chapter>
</part>
<part id="community">
<title>Community</title>
<partintro>
<simpara>The Neo4j project has a strong community around it.
Read about how to get help from the community and how to contribute to it.</simpara>
</partintro>
<chapter id="community-support">
<title>Community Support</title>
<simpara>You can learn a lot about Neo4j on different <emphasis>events.</emphasis>
To get information on upcoming Neo4j events, have a look here:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://www.neo4j.org/">http://www.neo4j.org/</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://neo4j.meetup.com/">http://neo4j.meetup.com/</ulink>
</simpara>
</listitem>
</itemizedlist>
<simpara>Get help from the Neo4j open source community; here are some starting points.</simpara>
<itemizedlist>
<listitem>
<simpara>
The neo4j tag at stackoverflow: <ulink url="http://stackoverflow.com/questions/tagged/neo4j">http://stackoverflow.com/questions/tagged/neo4j</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
Neo4j Community Discussions: <ulink url="https://groups.google.com/forum/#!forum/neo4j">https://groups.google.com/forum/#!forum/neo4j</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
Twitter: <ulink url="https://twitter.com/neo4j">https://twitter.com/neo4j</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
IRC channel: <ulink url="irc://irc.freenode.net/neo4j">irc://irc.freenode.net/neo4j</ulink> <ulink url="http://webchat.freenode.net/?randomnick=1&amp;channels=neo4j">web chat</ulink>.
</simpara>
</listitem>
</itemizedlist>
<simpara>Report a <emphasis>bug</emphasis> or add a <emphasis>feature request</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://github.com/neo4j/neo4j/issues">https://github.com/neo4j/neo4j/issues</ulink>
</simpara>
</listitem>
</itemizedlist>
<simpara>Questions regarding the <emphasis>documentation:</emphasis>
The Neo4j Manual is published online with a comment function, please use that to post any questions or comments regarding the documentation.
See <ulink url="http://docs.neo4j.org/chunked/2.0-SNAPSHOT/">http://docs.neo4j.org/chunked/2.0-SNAPSHOT/</ulink>.</simpara>
</chapter>
<chapter id="community-contributing">
<title>Contributing to Neo4j</title>
<simpara>The Neo4j project is an Open Source effort to bring fast complex data storage and processing to life. Every form of help is highly appreciated by the community - and you are not alone, see <xref linkend="contributors"/>!</simpara>
<simpara>One crucial aspect of contributing to the Neo4j project is the <xref linkend="cla"/>.</simpara>
<simpara>In short: make sure to sign the CLA and send in the email, or the Neo4j project won&#8217;t be able to accept your contribution.</simpara>
<simpara>Note that you can contribute to Neo4j also by contributing documentation or giving feedback on the current documentation.
Basically, at all the places where you can get help, there&#8217;s also room for contributions.</simpara>
<simpara>If you want to contribute, there are some good areas to start with, especially for getting in contact with the community, <xref linkend="community-support"/>.</simpara>
<simpara>To document your efforts, we highly recommend to read <xref linkend="community-docs"/>.</simpara>
<section id="cla">
<title>Contributor License Agreement</title>
<section id="_summary">
<title>Summary</title>
<simpara>We require all source code that is hosted on the Neo4j infrastructure to be contributed through the <ulink url="http://dist.neo4j.org/neo4j-cla.pdf">Neo4j Contributor License Agreement</ulink> (CLA). The purpose of the Neo4j Contributor License Agreement is to protect the integrity of the code base, which in turn protects the community around that code base: the founding entity Neo Technology, the Neo4j developer community and the Neo4j users. This kind of contributor agreement is common amongst free software and open source projects (it is in fact very similar to the widely signed  <ulink url="http://www.oracle.com/technetwork/community/oca-486395.html">Oracle Contributor Agreement</ulink>).</simpara>
<simpara>Please see the below or send a mail to admins [at] neofourjay.org if you have any other questions about the intent of the CLA. If you have a legal question, please ask a lawyer.</simpara>
</section>
<section id="_common_questions">
<title>Common questions</title>
<section id="_am_i_losing_the_rights_to_my_own_code">
<title>Am I losing the rights to my own code?</title>
<simpara>No, the <ulink url="http://dist.neo4j.org/neo4j-cla.pdf">Neo4j CLA</ulink> only asks you to <emphasis>share</emphasis> your rights, not relinquish them. Unlike some contribution agreements that require you to transfer copyrights to another organization, the CLA does not take away your rights to your contributed intellectual property. When you agree to the CLA, you grant us joint ownership in copyright, and a patent license for your contributions. You retain all rights, title, and interest in your contributions and may use them for any purpose you wish. Other than revoking our rights, you can still do whatever you want with your code.</simpara>
</section>
<section id="_what_can_you_do_with_my_contribution">
<title>What can you do with my contribution?</title>
<simpara>We may exercise all rights that a copyright holder has, as well as the rights you grant in the <ulink url="http://dist.neo4j.org/neo4j-cla.pdf">Neo4j CLA</ulink> to use any patents you have in your contributions. As the CLA provides for joint copyright ownership, you may exercise the same rights as we in your contributions.</simpara>
</section>
<section id="_what_are_the_community_benefits_of_this">
<title>What are the community benefits of this?</title>
<simpara>Well, it allows us to sponsor the Neo4j projects and provide an infrastructure for the community, while making sure that we can include this in software that we ship to our customers without any nasty surprises. Without this ability, we as a small company would be hard pressed to release all our code as free software.</simpara>
<simpara>Moreover, the CLA lets us protect community members (both developers and users) from hostile intellectual property litigation should the need arise. This is in line with how other free software stewards like the <ulink url="http://www.fsf.org">Free Software Foundation - FSF</ulink> defend projects (except with the FSF, there&#8217;s no shared copyright but instead you completely sign it over to the FSF). The contributor agreement also includes a &#8220;free software covenant,&#8221; or a promise that a contribution will remain available as free software.</simpara>
<simpara>At the end of the day, you still retain all rights to your contribution and we can stand confident that we can protect the Neo4j community and the Neo Technology customers.</simpara>
</section>
<section id="_can_we_discuss_some_items_in_the_cla">
<title>Can we discuss some items in the CLA?</title>
<simpara>Absolutely! Please give us feedback! But let&#8217;s keep the legalese off the mailing lists. Please mail your feedback directly to cla (@t) neotechnology dot cöm and we&#8217;ll get back to you.</simpara>
</section>
<section id="_i_still_don_8217_t_like_this_cla">
<title>I still don&#8217;t like this CLA.</title>
<simpara>That&#8217;s fine. You can still host it anywhere else, of course. Please do! We&#8217;re only talking here about the rules for the infrastructure that we provide.</simpara>
</section>
</section>
<section id="_how_to_sign">
<title>How to sign</title>
<simpara>When you&#8217;ve read through the CLA, please send a mail to cla (@t) neotechnology dot cöm. Include the following information:</simpara>
<itemizedlist>
<listitem>
<simpara>
Your full name.
</simpara>
</listitem>
<listitem>
<simpara>
Your e-mail address.
</simpara>
</listitem>
<listitem>
<simpara>
An attached copy of the <ulink url="http://dist.neo4j.org/neo4j-cla.pdf">Neo4j CLA</ulink>.
</simpara>
</listitem>
<listitem>
<simpara>
That you agree to its terms.
</simpara>
</listitem>
</itemizedlist>
<simpara>For example:</simpara>
<screen>Hi. My name is John Doe (john@doe.com).
I agree to the terms in the attached Neo4j Contributor License Agreement.</screen>
</section>
</section>
<section id="community-contribution-areas">
<title>Areas for contribution</title>
<simpara>Neo4j is a project with a vast ecosystem and a lot of space for contributions. Where you can and want to pitch in depends of course on your time, skill set and interests. Below are some of the areas that might interest you:</simpara>
<section id="_neo4j_core_projects">
<title>Neo4j Core Projects</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://github.com/neo4j/neo4j/issues">The Neo4j open issues</ulink> for some starting points for contribution
</simpara>
</listitem>
<listitem>
<simpara>
See the <ulink url="https://github.com/neo4j/">GitHub Neo4j area</ulink> for a list of projects
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_maintaining_neo4j_documentation">
<title>Maintaining Neo4j Documentation</title>
<simpara>Some parts of the documentation need extra care from the community to stay up to date.
They typically refer to different kinds of community contributions.
The easiest way to contribute fixes is to comment at the <ulink url="http://docs.neo4j.org/chunked/snapshot/">online HTML version</ulink>.</simpara>
</section>
<section id="_drivers_and_bindings_to_neo4j">
<title>Drivers and bindings to Neo4j</title>
<itemizedlist>
<listitem>
<simpara>
REST: see <xref linkend="languages"/> for a list of active projects
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="community-docs">
<title>Writing Neo4j Documentation</title>
<note><simpara>Other than writing documentation, you can help out by providing comments - head over to the <ulink url="http://docs.neo4j.org/chunked/snapshot/">online HTML version</ulink> to do that!</simpara></note>
<simpara>For how to build the manual see:
<ulink url="https://github.com/neo4j/neo4j/blob/master/manual/README.asciidoc">readme</ulink></simpara>
<simpara>The documents use the asciidoc format, see:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://www.methods.co.nz/asciidoc/">Aciidoc Reference</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://powerman.name/doc/asciidoc">AsciiDoc cheatsheet</ulink>
</simpara>
</listitem>
</itemizedlist>
<simpara>The cheatsheet is really useful!</simpara>
<section id="community-docs-overall-flow">
<title>Overall Flow</title>
<simpara>Each (sub)project has its own documentation, which will produce a <emphasis>docs.jar</emphasis> file.
By default this file is assembled from the contents in <emphasis>src/docs/</emphasis>.
Asciidoc documents have the <literal>.asciidoc</literal> file extension.</simpara>
<simpara>The documents can use code snippets which will extract code from the project.
The corresponding code must be deployed to the <emphasis>sources.jar</emphasis> or <emphasis>test-sources.jar</emphasis> file.</simpara>
<simpara>By setting up a unit test accordingly, documentation can be written directly in the JavaDoc comment.</simpara>
<simpara>The above files are all consumed by the build of the manual (by adding them as dependencies).
To get content included in the manual, it has to be explicitly included by a document in the manual as well.</simpara>
<simpara>Note that different ways to add documentation works best for different cases:</simpara>
<itemizedlist>
<listitem>
<simpara>
For detail level documentation, it works well to write the documentation as part of unit tests (in the JavaDoc comment).
  In this case, you typically do not want to link to the source code in the documentation.
</simpara>
</listitem>
<listitem>
<simpara>
For tutorial level documentation, the result will be best by writing a <literal>.asciidoc</literal> file containing the text.
  Source snippets and output examples can then be included from there.
  In this case you typically want to link to the source code, and users should be able to run it without any special setup.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_file_structure_in_emphasis_docs_jar_emphasis">
<title>File Structure in <emphasis>docs.jar</emphasis></title>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"> Directory </entry>
<entry align="left" valign="top"> Contents</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis>dev/</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>content aimed at developers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>dev/images/</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>images used by the dev docs</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>ops/</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>content aimed at operations</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>ops/images/</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>images used by the ops docs</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>man/</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>manpages</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Additional subdirectories are used as needed to structure the documents,
like <emphasis>dev/tutorial/</emphasis>, <emphasis>ops/tutorial/</emphasis> etc.</simpara>
</section>
<section id="_headings_and_document_structure">
<title>Headings and document structure</title>
<simpara>Each document starts over with headings from level zero (the document title).
Each document should have an id.
In some cases sections in the document need to have id&#8217;s as well, this depends on where they fit in the overall structure.
To be able to link to content, it has to have an id.
Missing id&#8217;s in mandatory places will fail the build.</simpara>
<simpara>This is how a document should start:</simpara>
<programlisting language="plain" linenumbering="unnumbered">[[unique-id-verbose-is-ok]]
= The Document Title =</programlisting>
<simpara>To push the headings down to the right level in the output, the <literal>leveloffset</literal>
attribute is used when including the document inside of another document.</simpara>
<simpara>Subsequent headings in a document should use the following syntax:</simpara>
<programlisting language="plain" linenumbering="unnumbered">== Subheading ==

... content here ...

=== Subsubheading ===

content here ...</programlisting>
<simpara>Asciidoc comes with one more syntax for headings, but in this project it&#8217;s not used.</simpara>
</section>
<section id="_writing">
<title>Writing</title>
<simpara>Put one sentence on each line.
This makes it easy to move content around, and also easy to spot (too) long sentences.</simpara>
</section>
<section id="_gotchas">
<title>Gotchas</title>
<itemizedlist>
<listitem>
<simpara>
A chapter can&#8217;t be empty. (the build will fail on the docbook xml validity check)
</simpara>
</listitem>
<listitem>
<simpara>
Always leave a blank line at the end of documents
  (or the title of the next document might end up in the last
  paragraph of the document)
</simpara>
</listitem>
<listitem>
<simpara>
As <literal>{}</literal> are used for Asciidoc attributes, everything inside will be treated as an attribute.
  What you have to do is to escape the opening brace: <literal>\{</literal>.
  If you don&#8217;t, the braces and the text inside them will be removed without any warning being issued!
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_links">
<title>Links</title>
<simpara>To link to other parts of the manual the id of the target is used.
This is how such a reference looks:</simpara>
<programlisting language="plain" linenumbering="unnumbered">&lt;&lt;community-docs-overall-flow&gt;&gt;</programlisting>
<simpara>Which will render like: <xref linkend="community-docs-overall-flow"/></simpara>
<note><simpara>Just write "see &lt;&lt;target-id&gt;&gt;" and similar, that should suffice in most cases.</simpara></note>
<simpara>If you need to link to another document with your own link text, this is what to do:</simpara>
<programlisting language="plain" linenumbering="unnumbered">&lt;&lt;target-id, link text that fits in the context&gt;&gt;</programlisting>
<note><simpara>Having lots of linked text may work well in a web context but is a pain in print, and we aim for both!</simpara></note>
<simpara>External links are added like this:</simpara>
<programlisting language="plain" linenumbering="unnumbered">http://neo4j.org/[Link text here]</programlisting>
<simpara>Which renders like: <ulink url="http://neo4j.org/">Link text here</ulink></simpara>
<simpara>For short links it may be better not to add a link text, just do:</simpara>
<programlisting language="plain" linenumbering="unnumbered">http://neo4j.org/</programlisting>
<simpara>Which renders like: <ulink url="http://neo4j.org/">http://neo4j.org/</ulink></simpara>
<note><simpara>It&#8217;s ok to have a dot right after the URL, it won&#8217;t be part of the link.</simpara></note>
</section>
<section id="_text_formatting">
<title>Text Formatting</title>
<itemizedlist>
<listitem>
<simpara>
_Italics_ is rendered as <emphasis>Italics</emphasis> and used for emphasis.
</simpara>
</listitem>
<listitem>
<simpara>
*Bold* is rendered as <emphasis role="strong">Bold</emphasis> and used sparingly, for strong emphasis only.
</simpara>
</listitem>
<listitem>
<simpara>
+methodName()+ is rendered as <literal>methodName()</literal> and is used for literals as well
  (note: the content between the <literal>+</literal> signs <emphasis>will</emphasis> be parsed).
</simpara>
</listitem>
<listitem>
<simpara>
`command` is rendered as <literal>command</literal> (typically used for command-line)
  (note: the content between the <literal>`</literal> signs <emphasis>will not</emphasis> be parsed).
</simpara>
</listitem>
<listitem>
<simpara>
Mono++space++d is rendered as Mono<literal>space</literal>d and is used for monospaced letters.
</simpara>
</listitem>
<listitem>
<simpara>
'my/path/' is rendered as <emphasis>my/path/</emphasis> (used for file names and paths).
</simpara>
</listitem>
<listitem>
<simpara>
``Double quoted'' (that is two grave accents to the left and two acute accents to the right) renders as &#8220;Double quoted&#8221;.
</simpara>
</listitem>
<listitem>
<simpara>
`Single quoted' (that is a single grave accent to the left and a single acute accent to the right) renders as &#8216;Single quoted&#8217;.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_admonitions">
<title>Admonitions</title>
<simpara>These are very useful and should be used where appropriate.
Choose from the following (write all caps and no, we can&#8217;t easily add new ones):</simpara>
<note><simpara>Note.</simpara></note>
<tip><simpara>Tip.</simpara></tip>
<important><simpara>Important</simpara></important>
<caution><simpara>Caution</simpara></caution>
<warning><simpara>Warning</simpara></warning>
<simpara>Here&#8217;s how it&#8217;s done:</simpara>
<programlisting language="plain" linenumbering="unnumbered">NOTE: Note.</programlisting>
<simpara>A multiline variation:</simpara>
<programlisting language="plain" linenumbering="unnumbered">[TIP]
Tiptext.
Line 2.</programlisting>
<simpara>Which is rendered as:</simpara>
<tip><simpara>Tiptext.
Line 2.</simpara></tip>
</section>
<section id="_images">
<title>Images</title>
<important><simpara><emphasis>All images in the entire manual share the same namespace.</emphasis>
  You know how to handle that.</simpara></important>
<section id="_images_files">
<title>Images Files</title>
<simpara>To include an image file, make sure it resides in the <emphasis>images/</emphasis> directory relative to the document you&#8217;re including it from. Then go:</simpara>
<programlisting language="plain" linenumbering="unnumbered">image::neo4j-logo.png[]</programlisting>
<simpara>Which is rendered as:</simpara>
<informalfigure>
<ulink url="images/neo4j-logo.png">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/neo4j-logo.png"/>
  </imageobject>
  <textobject><phrase>neo4j-logo.png</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
</section>
<section id="_static_graphviz_dot">
<title>Static Graphviz/DOT</title>
<simpara>We use the Graphviz/DOT language to describe graphs.
For documentation see <ulink url="http://graphviz.org/">http://graphviz.org/</ulink>.</simpara>
<simpara>This is how to include a simple example graph:</simpara>
<programlisting language="plain" linenumbering="unnumbered"> ["dot", "community-docs-graphdb-rels.svg"]
 ----
 "Start node" -&gt; "End node" [label="relationship"]
 ----</programlisting>
<simpara>Which is rendered as:</simpara>
<informalfigure>
<ulink url="images/community-docs-graphdb-rels.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/community-docs-graphdb-rels.svg"/>
  </imageobject>
  <textobject><phrase>community-docs-graphdb-rels.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>Here&#8217;s an example using some predefined variables available in the build:</simpara>
<programlisting language="plain" linenumbering="unnumbered"> ["dot", "community-docs-graphdb-rels-overview.svg", "meta"]
 ----
 "A Relationship" [fillcolor="NODEHIGHLIGHT"]
 "Start node" [fillcolor="NODE2HIGHLIGHT"]
 "A Relationship" -&gt; "Start node" [label="has a"]
 "A Relationship" -&gt; "End node" [label="has a"]
 "A Relationship" -&gt; "Relationship type" [label="has a"]
 "Name" [TEXTNODE]
 "Relationship type" -&gt; "Name" [label="uniquely identified by" color="EDGEHIGHLIGHT" fontcolor="EDGEHIGHLIGHT"]
 ----</programlisting>
<simpara>Which is rendered as:</simpara>
<informalfigure>
<ulink url="images/community-docs-graphdb-rels-overview.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/community-docs-graphdb-rels-overview.svg"/>
  </imageobject>
  <textobject><phrase>community-docs-graphdb-rels-overview.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>The optional second argument given to the dot filter defines the style to use:</simpara>
<itemizedlist>
<listitem>
<simpara>
when not defined: Default styling for nodespace examples.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>neoviz</literal>: Nodespace view generated by Neoviz.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>meta</literal>: Graphs that don&#8217;t resemble db contents, but rather concepts.
</simpara>
</listitem>
</itemizedlist>
<caution><simpara>Keywords of the DOT language have to be surrounded by double quotes when used for other purposes.
  The keywords include <emphasis>node, edge, graph, digraph, subgraph,</emphasis> and <emphasis>strict</emphasis>.</simpara></caution>
</section>
</section>
<section id="_attributes">
<title>Attributes</title>
<simpara>Common attributes you can use in documents:</simpara>
<itemizedlist>
<listitem>
<simpara>
{neo4j-version} - rendered as "2.0-SNAPSHOT"
</simpara>
</listitem>
<listitem>
<simpara>
{neo4j-git-tag} - rendered as "master"
</simpara>
</listitem>
<listitem>
<simpara>
{lucene-version} - rendered as "3_6_2"
</simpara>
</listitem>
</itemizedlist>
<simpara>These can substitute part of URLs that point to for example APIdocs or source code.
Note that neo4j-git-tag also handles the case of snapshot/master.</simpara>
<simpara>Sample Asciidoc attributes which can be used:</simpara>
<itemizedlist>
<listitem>
<simpara>
{docdir} - root directory of the documents
</simpara>
</listitem>
<listitem>
<simpara>
{nbsp} - non-breaking space
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_comments">
<title>Comments</title>
<simpara>There&#8217;s a separate build including comments.
The comments show up with a yellow background.
This build doesn&#8217;t run by default, but after a normal build, you can use <literal>make annotated</literal> to build it.
You can also use the resulting page to search for content, as the full manual is on a single page.</simpara>
<simpara>Here&#8217;s how to write a comment:</simpara>
<programlisting language="plain" linenumbering="unnumbered">// this is a comment</programlisting>
<simpara>The comments are not visible in the normal build.
Comment blocks won&#8217;t be included in the output of any build at all.
Here&#8217;s a comment block:</simpara>
<programlisting language="plain" linenumbering="unnumbered">////
Note that includes in here will still be processed, but not make it into the output.
That is, missing includes here will still break the build!
////</programlisting>
</section>
<section id="_code_snippets">
<title>Code Snippets</title>
<section id="_explicitly_defined_in_the_document">
<title>Explicitly defined in the document</title>
<warning><simpara>Use this kind of code snippets as little as possible.
  They are well known to get out of sync with reality after a while.</simpara></warning>
<simpara>This is how to do it:</simpara>
<programlisting language="plain" linenumbering="unnumbered"> [source,cypher]
 ----
 start n=(2, 1) where (n.age &lt; 30 and n.name = "Tobias") or not(n.name = "Tobias")  return n
 ----</programlisting>
<simpara>Which is rendered as:</simpara>
<programlisting language="cypher" linenumbering="unnumbered">start n=(2, 1) where (n.age &lt; 30 and n.name = "Tobias") or not(n.name = "Tobias")  return n</programlisting>
<simpara>If there&#8217;s no suitable syntax highlighter, just omit the language: <literal>[source]</literal>.</simpara>
<simpara>Currently the following syntax highlighters are enabled:</simpara>
<itemizedlist>
<listitem>
<simpara>
Bash
</simpara>
</listitem>
<listitem>
<simpara>
Cypher
</simpara>
</listitem>
<listitem>
<simpara>
Groovy
</simpara>
</listitem>
<listitem>
<simpara>
Java
</simpara>
</listitem>
<listitem>
<simpara>
JavaScript
</simpara>
</listitem>
<listitem>
<simpara>
Python
</simpara>
</listitem>
<listitem>
<simpara>
XML
</simpara>
</listitem>
</itemizedlist>
<simpara>For other highlighters we could add see <ulink url="http://alexgorbatchev.com/SyntaxHighlighter/manual/brushes/">http://alexgorbatchev.com/SyntaxHighlighter/manual/brushes/</ulink>.</simpara>
</section>
<section id="_fetched_from_source_code">
<title>Fetched from source code</title>
<simpara>Code can be automatically fetched from source files.
You need to define:</simpara>
<itemizedlist>
<listitem>
<simpara>
component: the <literal>artifactId</literal> of the Maven coordinates,
</simpara>
</listitem>
<listitem>
<simpara>
source: path to the file inside the jar it&#8217;s deployed to,
</simpara>
</listitem>
<listitem>
<simpara>
classifier: <literal>sources</literal> or <literal>test-sources</literal> or any other classifier pointing to the artifact,
</simpara>
</listitem>
<listitem>
<simpara>
tag: tag name to search the file for,
</simpara>
</listitem>
<listitem>
<simpara>
the language of the code, if a corresponding syntax highlighter is available.
</simpara>
</listitem>
</itemizedlist>
<simpara>Note that the artifact has to be included as a Maven dependency of the Manual project so that the files can be found.</simpara>
<simpara>Be aware of that the tag "abc" will match "abcd" as well.
It&#8217;s a simple on/off switch, meaning that multiple occurrences will be assembled into a single code snippet in the output.
This behavior can be user to hide away assertions from code examples sourced from tests.</simpara>
<simpara>This is how to define a code snippet inclusion:</simpara>
<programlisting language="plain" linenumbering="unnumbered"> [snippet,java]
 ----
 component=neo4j-examples
 source=org/neo4j/examples/JmxDocTest.java
 classifier=test-sources
 tag=getStartTime
 ----</programlisting>
<simpara>This is how it renders:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[private static Date getStartTimeFromManagementBean(
        GraphDatabaseService graphDbService )
{
    ObjectName objectName = JmxUtils.getObjectName( graphDbService, "Kernel" );
    Date date = JmxUtils.getAttribute( objectName, "KernelStartTime" );
    return date;
}
]]></programlisting>
</section>
<section id="_query_results">
<title>Query Results</title>
<simpara>There&#8217;s a special filter for Cypher query results.
This is how to tag a query result:</simpara>
<programlisting language="plain" linenumbering="unnumbered"> .Result
 [queryresult]
 ----
 +----------------------------------+
 | friend_of_friend.name | count(*) |
 +----------------------------------+
 | Ian                   | 2        |
 | Derrick               | 1        |
 | Jill                  | 1        |
 +----------------------------------+
 3 rows, 12 ms
 ----</programlisting>
<simpara>This is how it renders:</simpara>
<table tabstyle="queryresult table" role="NotInToc" frame="none" rowsep="1" colsep="1"><title>Result</title><tgroup cols="2"><colspec colname="col1"/><colspec colname="col2"/><thead><row><entry align="left" valign="top">friend_of_friend.name</entry><entry align="left" valign="top">count(*)</entry></row></thead><tfoot><row><entry align="left" valign="top" namest="col1" nameend="col2">3 rows, 12 ms</entry></row></tfoot><tbody><row><entry align="left" valign="top"><simpara><literal>Ian</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Derrick</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row><row><entry align="left" valign="top"><simpara><literal>Jill</literal></simpara></entry><entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry></row></tbody></tgroup></table>
</section>
</section>
<section id="_a_sample_java_based_documentation_test">
<title>A sample Java based documentation test</title>
<simpara>For Java, there are a couple of premade utilities that keep code and documentation together in
Javadocs and code snippets that generate Asciidoc for the rest of the toolchain.</simpara>
<simpara>To illustrate this, look at the following documentation that generates the Asciidoc file <literal>hello-world-title.asciidoc</literal> with a content of:</simpara>
<programlisting language="plain" linenumbering="unnumbered">[[examples-hello-world-sample-chapter]]
Hello world Sample Chapter
==========================

This is a sample documentation test, demonstrating different ways of
bringing code and other artifacts into Asciidoc form. The title of the
generated document is determined from the method name, replacing "+_+" with
" ".

Below you see a number of different ways to generate text from source,
inserting it into the JavaDoc documentation (really being Asciidoc markup)
via the +@@+ snippet markers and programmatic adding with runtime data
in the Java code.

- The annotated graph as http://www.graphviz.org/[GraphViz]-generated visualization:

.Hello World Graph
["dot", "Hello-World-Graph-hello-world-Sample-Chapter.svg", "neoviz", ""]
----
  N0 [
    label = "{Node\[0\]name = \'you\'\l}"
  ]
  N1 [
    label = "{Node\[1\]name = \'I\'\l}"
  ]
  N1 -&gt; N0 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "know\n"
  ]
----

- A sample Cypher query:

[source,cypher]
----
START n = node(1)
RETURN n
----

- A sample text output snippet:

[source]
----
Hello graphy world!
----

- a generated source link to the original GIThub source for this test:

https://github.com/neo4j/neo4j/blob/{neo4j-git-tag}/community/embedded-examples/src/test/java/org/neo4j/examples/DocumentationDocTest.java[DocumentationDocTest.java]

- The full source for this example as a source snippet, highlighted as Java code:

[snippet,java]
----
component=neo4j-examples
source=org/neo4j/examples/DocumentationDocTest.java
classifier=test-sources
tag=sampleDocumentation
----

This is the end of this chapter.</programlisting>
<simpara>this file is included in this documentation via</simpara>
<programlisting language="plain" linenumbering="unnumbered">  :leveloffset: 3
  include::{importdir}/neo4j-examples-docs-jar/dev/examples/hello-world-sample-chapter.asciidoc[]</programlisting>
<simpara>which renders the following chapter:</simpara>
</section>
<section id="examples-hello-world-sample-chapter">
<title>Hello world Sample Chapter</title>
<simpara>This is a sample documentation test, demonstrating different ways of
bringing code and other artifacts into Asciidoc form. The title of the
generated document is determined from the method name, replacing "<literal>_</literal>" with
" ".</simpara>
<simpara>Below you see a number of different ways to generate text from source,
inserting it into the JavaDoc documentation (really being Asciidoc markup)
via the <literal>@@</literal> snippet markers and programmatic adding with runtime data
in the Java code.</simpara>
<itemizedlist>
<listitem>
<simpara>
The annotated graph as <ulink url="http://www.graphviz.org/">GraphViz</ulink>-generated visualization:
</simpara>
</listitem>
</itemizedlist>
<figure><title>Hello World Graph</title>
<ulink url="images/Hello-World-Graph-hello-world-Sample-Chapter.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Hello-World-Graph-hello-world-Sample-Chapter.svg"/>
  </imageobject>
  <textobject><phrase>Hello-World-Graph-hello-world-Sample-Chapter.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<itemizedlist>
<listitem>
<simpara>
A sample Cypher query:
</simpara>
</listitem>
</itemizedlist>
<programlisting language="cypher" linenumbering="unnumbered">START n = node(1)
RETURN n</programlisting>
<itemizedlist>
<listitem>
<simpara>
A sample text output snippet:
</simpara>
</listitem>
</itemizedlist>
<programlisting language="plain" linenumbering="unnumbered">Hello graphy world!</programlisting>
<itemizedlist>
<listitem>
<simpara>
a generated source link to the original GIThub source for this test:
</simpara>
</listitem>
</itemizedlist>
<simpara><ulink url="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/test/java/org/neo4j/examples/DocumentationDocTest.java">DocumentationDocTest.java</ulink></simpara>
<itemizedlist>
<listitem>
<simpara>
The full source for this example as a source snippet, highlighted as Java code:
</simpara>
</listitem>
</itemizedlist>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[// START SNIPPET: _sampleDocumentation
package org.neo4j.examples;

import org.junit.Test;

import org.neo4j.kernel.impl.annotations.Documented;
import org.neo4j.test.GraphDescription.Graph;

import static org.neo4j.visualization.asciidoc.AsciidocHelper.createGraphVizWithNodeId;
import static org.neo4j.visualization.asciidoc.AsciidocHelper.createOutputSnippet;

public class DocumentationDocTest extends ImpermanentGraphJavaDocTestBase
{
    /**
     * This is a sample documentation test, demonstrating different ways of
     * bringing code and other artifacts into Asciidoc form. The title of the
     * generated document is determined from the method name, replacing "+_+" with
     * " ".
     *
     * Below you see a number of different ways to generate text from source,
     * inserting it into the JavaDoc documentation (really being Asciidoc markup)
     * via the +@@+ snippet markers and programmatic adding with runtime data
     * in the Java code.
     *
     * - The annotated graph as http://www.graphviz.org/[GraphViz]-generated visualization:
     *
     * @@graph
     *
     * - A sample Cypher query:
     *
     * @@cypher
     *
     * - A sample text output snippet:
     *
     * @@output
     *
     * - a generated source link to the original GIThub source for this test:
     *
     * @@github
     *
     * - The full source for this example as a source snippet, highlighted as Java code:
     *
     * @@sampleDocumentation
     *
     * This is the end of this chapter.
     */
    @Test
    // signaling this to be a documentation test
    @Documented
    // the graph data setup as simple statements
    @Graph( "I know you" )
    // title is determined from the method name
    public void hello_world_Sample_Chapter()
    {
        // initialize the graph with the annotation data
        data.get();
        gen.get().addTestSourceSnippets( this.getClass(), "sampleDocumentation" );
        gen.get()
                .addGithubTestSourceLink( "github", this.getClass(),
                        "community/embedded-examples" );

        gen.get().addSnippet( "output",
                createOutputSnippet( "Hello graphy world!" ) );

        gen.get().addSnippet(
                "graph",
                createGraphVizWithNodeId( "Hello World Graph", graphdb(),
                        gen.get().getTitle() ) );
        // A cypher snippet referring to the generated graph in the start clause
        gen.get().addSnippet(
                "cypher",
                createCypherSnippet( "start n = node(" + data.get().get( "I" ).getId()
                                     + ") return n" ) );
    }
}
// END SNIPPET: _sampleDocumentation
]]></programlisting>
<simpara>This is the end of this chapter.</simpara>
</section>
<section id="_integrated_live_console">
<title>Integrated Live Console</title>
<simpara>An interactive console can be added and will show up in the online HTML version.
An optional title can be added, which will be used for the text of the button.</simpara>
<simpara>This is how to do it, using Cypher to define the data, with an empty line to separate it from the query:</simpara>
<programlisting language="plain" linenumbering="unnumbered"> .Interactive Example
 [console]
 ----
 CREATE (n {name: 'Neo4j'})

 MATCH (n)
 return n
 ----</programlisting>
<simpara>And this is the result:</simpara>
<formalpara role="cypherconsole"><title>Interactive Example</title><para><database>CREATE (n {name: 'Neo4j'})
</database><command>MATCH (n)
 return n</command></para></formalpara>
</section>
<section id="_toolchain">
<title>Toolchain</title>
<simpara>Useful links when configuring the docbook toolchain:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://www.docbook.org/tdg/en/html/docbook.html">http://www.docbook.org/tdg/en/html/docbook.html</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://www.sagehill.net/docbookxsl/index.html">http://www.sagehill.net/docbookxsl/index.html</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://docbook.sourceforge.net/release/xsl/1.76.1/doc/html/index.html">http://docbook.sourceforge.net/release/xsl/1.76.1/doc/html/index.html</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://docbook.sourceforge.net/release/xsl/1.76.1/doc/fo/index.html">http://docbook.sourceforge.net/release/xsl/1.76.1/doc/fo/index.html</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="community-translating">
<title>Translating the Neo4j Manual</title>
<simpara>To translate the Neo4j Manual, there&#8217;s a special project setup to use.
See the French translation project for an example:
<ulink url="https://github.com/neo4j/manual-french">https://github.com/neo4j/manual-french</ulink></simpara>
<simpara>The project contains:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>conf/</emphasis>&#8201;&#8212;&#8201;configuration for the project.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>docs/</emphasis>&#8201;&#8212;&#8201;translated files for content provided by Neo4j modules.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>po/</emphasis>&#8201;&#8212;&#8201;translation files and po4a configuration files.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>src/</emphasis>&#8201;&#8212;&#8201;translated files for content provided by the original manual.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>Makefile</emphasis>&#8201;&#8212;&#8201;a makefile with project-specific configuration.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>pom.xml</emphasis>&#8201;&#8212;&#8201;Maven build configuration.
</simpara>
</listitem>
</itemizedlist>
<section id="_prerequisites_2">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>
Apache Maven
</simpara>
</listitem>
<listitem>
<simpara>
GNU Make
</simpara>
</listitem>
<listitem>
<simpara>
Python
</simpara>
</listitem>
<listitem>
<simpara>
Perl
</simpara>
</listitem>
<listitem>
<simpara>
Perl module: <literal>Unicode::GCString</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>To check if you have the <literal>Unicode::GCString</literal> module installed, you can issue the following command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">perl -MUnicode::GCString -e ''</programlisting>
<simpara>If there&#8217;s no error, the module has been successfully installed on your system.</simpara>
<simpara>To install the module, you can use <ulink url="http://search.cpan.org/dist/App-cpanminus/lib/App/cpanminus.pm">cpanminus</ulink>.
For a convenient way to install it, see <ulink url="http://cpanmin.us">http://cpanmin.us</ulink>.
With cpanminus installed, execute this command:</simpara>
<programlisting language="bash" linenumbering="unnumbered">cpanm Unicode::GCString</programlisting>
<simpara>You will probably want to use a <emphasis>.po</emphasis> file editor as well, see <xref linkend="community-translating-tools"/>.</simpara>
</section>
<section id="_build_flow_and_file_layout">
<title>Build flow and file layout</title>
<simpara>The build is essentially a two-step process.
The first step generates or copies translated documents, while the second step is an ordinary AsciiDoc build using the output from the first step as sources.</simpara>
<simpara>Other than the <emphasis>src/</emphasis> and <emphasis>docs/</emphasis> diirectories of the project, the build generates files with the same layout in two more places:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis>target/original/(src|docs)/</emphasis>&#8201;&#8212;&#8201;the contents of the original manual. Note that&#8217;s it easier to look for content here than to dig into the original manual itself.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>target/(src|docs)/</emphasis>&#8201;&#8212;&#8201;the translated source to use for the AsciiDoc build.
</simpara>
</listitem>
</orderedlist>
<simpara>The translated documents in <emphasis>target/(src|docs)/</emphasis> are generated in three steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
It starts out as a copy of the original manual.
</simpara>
</listitem>
<listitem>
<simpara>
Next, any static translated files fromt the <emphasis>src/</emphasis> and <emphasis>docs/</emphasis> directories of the project are copied.
</simpara>
</listitem>
<listitem>
<simpara>
Finally, the translation files in the <emphasis>po/</emphasis> directory are used to generate translated documents.
</simpara>
</listitem>
</orderedlist>
<simpara>Files produced by later steps will overwrite existing files from earlier steps.</simpara>
</section>
<section id="_adding_a_chapter_to_a_translation_file">
<title>Adding a chapter to a translation file</title>
<simpara>The translation is split over multiple translation files, one per &#8220;part&#8221; of the manual.
It&#8217;s all about making the translation easier to manage and the tools to perform well.
The basic rule of thumb is that if some content is moved, it should likely still end up in the same translation file.
In that case, the tools will even detect this and the translation will be moved automatically.</simpara>
<simpara>To add a document to a translation file, do like this:</simpara>
<programlisting language="bash" linenumbering="unnumbered">make add DOCUMENT="src/introduction/the-neo4j-graphdb.asciidoc" PART="introduction"</programlisting>
<simpara>If the translation file does not already exist, it will be created.
The document will be added to the translation build configuration file as well.
(The configuration is in the corresponding <emphasis>.conf</emphasis> file in the <emphasis>po/</emphasis> directory.)</simpara>
<simpara>If there exists a translated copy of the document at the location the <literal>DOCUMENT</literal> parameter points to, the script will attempt to populate the translation file with translated paragraphs from that document.
Note that the structure of the document has to be a <emphasis>perfect match</emphasis>, or it will fail.
However, the error messages are helpful, so just fix and try again until it works!
Translation file and configuration are only changed when the first part succeeds.</simpara>
<note><simpara>Only documents that need to be translated should be added.
For example Cypher queries and query results should not be translated.
In general, documents residing in a directory named <emphasis>includes</emphasis> should not be translated.</simpara></note>
<simpara>Also note that AsciiDoc <literal>include::</literal> lines are normally not part of the translation at all, but handled automatically.
In case they need to be handled differently in a document, this has to be configured in the corresponding <emphasis>.conf</emphasis> file.
For example a normal document entry in such a file can look like this:</simpara>
<programlisting language="plain" linenumbering="unnumbered">[type: asciidoc] target/original/src/operations/index.asciidoc fr:target/src/operations/index.asciidoc</programlisting>
<simpara>To configure a single document not to handle <literal>include::</literal> lines automatically, add the following at the end of the line:</simpara>
<programlisting language="plain" linenumbering="unnumbered">opt: "-o definitions=target/tools/main/resources/conf/translate-includes"</programlisting>
</section>
<section id="_workflow">
<title>Workflow</title>
<simpara>First, use Maven to set up the environment and download the original manual and documentation tools:</simpara>
<programlisting language="bash" linenumbering="unnumbered">mvn clean package</programlisting>
<simpara>To refresh the original manual and the tools, use the maven command again.
For the sake of keeping in sync with the original manual, a daily run of this command is recommended.</simpara>
<simpara>Once things are set up, use <literal>make</literal> during work.</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>make</literal>&#8201;&#8212;&#8201;same as <literal>make preview</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>make add</literal>&#8201;&#8212;&#8201;add a document to a translation file.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>make preview</literal>&#8201;&#8212;&#8201;refresh and build preview of the manual.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>make refresh</literal>&#8201;&#8212;&#8201;refresh translation files from the original and generated translated documents.
</simpara>
</listitem>
</itemizedlist>
<simpara>The preview of the translated manual is found in the <emphasis>target/html/</emphasis> directory.</simpara>
<simpara>The actual work on translation is done by editing translation files.
Suggested tools for that are found below.</simpara>
</section>
<section id="community-translating-tools">
<title>Translation tools</title>
<simpara>There are different editors for <emphasis>.po</emphasis> files containing the translations
Below is a list of editors.</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://projects.gnome.org/gtranslator/">Gtranslator</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://userbase.kde.org/Lokalize">Lokalize</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://translate.sourceforge.net/wiki/virtaal/index">Virtaal</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://www.poedit.net/">Poedit</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="community-contributing-code">
<title>Contributing Code to Neo4j</title>
<section id="community-contributing-code-intro">
<title>Intro</title>
<simpara>The Neo4j community is a free software and open source community centered around software and components for the Neo4j Graph Database.
It is sponsored by <ulink url="http://neotechnology.com">Neo Technology</ulink>, which provides infrastructure (different kinds of hosting, documentation, etc) as well as people to manage it.
The Neo4j community is an open community, in so far as it welcomes any member that accepts the basic criterias of contribution and adheres to the community&#8217;s Code of Conduct.</simpara>
<simpara>Contribution can be in many forms (documentation, discussions, bug reports).
This document outlines the rules of governance for a contributor of code.</simpara>
</section>
<section id="community-contributing-code-governance-fundamentals">
<title>Governance fundamentals</title>
<simpara>In a nutshell, you need to be aware of the following fundamentals if you wish to contribute code:</simpara>
<itemizedlist>
<listitem>
<simpara>
All software published by the Neo4j project must have been contributed under the Neo4j Code <link linkend="cla">Contributor License Agreement</link>.
</simpara>
</listitem>
<listitem>
<simpara>
Neo4j is a free software and open source community.
  As a contributor, you are free to place your work under any license that has been approved by either the <ulink url="http://www.fsf.org/">Free Software Foundation</ulink> or the <ulink url="http://opensource.org">Open Source Initiative</ulink>.
  You still retain copyright, so in addition to that license you can of course release your work under any other license (for example a fully proprietary license), just not on the Neo4j infrastructure.
</simpara>
</listitem>
<listitem>
<simpara>
The Neo4j software is split into components.
  A Git repository holds either a single or multiple components.
</simpara>
</listitem>
<listitem>
<simpara>
The source code should follow the Neo4j <link linkend="community-contributing-code-code-style">Code Style</link> and &#8220;fit in&#8221; with the Neo4j infrastructure as much as is reasonable for the specific component.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="community-contributing-code-contributor-roles">
<title>Contributor roles</title>
<simpara>Every individual that contributes code does so in the context of a role (a single individual can have multiple roles).
The role defines their responsibilities and privileges:</simpara>
<itemizedlist>
<listitem>
<simpara>
A <emphasis>patch submitter</emphasis> is a person who wishes to contribute a patch to an existing component.
  See <link linkend="community-contributing-code-workflow">Workflow</link> below.
</simpara>
</listitem>
<listitem>
<simpara>
A <emphasis>committer</emphasis> can contribute code directly to one or more components.
</simpara>
</listitem>
<listitem>
<simpara>
A <emphasis>component maintainer</emphasis> is in charge of a specific component.
  They can:
</simpara>
<itemizedlist>
<listitem>
<simpara>
commit code in their component&#8217;s repository,
</simpara>
</listitem>
<listitem>
<simpara>
manage tickets for the repository,
</simpara>
</listitem>
<listitem>
<simpara>
grant push rights to the repository.
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
A <emphasis>Neo4j admin</emphasis> manages the Neo4j infrastructure.
  They:
</simpara>
<itemizedlist>
<listitem>
<simpara>
define new components and assign component maintainership,
</simpara>
</listitem>
<listitem>
<simpara>
drive, mentor and coach Neo4j component development.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section id="community-contributing-code-workflow">
<title>Contribution workflow</title>
<simpara>Code contributions to Neo4j are normally done via Github Pull Requests, following the workflow shown below.
Please check the <link linkend="community-contributing-code-pull-requests">pull request checklist</link> before sending off a pull request as well.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Fork the appropriate Github repository.
</simpara>
</listitem>
<listitem>
<simpara>
Create a new branch for your specific feature or fix.
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="community-contributing-code-tests">Write unit tests for your code</link>.
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="community-contributing-code-code-style">Write code</link>.
</simpara>
</listitem>
<listitem>
<simpara>
Write appropriate Javadocs and <link linkend="community-docs">Manual entries</link>.
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="community-contributing-code-commit-messages">Commit changes</link>.
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="community-contributing-code-pull-requests">Send pull request</link>.
</simpara>
</listitem>
</orderedlist>
</section>
<section id="community-contributing-code-pull-requests">
<title>Pull request checklist</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<link linkend="community-contributing-code-intro-the-fast-track">Sign the CLA</link>.
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="community-contributing-code-no-merging">Ensure that you have not added any merge commits</link>.
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="community-contributing-code-single-commit">Squash all your changes into a single commit</link>.
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="community-contributing-code-no-merging">Rebase against the latest master</link>.
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="community-contributing-code-tests">Run all relevant tests</link>.
</simpara>
</listitem>
<listitem>
<simpara>
Send the request!
</simpara>
</listitem>
</orderedlist>
</section>
<section id="community-contributing-code-tests">
<title>Unit Tests</title>
<simpara>You have a much higher chance of getting your changes accepted if you supply us with small, readable unit tests covering the code you&#8217;ve written.
Also, make sure your code doesn&#8217;t break any existing tests.
<emphasis>Note that there may be downstream components that need to be tested as well,</emphasis> depending on what you change.</simpara>
<simpara>To run tests, use Maven rather than your IDE to ensure others can replicate your test run.
The command for running Neo4j tests in any given component is <literal>mvn clean validate</literal>.</simpara>
</section>
<section id="community-contributing-code-code-style">
<title>Code Style</title>
<simpara>The Neo4j Code style is maintained on GitHub in <ulink url="https://github.com/neo4j/neo4j.github.com/tree/master/code-style">styles for the different IDEs</ulink>.</simpara>
</section>
<section id="community-contributing-code-commit-messages">
<title>Commit messages</title>
<simpara>Please take some care in providing good commit messages.
Use your common sense. In particular:</simpara>
<itemizedlist>
<listitem>
<simpara>
Use <emphasis>english</emphasis>. This includes proper punctuation and correct spelling.
  Commit messages are supposed to convey some information at a glance&#8201;&#8212;&#8201;they&#8217;re not a chat room.
</simpara>
</listitem>
<listitem>
<simpara>
Remember that a commit is a <emphasis>changeset</emphasis>, which describes a cohesive set of changes across potentially many files.
  Try to group every commit as a logical change.
  Explain what it changes.
  If you have to redo work, you might want to clean up your commit log before doing a pull request.
</simpara>
</listitem>
<listitem>
<simpara>
If you fix a bug or an issue that&#8217;s related to a ticket, then refer to the ticket in the message.
  For example, <emphasis>`&#8216;Added this and then changed that. This fixes #14.&#8217;'</emphasis>
  Just mentioning #xxx in the commit will connect  it to the GitHub issue with that number, see <ulink url="https://github.com/blog/831-issues-2-0-the-next-generation">GitHub issues</ulink>.
  Any of these synonyms will also work:
</simpara>
<itemizedlist>
<listitem>
<simpara>
fixes #xxx
</simpara>
</listitem>
<listitem>
<simpara>
fixed #xxx
</simpara>
</listitem>
<listitem>
<simpara>
fix #xxx
</simpara>
</listitem>
<listitem>
<simpara>
closes #xxx
</simpara>
</listitem>
<listitem>
<simpara>
close #xxx
</simpara>
</listitem>
<listitem>
<simpara>
closed #xxx.
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
Remember to convey <emphasis>intent</emphasis>.
  Don&#8217;t be too brief but don&#8217;t provide too much detail, either.
  That&#8217;s what <literal>git diff</literal> is for.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="community-contributing-code-intro-the-fast-track">
<title>Signing the CLA</title>
<simpara>One crucial aspect of contributing is the <link linkend="cla">Contributor License Agreement</link>.
In short: make sure to sign the CLA, or the Neo4j project won&#8217;t be able to accept your contribution.</simpara>
</section>
<section id="community-contributing-code-no-merging">
<title>Don&#8217;t merge, use rebase instead!</title>
<simpara>Because we would like each contribution to be contained in a single commit, merge commits are not allowed inside a pull request.
Merges are messy, and should only be done when necessary, eg. when merging a branch into master to remember where the code came from.</simpara>
<simpara>If you want to update your development branch to incorporate the latest changes from master, use git rebase.
For details on how to use rebase, see Git manual on rebase: <ulink url="http://git-scm.com/book/en/Git-Branching-Rebasing">the Git Manual</ulink>.</simpara>
</section>
<section id="community-contributing-code-single-commit">
<title>Single commit</title>
<simpara>If you have multiple commits, you should squash them into a single one for the pull request, unless there is some extraordinary reason not to.
Keeping your changes in a single commit makes the commit history easier to read, it also makes it easy to revert and move features around.</simpara>
<simpara>One way to do this is to, while standing on your local branch with your changes, create a new branch and then interactively rebase your commits into a single one.</simpara>
<formalpara><title>Interactive rebasing with Git</title><para>
<programlisting language="shell" linenumbering="unnumbered"># On branch mychanges
git checkout -b mychanges-clean

# Assuming you have 4 commits, rebase the last four commits interactively:
git rebase -i HEAD~4

# In the dialog git gives you, keep your first commit, and squash all others into it.
# Then reword the commit description to accurately depict what your commit does.
# If applicable, include any issue numbers like so: #760</programlisting>
</para></formalpara>
<simpara>For more details, see the git manual: <ulink url="http://git-scm.com/book/en/Git-Tools-Rewriting-History#Changing-Multiple-Commit-Messages">http://git-scm.com/book/en/Git-Tools-Rewriting-History#Changing-Multiple-Commit-Messages</ulink></simpara>
<simpara>If you are asked to modify parts of your code, work in your original branch (the one with multiple commits), and follow the above process to create a fixed single commit.</simpara>
</section>
</section>
<section id="contributors">
<title>Contributors</title>
<simpara>As an Open Source Project, the Neo4j User community extends its warmest thanks to all the contributors who have signed the <xref linkend="cla"/> to date and are contributing to this collective effort.</simpara>
<informaltable
frame="none"
rowsep="1" colsep="1"
>
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="113*"/>
<colspec colname="col_2" colwidth="227*"/>
<thead>
<row>
<entry align="left" valign="top">name </entry>
<entry align="left" valign="top"> GIThub ID</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Johan Svensson</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/johan-neo">johan-neo</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Emil Eifrem</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/emileifrem">emileifrem</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Peter Neubauer</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/peterneubauer">peterneubauer</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Mattias Persson</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/tinwelint">tinwelint</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Tobias Lindaaker</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/thobe">thobe</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Anders Nawroth</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/nawroth">nawroth</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Andrés Taylor</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/systay">systay</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jacob Hansson</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/jakewins">jakewins</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jim Webber</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/jimwebber">jimwebber</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Josh Adell</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/jadell">jadell</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Andreas Kollegger</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/akollegger">akollegger</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Chris Gioran</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/digitalstain">digitalstain</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Thomas Baum</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/tbaum">tbaum</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Alistair Jones</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/apcj">apcj</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Michael Hunger</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/jexp">jexp</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jesper Nilsson</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/jespernilsson">jespernilsson</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Tom Sulston</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/tomsulston">tomsulston</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>David Montag</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/dmontag">dmontag</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Marlon Richert</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/marlonrichert">marlonrichert</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Hugo Josefson</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/hugojosefson">hugojosefson</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Vivek Prahlad</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/vivekprahlad">vivekprahlad</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Adriano Almeida</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/adrianoalmeida7">adrianoalmeida7</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Benjamin Gehrels</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/BGehrels">BGehrels</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Christopher Schmidt</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/FaKod">FaKod</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Pascal Rehfeldt</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/prehfeldt">prehfeldt</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Björn Söderqvist</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/cybear">cybear</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Abdul Azeez Shaik</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/abdulazeezsk">abdulazeezsk</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>James Thornton</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/espeed">espeed</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Radhakrishna Kalyan</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/nrkkalyan">nrkkalyan</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Michel van den Berg</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/promontis">promontis</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Brandon McCauslin</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/bm3780">bm3780</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Hendy Irawan</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/ceefour">ceefour</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Luanne Misquitta</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/luanne">luanne</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jim Radford</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/radford">radford</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Axel Morgner</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/amorgner">amorgner</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Taylor Buley</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/editor">editor</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Alex Smirnov</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/alexsmirnov">alexsmirnov</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Johannes Mockenhaupt</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/jotomo">jotomo</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Pablo Pareja Tobes</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/pablopareja">pablopareja</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Björn Granvik</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/bjorngranvik">bjorngranvik</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Julian Simpson</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/simpsonjulian">simpsonjulian</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Pablo Pareja Tobes</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/pablopareja">pablopareja</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rickard Öberg</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/rickardoberg">rickardoberg</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Stefan Armbruster</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/sarmbruster">sarmbruster</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Stephan Hagemann</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/shageman">shageman</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Linan Wang</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/wangii">wangii</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ian Robinson</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/iansrobinson">iansrobinson</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Marko Rodriguez</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/okram">okram</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Saikat Kanjilal</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/skanjila">skanjila</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Craig Taverner</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/craigtaverner">craigtaverner</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>David Winslow</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/dwins">dwins</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Patrick Fitzgerald</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/paddydub">paddydub</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Stefan Berder</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/hrbonz">hrbonz</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Michael Kanner</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/SepiaGroup">SepiaGroup</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Lin Zhemin</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/miaoski">miaoski</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Christophe Willemsen</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/kwattro">kwattro</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Tony Liu</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/kooyeed">kooyeed</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Michael Klishin</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/michaelklishin">michaelklishin</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Wes Freeman</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/wfreeman">wfreeman</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Chris Leishman</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/cleishm">cleishm</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Brian Levine</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/blevine">blevine</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ben Day</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/benday280412">benday280412</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Davide Savazzi</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/svzdvd">svzdvd</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Nigel Small</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/nigelsmall">nigelsmall</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Lasse Westh-Nielsen</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/lassewesth">lassewesth</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Wujek Srujek</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/wujek-srujek">wujek-srujek</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Alexander Yastrebov</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/AlexanderYastrebov">AlexanderYastrebov</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Mike Bryant</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/mikesname">mikesname</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Klaus Grossmann</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/iKlaus">iKlaus</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Pablo Lalloni</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/plalloni">plalloni</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Stefan Plantikow</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/boggle">boggle</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Trenton Strong</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/trentonstrong">trentonstrong</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Maciej Mazur</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/mamciek">mamciek</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>German Borbolla</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/germanborbolla">germanborbolla</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Laurent Raufaste</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/lra">lra</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Thomas Häfele</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/Perfect-Pixel">Perfect-Pixel</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Sevki Hasirci</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/Sevki">Sevki</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Max De Marzi</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/maxdemarzi">maxdemarzi</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Pieter-Jan Van Aeken</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/PieterJanVanAeken">PieterJanVanAeken</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Shane Gibbs</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/sgibbs-kellermed">sgibbs-kellermed</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Yin Wang</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/yinwang0">yinwang0</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Volker Lanting</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/VolkerL">VolkerL</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Mark Needham</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/mneedham">mneedham</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Chris Vest</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/chrisvest">chrisvest</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ben Butler-Cole</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/benbc">benbc</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Tatham Oddie</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="https://github.com/tathamoddie">tathamoddie</ulink></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</chapter>
</part>
<part id="advanced-usage">
<title>Advanced Usage</title>
<partintro>
<simpara>This part contains information on advanced usage of Neo4j.
Among the topics covered are embedding Neo4j in your own software and writing plugins for the Neo4j Server.</simpara>
</partintro>
<chapter id="server-extending">
<title>Extending the Neo4j Server</title>
<simpara>The Neo4j Server can be extended by either plugins or unmanaged extensions.</simpara>
<section id="server-plugins">
<title>Server Plugins</title>
<sidebar>
<title>Quick info</title>
<itemizedlist>
<listitem>
<simpara>
The server&#8217;s functionality can be extended by adding plugins.
</simpara>
</listitem>
<listitem>
<simpara>
Plugins are user-specified code which extend the capabilities of the database, nodes, or relationships.
</simpara>
</listitem>
<listitem>
<simpara>
The neo4j server will then advertise the plugin functionality within representations as clients interact via HTTP.
</simpara>
</listitem>
</itemizedlist>
</sidebar>
<simpara>Plugins provide an easy way to extend the Neo4j REST API with new functionality, without the need to
invent your own API.
Think of plugins as server-side scripts that can add functions for retrieving and manipulating nodes, relationships, paths, properties or indices.</simpara>
<tip><simpara>If you want to have full control over your API, and are willing to put in the effort, and understand the risks, then Neo4j server also provides hooks for <link linkend="server-unmanaged-extensions">unmanaged extensions</link> based on JAX-RS.</simpara></tip>
<simpara>The needed classes reside in the <ulink url="http://search.maven.org/#search|gav|1|g%3A%22org.neo4j%22%20AND%20a%3A%22server-api%22">org.neo4j:server-api</ulink> jar file.
See the linked page for downloads and instructions on how to include it using dependency management.
For Maven projects, add the Server API dependencies in your <literal>pom.xml</literal> like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.neo4j&lt;/groupId&gt;
  &lt;artifactId&gt;server-api&lt;/artifactId&gt;
  &lt;version&gt;${neo4j-version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara><emphasis>Where ${neo4j-version} is the intended version.</emphasis></simpara>
<simpara>To create a plugin, your code must inherit from the <ulink url="http://components.neo4j.org/server-api/2.0-SNAPSHOT/apidocs/org/neo4j/server/plugins/ServerPlugin.html">ServerPlugin</ulink> class.
Your plugin should also:</simpara>
<itemizedlist>
<listitem>
<simpara>
ensure that it can produce an (Iterable of) <literal>Node</literal>, <literal>Relationship</literal> or <literal>Path</literal>, any Java primitive or <literal>String</literal> or an instance of a <literal>org.neo4j.server.rest.repr.Representation</literal>
</simpara>
</listitem>
<listitem>
<simpara>
specify parameters,
</simpara>
</listitem>
<listitem>
<simpara>
specify a point of extension and of course
</simpara>
</listitem>
<listitem>
<simpara>
contain the application logic.
</simpara>
</listitem>
<listitem>
<simpara>
make sure that the discovery point type in the <literal>@PluginTarget</literal> and the <literal>@Source</literal> parameter are of the same type.
</simpara>
</listitem>
</itemizedlist>
<simpara>An example of a plugin which augments the database (as opposed to nodes or relationships) follows:</simpara>
<formalpara><title>Get all nodes or relationships plugin</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[@Description( "An extension to the Neo4j Server for getting all nodes or relationships" )
public class GetAll extends ServerPlugin
{
    @Name( "get_all_nodes" )
    @Description( "Get all nodes from the Neo4j graph database" )
    @PluginTarget( GraphDatabaseService.class )
    public Iterable<Node> getAllNodes( @Source GraphDatabaseService graphDb )
    {
        ArrayList<Node> nodes = new ArrayList<>();
        try (Transaction tx = graphDb.beginTx())
        {
            for ( Node node : GlobalGraphOperations.at( graphDb ).getAllNodes() )
            {
                nodes.add( node );
            }
            tx.success();
        }
        return nodes;
    }

    @Description( "Get all relationships from the Neo4j graph database" )
    @PluginTarget( GraphDatabaseService.class )
    public Iterable<Relationship> getAllRelationships( @Source GraphDatabaseService graphDb )
    {
        List<Relationship> rels = new ArrayList<>();
        try (Transaction tx = graphDb.beginTx())
        {
            for ( Relationship rel : GlobalGraphOperations.at( graphDb ).getAllRelationships() )
            {
                rels.add( rel );
            }
            tx.success();
        }
        return rels;
    }
}
]]></programlisting>
</para></formalpara>
<simpara>The full source code is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/server-examples/src/main/java/org/neo4j/examples/server/plugins/GetAll.java">GetAll.java</ulink></simpara>
<formalpara><title>Find the shortest path between two nodes plugin</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[public class ShortestPath extends ServerPlugin
{
    @Description( "Find the shortest path between two nodes." )
    @PluginTarget( Node.class )
    public Iterable<Path> shortestPath(
            @Source Node source,
            @Description( "The node to find the shortest path to." )
                @Parameter( name = "target" ) Node target,
            @Description( "The relationship types to follow when searching for the shortest path(s). " +
                    "Order is insignificant, if omitted all types are followed." )
                @Parameter( name = "types", optional = true ) String[] types,
            @Description( "The maximum path length to search for, default value (if omitted) is 4." )
                @Parameter( name = "depth", optional = true ) Integer depth )
    {
        PathExpander<?> expander;
        List<Path> paths = new ArrayList<>();
        if ( types == null )
        {
            expander = PathExpanders.allTypesAndDirections();
        }
        else
        {
            PathExpanderBuilder expanderBuilder = PathExpanderBuilder.empty();
            for ( int i = 0; i < types.length; i++ )
            {
                expanderBuilder = expanderBuilder.add( DynamicRelationshipType.withName( types[i] ) );
            }
            expander = expanderBuilder.build();
        }
        try (Transaction tx = source.getGraphDatabase().beginTx())
        {
            PathFinder<Path> shortestPath = GraphAlgoFactory.shortestPath( expander,
                    depth == null ? 4 : depth.intValue() );
            for ( Path path : shortestPath.findAllPaths( source, target ) )
            {
                paths.add( path );
            }
            tx.success();
        }
        return paths;
    }
}
]]></programlisting>
</para></formalpara>
<simpara>The full source code is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/server-examples/src/main/java/org/neo4j/examples/server/plugins/ShortestPath.java">ShortestPath.java</ulink></simpara>
<simpara>To deploy the code, simply compile it into a .jar file and place it onto the server classpath (which by
convention is the plugins directory under the Neo4j server home directory).</simpara>
<tip><simpara>Make sure the directories listings are retained in the jarfile by either building with default Maven, or with <literal>jar -cvf myext.jar *</literal>, making sure
to jar directories instead of specifying single files.</simpara></tip>
<simpara>The <emphasis>.jar</emphasis> file must include the file <emphasis>META-INF/services/org.neo4j.server.plugins.ServerPlugin</emphasis> with the fully qualified name of the implementation class.
This is an example with multiple entries, each on a separate line:</simpara>
<programlisting language="plain" linenumbering="unnumbered">org.neo4j.examples.server.plugins.DepthTwo
org.neo4j.examples.server.plugins.GetAll
org.neo4j.examples.server.plugins.ShortestPath</programlisting>
<simpara>The code above makes an extension visible in the database representation (via the <literal>@PluginTarget</literal> annotation)
whenever it is served from the Neo4j Server.
Simply changing the <literal>@PluginTarget</literal> parameter to <literal>Node.class</literal> or <literal>Relationship.class</literal> allows us to target those parts of the data model should we wish.
The functionality extensions provided by the plugin are automatically advertised in representations on the wire.
For example, clients can discover the extension implemented by the above plugin easily by examining the representations
they receive as responses from the server, e.g. by performing a <literal>GET</literal> on the default database URI:</simpara>
<programlisting language="shell" linenumbering="unnumbered">curl -v http://localhost:7474/db/data/</programlisting>
<simpara>The response to the <literal>GET</literal> request will contain (by default) a JSON container that itself contains a container
called "extensions" where the available plugins are listed.
In the following case, we only have the <literal>GetAll</literal> plugin registered with the server, so only its extension functionality is available.
Extension names will be automatically assigned, based on method names, if not specifically specified using the <literal>@Name</literal> annotation.</simpara>
<programlisting language="javascript" linenumbering="unnumbered">{
"extensions-info" : "http://localhost:7474/db/data/ext",
"node" : "http://localhost:7474/db/data/node",
"node_index" : "http://localhost:7474/db/data/index/node",
"relationship_index" : "http://localhost:7474/db/data/index/relationship",
"reference_node" : "http://localhost:7474/db/data/node/0",
"extensions_info" : "http://localhost:7474/db/data/ext",
"extensions" : {
  "GetAll" : {
    "get_all_nodes" : "http://localhost:7474/db/data/ext/GetAll/graphdb/get_all_nodes",
    "get_all_relationships" : "http://localhost:7474/db/data/ext/GetAll/graphdb/getAllRelationships"
  }
}</programlisting>
<simpara>Performing a <literal>GET</literal> on one of the two extension URIs gives back the meta information about the service:</simpara>
<programlisting language="shell" linenumbering="unnumbered">curl http://localhost:7474/db/data/ext/GetAll/graphdb/get_all_nodes</programlisting>
<programlisting language="javascript" linenumbering="unnumbered">{
  "extends" : "graphdb",
  "description" : "Get all nodes from the Neo4j graph database",
  "name" : "get_all_nodes",
  "parameters" : [ ]
}</programlisting>
<simpara>To use it, just <literal>POST</literal> to this URL, with parameters as specified in the description and encoded as JSON data content.
F.ex for calling the <literal>shortest path</literal> extension (URI gotten from a <literal>GET</literal> to <ulink url="http://localhost:7474/db/data/node/123">http://localhost:7474/db/data/node/123</ulink>):</simpara>
<programlisting language="bash" linenumbering="unnumbered">curl -X POST http://localhost:7474/db/data/ext/GetAll/node/123/shortestPath \
  -H "Content-Type: application/json" \
  -d '{"target":"http://localhost:7474/db/data/node/456&amp;depth=5"}'</programlisting>
<simpara>If everything is OK a response code <literal>200</literal> and a list of zero or more items will be returned.
If nothing is returned (null returned from extension) an empty result and response code <literal>204</literal> will be returned.
If the extension throws an exception response code <literal>500</literal> and a detailed error message is returned.</simpara>
<simpara>Extensions that do any kind of database operation will have to manage their own transactions, i.e. transactions aren&#8217;t managed automatically.
Note that the results of traversals or execution of graph algorithms should be exhausted inside the transaction before returning the result.</simpara>
<simpara>Through this model, any plugin can naturally fit into the general hypermedia scheme that Neo4j espouses&#8201;&#8212;&#8201;meaning that
clients can still take advantage of abstractions like  Nodes, Relationships and Paths with a straightforward upgrade
path as servers are enriched with plugins (old clients don&#8217;t break).</simpara>
</section>
<section id="server-unmanaged-extensions">
<title>Unmanaged Extensions</title>
<sidebar>
<title>Quick info</title>
<itemizedlist>
<listitem>
<simpara>
Danger: Men at Work!
  The unmanaged extensions are a way of deploying arbitrary JAX-RS code into the Neo4j server.
</simpara>
</listitem>
<listitem>
<simpara>
The unmanaged extensions are exactly that: unmanaged.
  If you drop poorly tested code into the server, it&#8217;s highly likely you&#8217;ll degrade its performance, so be careful.
</simpara>
</listitem>
</itemizedlist>
</sidebar>
<simpara>Some projects want extremely fine control over their server-side code.
For this we&#8217;ve introduced an unmanaged extension API.</simpara>
<warning><simpara>This is a sharp tool, allowing users to deploy arbitrary <ulink url="http://en.wikipedia.org/wiki/JAX-RS">JAX-RS</ulink> classes to the server and so you should be careful when thinking about using this.
In particular you should understand that it&#8217;s easy to consume lots of heap space on the server and hinder performance if you&#8217;re not careful.</simpara></warning>
<simpara>Still, if you understand the disclaimer, then you load your JAX-RS classes into the Neo4j server simply by adding a @Context annotation to your code, compiling against the JAX-RS jar and any Neo4j jars you&#8217;re making use of.
Then add your classes to the runtime classpath (just drop it in the lib directory of the Neo4j server).
In return you get access to the hosted environment of the Neo4j server like logging through the <literal>org.neo4j.server.logging.Logger</literal>.</simpara>
<simpara>In your code, you get access to the underlying <literal>GraphDatabaseService</literal> through the <literal>@Context</literal> annotation like so:</simpara>
<programlisting language="java" linenumbering="unnumbered">public MyCoolService( @Context GraphDatabaseService database )
{
  // Have fun here, but be safe!
}</programlisting>
<simpara>Remember, the unmanaged API is a very sharp tool.
It&#8217;s all to easy to compromise the server by deploying code this way, so think first and see if you can&#8217;t use the managed extensions in preference.
However, a number of context parameters can be automatically provided for you, like the reference to the database.</simpara>
<simpara>In order to specify the mount point of your extension, a full class looks like this:</simpara>
<formalpara><title>Unmanaged extension example</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[@Path( "/helloworld" )
public class HelloWorldResource
{
    private final GraphDatabaseService database;

    public HelloWorldResource( @Context GraphDatabaseService database )
    {
        this.database = database;
    }

    @GET
    @Produces( MediaType.TEXT_PLAIN )
    @Path( "/{nodeId}" )
    public Response hello( @PathParam( "nodeId" ) long nodeId )
    {
        // Do stuff with the database
        return Response.status( Status.OK ).entity(
                ("Hello World, nodeId=" + nodeId).getBytes( Charset.forName("UTF-8") ) ).build();
    }
}
]]></programlisting>
</para></formalpara>
<simpara>The full source code is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/server-examples/src/main/java/org/neo4j/examples/server/unmanaged/HelloWorldResource.java">HelloWorldResource.java</ulink></simpara>
<simpara>Build this code, and place the resulting jar file (and any custom dependencies) into the <literal>$NEO4J_SERVER_HOME/plugins</literal> directory, and include this class in the <literal>neo4j-server.properties</literal> file, like so:</simpara>
<tip><simpara>Make sure the directories listings are retained in the jarfile by either building with default Maven, or with <literal>jar -cvf myext.jar *</literal>, making sure
to jar directories instead of specifying single files.</simpara></tip>
<tip><simpara>You will need to include a dependency to JAX-RS API on your classpath when you compile. In Maven this would be achieved by adding the following to the pom file:</simpara></tip>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
    &lt;groupId&gt;javax.ws.rs&lt;/groupId&gt;
    &lt;artifactId&gt;javax.ws.rs-api&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</programlisting>
<programlisting language="plain" linenumbering="unnumbered">#Comma separated list of JAXRS packages containing JAXRS Resource, one package name for each mountpoint.
org.neo4j.server.thirdparty_jaxrs_classes=org.neo4j.examples.server.unmanaged=/examples/unmanaged</programlisting>
<simpara>Which binds the hello method to respond to <literal>GET</literal> requests at the URI: <literal>http://{neo4j_server}:{neo4j_port}/examples/unmanaged/helloworld/{nodeId}</literal></simpara>
<programlisting language="bash" linenumbering="unnumbered">curl http://localhost:7474/examples/unmanaged/helloworld/123</programlisting>
<simpara>which results in</simpara>
<programlisting language="plain" linenumbering="unnumbered">Hello World, nodeId=123</programlisting>
</section>
<section id="plugins-extensions-desktop">
<title>Installing Plugins and Extensions in Neo4j Desktop</title>
<simpara>Neo4j Desktop can also be extended with server plugins and extensions. Neo4j
Desktop will add all jars in <emphasis>%ProgramFiles%\Neo4j Community\plugins</emphasis> to the
classpath, but please note that nested directories for plugins are currently
not supported.</simpara>
<simpara>Otherwise server plugins and extensions are subject to the same rules as usual.
Please note when configuring server extensions that <emphasis>neo4j-server.properties</emphasis>
for Neo4j Desktop lives in <emphasis>%APPDATA%\Neo4j Community</emphasis>.</simpara>
</section>
</chapter>
<chapter id="tutorials-java-embedded">
<title>Using Neo4j embedded in Java applications</title>
<simpara>It&#8217;s easy to use Neo4j embedded in Java applications.
In this chapter you will find everything needed&#8201;&#8212;&#8201;from setting up the environment to doing something useful with your data.</simpara>
<section id="tutorials-java-embedded-setup">
<title>Include Neo4j in your project</title>
<simpara>After selecting the appropriate <link linkend="editions">edition</link> for your platform, embed Neo4j in your Java application by including the Neo4j library jars in your build.
The following sections will show how to do this by either altering the build path directly or by using dependency management.</simpara>
<section id="_add_neo4j_to_the_build_path">
<title>Add Neo4j to the build path</title>
<simpara>Get the Neo4j libraries from one of these sources:</simpara>
<itemizedlist>
<listitem>
<simpara>
Extract a Neo4j <ulink url="http://www.neo4j.org/download">download</ulink> zip/tarball, and use the <emphasis>jar</emphasis> files found in the <emphasis>lib/</emphasis> directory.
</simpara>
</listitem>
<listitem>
<simpara>
Use the <emphasis>jar</emphasis> files available from <ulink url="http://search.maven.org/#search|ga|1|g%3A%22org.neo4j%22">Maven Central Repository</ulink>
</simpara>
</listitem>
</itemizedlist>
<simpara>Add the jar files to your project:</simpara>
<variablelist>
<varlistentry>
<term>
JDK tools
</term>
<listitem>
<simpara>
 Append to <literal>-classpath</literal>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Eclipse
</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>
Right-click on the project and then go <emphasis>Build Path &#8594; Configure Build Path.</emphasis>
   In the dialog, choose <emphasis>Add External JARs</emphasis>, browse to the Neo4j <emphasis>lib/</emphasis> directory and select all of the jar files.
</simpara>
</listitem>
<listitem>
<simpara>
Another option is to use <ulink url="http://help.eclipse.org/indigo/index.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/buildpath/ref-preferences-user-libraries.htm">User Libraries</ulink>.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
IntelliJ IDEA
</term>
<listitem>
<simpara>
 See <ulink url="http://www.jetbrains.com/idea/webhelp/configuring-project-and-global-libraries.html">Libraries, Global Libraries, and the Configure Library dialog</ulink>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
NetBeans
</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>
Right-click on the <emphasis>Libraries</emphasis> node of the project, choose <emphasis>Add JAR/Folder</emphasis>, browse to the Neo4j <emphasis>lib/</emphasis> directory and select all of the jar files.
</simpara>
</listitem>
<listitem>
<simpara>
You can also handle libraries from the project node, see <ulink url="http://netbeans.org/kb/docs/java/project-setup.html#projects-classpath">Managing a Project&#8217;s Classpath</ulink>.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="editions">
<title>Editions</title>
<simpara>The following table outlines the available editions and their names for use with dependency management tools.</simpara>
<tip><simpara>Follow the links in the table for details on dependency configuration with Apache Maven, Apache Buildr, Apache Ivy, Groovy Grape, Grails, Scala SBT!</simpara></tip>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>Neo4j editions</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Edition     </entry>
<entry align="left" valign="top">Dependency      </entry>
<entry align="left" valign="top">Description  </entry>
<entry align="left" valign="top">License</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Community</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="http://search.maven.org/#search|gav|1|g%3A%22org.neo4j%22%20AND%20a%3A%22neo4j%22">org.neo4j:neo4j</ulink></simpara></entry>
<entry align="left" valign="top"><simpara>a high performance, fully ACID transactional graph database</simpara></entry>
<entry align="left" valign="top"><simpara>GPLv3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Enterprise</simpara></entry>
<entry align="left" valign="top"><simpara><ulink url="http://search.maven.org/#search|gav|1|g%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-enterprise%22">org.neo4j:neo4j-enterprise</ulink></simpara></entry>
<entry align="left" valign="top"><simpara>adding advanced monitoring, online backup and High Availability clustering</simpara></entry>
<entry align="left" valign="top"><simpara>AGPLv3</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note><simpara>The listed dependencies do not contain the implementation, but pulls it in transitively.</simpara></note>
<simpara>For more information regarding licensing, see the <ulink url="http://www.neo4j.org/learn/licensing">Licensing Guide</ulink>.</simpara>
</section>
<section id="_add_neo4j_as_a_dependency">
<title>Add Neo4j as a dependency</title>
<simpara>You can either go with the top-level artifact from the table above or include the individual components directly.
The examples included here use the top-level artifact approach.</simpara>
<section id="_maven">
<title>Maven</title>
<formalpara><title>Maven dependency</title><para>
<programlisting language="xml" linenumbering="unnumbered">&lt;project&gt;
...
 &lt;dependencies&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;org.neo4j&lt;/groupId&gt;
   &lt;artifactId&gt;neo4j&lt;/artifactId&gt;
   &lt;version&gt;2.0-SNAPSHOT&lt;/version&gt;
  &lt;/dependency&gt;
  ...
 &lt;/dependencies&gt;
...
&lt;/project&gt;</programlisting>
</para></formalpara>
<simpara><emphasis>Where the <literal>artifactId</literal> is found in the editions table.</emphasis></simpara>
</section>
<section id="_eclipse_and_maven">
<title>Eclipse and Maven</title>
<simpara>For development in <ulink url="http://www.eclipse.org">Eclipse</ulink>, it is recommended to install the <ulink url="http://www.eclipse.org/m2e/">m2e plugin</ulink> and let Maven manage the project build classpath instead, see above.
This also adds the possibility to build your project both via the command line with Maven and have a working Eclipse setup for development.</simpara>
</section>
<section id="_ivy">
<title>Ivy</title>
<simpara>Make sure to resolve dependencies from Maven Central, for example using this configuration in your <emphasis>ivysettings.xml</emphasis> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;ivysettings&gt;
  &lt;settings defaultResolver="main"/&gt;
  &lt;resolvers&gt;
    &lt;chain name="main"&gt;
      &lt;filesystem name="local"&gt;
        &lt;artifact pattern="${ivy.settings.dir}/repository/[artifact]-[revision].[ext]" /&gt;
      &lt;/filesystem&gt;
      &lt;ibiblio name="maven_central" root="http://repo1.maven.org/maven2/" m2compatible="true"/&gt;
    &lt;/chain&gt;
  &lt;/resolvers&gt;
&lt;/ivysettings&gt;</programlisting>
<simpara>With that in place you can add Neo4j to the mix by having something along these lines to your <emphasis>ivy.xml</emphasis> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">..
&lt;dependencies&gt;
  ..
  &lt;dependency org="org.neo4j" name="neo4j" rev="2.0-SNAPSHOT"/&gt;
  ..
&lt;/dependencies&gt;
..</programlisting>
<simpara><emphasis>Where the <literal>name</literal> is found in the editions table above</emphasis></simpara>
</section>
<section id="_gradle">
<title>Gradle</title>
<simpara>The example below shows an example gradle build script for including the Neo4j libraries.</simpara>
<programlisting language="groovy" linenumbering="unnumbered">def neo4jVersion = "2.0-SNAPSHOT"
apply plugin: 'java'
repositories {
   mavenCentral()
}
dependencies {
   compile "org.neo4j:neo4j:${neo4jVersion}"
}</programlisting>
<simpara><emphasis>Where the coordinates (<literal>org.neo4j:neo4j</literal> in the example) are found in the editions table above.</emphasis></simpara>
</section>
</section>
<section id="tutorials-java-embedded-setup-startstop">
<title>Starting and stopping</title>
<simpara>To create a new database or ópen an existing one you instantiate an <literal><ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/kernel/EmbeddedGraphDatabase.html">EmbeddedGraphDatabase</ulink></literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );
registerShutdownHook( graphDb );
]]></programlisting>
<note><simpara>The <literal>EmbeddedGraphDatabase</literal> instance can be shared among multiple threads.
Note however that you can&#8217;t create multiple instances pointing to the same database.</simpara></note>
<simpara>To stop the database, call the <literal>shutdown()</literal> method:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[graphDb.shutdown();
]]></programlisting>
<simpara>To make sure Neo4j is shut down properly you can add a shutdown hook:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[private static void registerShutdownHook( final GraphDatabaseService graphDb )
{
    // Registers a shutdown hook for the Neo4j instance so that it
    // shuts down nicely when the VM exits (even if you "Ctrl-C" the
    // running application).
    Runtime.getRuntime().addShutdownHook( new Thread()
    {
        @Override
        public void run()
        {
            graphDb.shutdown();
        }
    } );
}
]]></programlisting>
<section id="tutorials-java-embedded-setup-config">
<title>Starting an embedded database with configuration settings</title>
<simpara>To start Neo4j with configuration settings, a Neo4j properties file can be loaded like this:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[GraphDatabaseService graphDb = new GraphDatabaseFactory()
    .newEmbeddedDatabaseBuilder( storeDir )
    .loadPropertiesFromFile( pathToConfig + "neo4j.properties" )
    .newGraphDatabase();
]]></programlisting>
<simpara>Configuration settings can also be applied programmatically, like so:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[GraphDatabaseService graphDb = new GraphDatabaseFactory()
    .newEmbeddedDatabaseBuilder( storeDir )
    .setConfig( GraphDatabaseSettings.nodestore_mapped_memory_size, "10M" )
    .setConfig( GraphDatabaseSettings.string_block_size, "60" )
    .setConfig( GraphDatabaseSettings.array_block_size, "300" )
    .newGraphDatabase();
]]></programlisting>
<simpara>For configuration settings, see <xref linkend="embedded-configuration"/>.</simpara>
</section>
<section id="tutorials-java-embedded-setup-readonly">
<title>Starting an embedded read-only instance</title>
<simpara>If you want a <emphasis>read-only view</emphasis> of the database, create an instance this way:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[graphDb = new GraphDatabaseFactory().newEmbeddedDatabaseBuilder(
        "target/read-only-db/location" )
        .setConfig( GraphDatabaseSettings.read_only, "true" )
        .newGraphDatabase();
]]></programlisting>
<simpara>Obviously the database has to already exist in this case.</simpara>
<note><simpara>Concurrent access to the same database files by multiple (read-only or write) instances is not supported.</simpara></note>
</section>
</section>
</section>
<section id="tutorials-java-embedded-hello-world">
<title>Hello World</title>
<simpara>Learn how to create and access nodes and relationships.
For information on project setup, see <xref linkend="tutorials-java-embedded-setup"/>.</simpara>
<simpara>Remember, from <xref linkend="what-is-a-graphdb"/>, that a Neo4j graph consist of:</simpara>
<itemizedlist>
<listitem>
<simpara>
Nodes that are connected by
</simpara>
</listitem>
<listitem>
<simpara>
Relationships, with
</simpara>
</listitem>
<listitem>
<simpara>
Properties on both nodes and relationships.
</simpara>
</listitem>
</itemizedlist>
<simpara>All relationships have a type.
For example, if the graph represents a social network, a relationship type could be <literal>KNOWS</literal>.
If a relationship of the type <literal>KNOWS</literal> connects two nodes, that probably represents two people that know each other.
A lot of the semantics (that is the meaning) of a graph is encoded in the relationship types of the application.
And although relationships are directed they are equally well traversed regardless of which direction they are traversed.</simpara>
<tip><simpara>The source code of this example is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/main/java/org/neo4j/examples/EmbeddedNeo4j.java">EmbeddedNeo4j.java</ulink></simpara></tip>
<section id="_prepare_the_database">
<title>Prepare the database</title>
<simpara>Relationship types can be created by using an <literal>enum</literal>.
In this example we only need a single relationship type. This is how to
define it:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[private static enum RelTypes implements RelationshipType
{
    KNOWS
}
]]></programlisting>
<simpara>We also prepare some variables to use:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[GraphDatabaseService graphDb;
Node firstNode;
Node secondNode;
Relationship relationship;
]]></programlisting>
<simpara>The next step is to start the database server.
Note that if the directory given for the database doesn&#8217;t already exist, it will be created.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );
registerShutdownHook( graphDb );
]]></programlisting>
<simpara>Note that starting a database server is an expensive operation, so don&#8217;t start up a new instance every time you need to interact with the database!
The instance can be shared by multiple threads.
Transactions are thread confined.</simpara>
<simpara>As seen, we register a shutdown hook that will make sure the database shuts down when the JVM exits.
Now it&#8217;s time to interact with the database.</simpara>
</section>
<section id="_wrap_operations_in_a_transaction">
<title>Wrap operations in a transaction</title>
<simpara>All operations have to be performed in a transaction.
This is a conscious design decision, since we believe transaction demarcation to be an important part of working with a real enterprise database.
Now, transaction handling in Neo4j is very easy:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphDb.beginTx() )
{
    // Database operations go here
    tx.success();
}
]]></programlisting>
<simpara>For more information on transactions, see <xref linkend="transactions"/> and
<ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/Transaction.html">Java API for Transaction</ulink>.</simpara>
<note><simpara>For brevity, we do not spell out wrapping of operations in a transaction throughout the manual.</simpara></note>
</section>
<section id="_create_a_small_graph">
<title>Create a small graph</title>
<simpara>Now, let&#8217;s create a few nodes.
The API is very intuitive.
Feel free to have a look at the JavaDocs at <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/">http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/</ulink>.
They&#8217;re included in the distribution, as well.
Here&#8217;s how to create a small graph consisting of two nodes, connected with one relationship and some properties:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[firstNode = graphDb.createNode();
firstNode.setProperty( "message", "Hello, " );
secondNode = graphDb.createNode();
secondNode.setProperty( "message", "World!" );

relationship = firstNode.createRelationshipTo( secondNode, RelTypes.KNOWS );
relationship.setProperty( "message", "brave Neo4j " );
]]></programlisting>
<simpara>We now have a graph that looks like this:</simpara>
<figure><title>Hello World Graph</title>
<ulink url="images/Hello-World-Graph-java.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Hello-World-Graph-java.svg"/>
  </imageobject>
  <textobject><phrase>Hello-World-Graph-java.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
<section id="_print_the_result">
<title>Print the result</title>
<simpara>After we&#8217;ve created our graph, let&#8217;s read from it and print the result.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[System.out.print( firstNode.getProperty( "message" ) );
System.out.print( relationship.getProperty( "message" ) );
System.out.print( secondNode.getProperty( "message" ) );
]]></programlisting>
<simpara>Which will output:</simpara>
<simpara>Hello, brave Neo4j World!</simpara>
</section>
<section id="_remove_the_data">
<title>Remove the data</title>
<simpara>In this case we&#8217;ll remove the data before committing:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[// let's remove the data
firstNode.getSingleRelationship( RelTypes.KNOWS, Direction.OUTGOING ).delete();
firstNode.delete();
secondNode.delete();
]]></programlisting>
<simpara>Note that deleting a node which still has relationships when the transaction commits will fail.
This is to make sure relationships always have a start node and an end node.</simpara>
</section>
<section id="_shut_down_the_database_server">
<title>Shut down the database server</title>
<simpara>Finally, shut down the database server <emphasis>when the application finishes:</emphasis></simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[graphDb.shutdown();
]]></programlisting>
</section>
</section>
<section id="tutorials-java-embedded-new-index">
<title>User database with indexes</title>
<simpara>You have a user database, and want to retrieve users by name using indexes.</simpara>
<tip><simpara>The source code used in this example is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/main/java/org/neo4j/examples/EmbeddedNeo4jWithNewIndexing.java">EmbeddedNeo4jWithNewIndexing.java</ulink></simpara></tip>
<simpara>To begin with, we start the database server:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[GraphDatabaseService graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );
]]></programlisting>
<simpara>Then we have to configure the database to index users by name.
This only needs to be done once.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[IndexDefinition indexDefinition;
try ( Transaction tx = graphDb.beginTx() )
{
    Schema schema = graphDb.schema();
    indexDefinition = schema.indexFor( DynamicLabel.label( "User" ) )
            .on( "username" )
            .create();
    tx.success();
}
]]></programlisting>
<simpara>Indexes are populated asynchronously when they are first created.
It is possible to use the core API to wait for index population to complete:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphDb.beginTx() )
{
    Schema schema = graphDb.schema();
    schema.awaitIndexOnline( indexDefinition, 10, TimeUnit.SECONDS );
}
]]></programlisting>
<simpara>It&#8217;s time to add the users:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphDb.beginTx() )
{
    Label label = DynamicLabel.label( "User" );

    // Create some users
    for ( int id = 0; id < 100; id++ )
    {
        Node userNode = graphDb.createNode( label );
        userNode.setProperty( "username", "user" + id + "@neo4j.org" );
    }
    System.out.println( "Users created" );
    tx.success();
}
]]></programlisting>
<simpara>And here&#8217;s how to find a user by id:</simpara>
<note><simpara>Please read <xref linkend="tutorials-java-embedded-resource-iteration"/> on how to properly close ResourceIterators returned from index lookups.</simpara></note>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Label label = DynamicLabel.label( "User" );
int idToFind = 45;
String nameToFind = "user" + idToFind + "@neo4j.org";
try ( Transaction tx = graphDb.beginTx() )
{
    try ( ResourceIterator<Node> users =
            graphDb.findNodesByLabelAndProperty( label, "username", nameToFind ).iterator() )
    {
        ArrayList<Node> userNodes = new ArrayList<>();
        while ( users.hasNext() )
        {
            userNodes.add( users.next() );
        }

        for ( Node node : userNodes )
        {
            System.out.println( "The username of user " + idToFind + " is " + node.getProperty( "username" ) );
        }
    }
}
]]></programlisting>
<simpara>When updating the name of a user, the index is updated as well:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphDb.beginTx() )
{
    Label label = DynamicLabel.label( "User" );
    int idToFind = 45;
    String nameToFind = "user" + idToFind + "@neo4j.org";

    for ( Node node : graphDb.findNodesByLabelAndProperty( label, "username", nameToFind ) )
    {
        node.setProperty( "username", "user" + ( idToFind + 1 ) + "@neo4j.org" );
    }
    tx.success();
}
]]></programlisting>
<simpara>When deleting a user, it is automatically removed from the index:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphDb.beginTx() )
{
    Label label = DynamicLabel.label( "User" );
    int idToFind = 46;
    String nameToFind = "user" + idToFind + "@neo4j.org";

    for ( Node node : graphDb.findNodesByLabelAndProperty( label, "username", nameToFind ) )
    {
        node.delete();
    }
    tx.success();
}
]]></programlisting>
<simpara>In case we change our data model, we can drop the index as well:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphDb.beginTx() )
{
    Label label = DynamicLabel.label( "User" );
    for ( IndexDefinition indexDefinition : graphDb.schema()
            .getIndexes( label ) )
    {
        // There is only one index
        indexDefinition.drop();
    }

    tx.success();
}
]]></programlisting>
</section>
<section id="tutorials-java-embedded-index">
<title>User database with legacy index</title>
<note><simpara>Please read <xref linkend="tutorials-java-embedded-resource-iteration"/> on how to properly close ResourceIterators returned from index lookups.</simpara></note>
<simpara>You have a user database, and want to retrieve users by name using the legacy indexing system.</simpara>
<tip><simpara>The source code used in this example is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/main/java/org/neo4j/examples/EmbeddedNeo4jWithIndexing.java">EmbeddedNeo4jWithIndexing.java</ulink></simpara></tip>
<simpara>We have created two helper methods to handle user names and adding users to the database:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[private static String idToUserName( final int id )
{
    return "user" + id + "@neo4j.org";
}

private static Node createAndIndexUser( final String username )
{
    Node node = graphDb.createNode();
    node.setProperty( USERNAME_KEY, username );
    nodeIndex.add( node, USERNAME_KEY, username );
    return node;
}
]]></programlisting>
<simpara>The next step is to start the database server:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[graphDb = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );
registerShutdownHook();
]]></programlisting>
<simpara>It&#8217;s time to add the users:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphDb.beginTx() )
{
    nodeIndex = graphDb.index().forNodes( "nodes" );
    // Create some users and index their names with the IndexService
    for ( int id = 0; id < 100; id++ )
    {
        createAndIndexUser( idToUserName( id ) );
    }
]]></programlisting>
<simpara>And here&#8217;s how to find a user by Id:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[int idToFind = 45;
String userName = idToUserName( idToFind );
Node foundUser = nodeIndex.get( USERNAME_KEY, userName ).getSingle();

System.out.println( "The username of user " + idToFind + " is "
    + foundUser.getProperty( USERNAME_KEY ) );
]]></programlisting>
</section>
<section id="tutorials-java-embedded-resource-iteration">
<title>Managing resources when using long running transactions</title>
<simpara>It is necessary to always open a transaction when accessing the database.
Inside a long running transaction it is good practice to ensure that any
<literal><ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/ResourceIterator.html">ResourceIterator</ulink></literal>s
obtained inside the transaction are closed as early as possible.
This is either achieved by just exhausting the iterator or by explicitly calling its close method.</simpara>
<simpara>What follows is an example of how to work with a <literal>ResourceIterator</literal>.
As we don&#8217;t exhaust the iterator, we will close it explicitly using the <literal>close()</literal> method.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Label label = DynamicLabel.label( "User" );
int idToFind = 45;
String nameToFind = "user" + idToFind + "@neo4j.org";
try ( Transaction tx = graphDb.beginTx();
      ResourceIterator<Node> users = graphDb
            .findNodesByLabelAndProperty( label, "username", nameToFind )
            .iterator() )
{
    Node firstUserNode;
    if ( users.hasNext() )
    {
        firstUserNode = users.next();
    }
    users.close();
}
]]></programlisting>
</section>
<section id="tutorials-java-unit-testing">
<title>Basic unit testing</title>
<simpara>The basic pattern of unit testing with Neo4j is illustrated by the following example.</simpara>
<simpara>To access the Neo4j testing facilities you should have the <literal>neo4j-kernel</literal> <emphasis>tests.jar</emphasis> on the classpath during tests.
You can download it from Maven Central: <ulink url="http://search.maven.org/#search|ga|1|g%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-kernel%22">org.neo4j:neo4j-kernel</ulink>.</simpara>
<simpara>Using Maven as a dependency manager you would typically add this dependency together with JUnit and Hamcrest like so:</simpara>
<formalpara><title>Maven dependency</title><para>
<programlisting language="xml" linenumbering="unnumbered">&lt;project&gt;
...
 &lt;dependencies&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;org.neo4j&lt;/groupId&gt;
   &lt;artifactId&gt;neo4j-kernel&lt;/artifactId&gt;
   &lt;version&gt;2.0-SNAPSHOT&lt;/version&gt;
   &lt;type&gt;test-jar&lt;/type&gt;
   &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;junit&lt;/groupId&gt;
   &lt;artifactId&gt;junit-dep&lt;/artifactId&gt;
   &lt;version&gt;4.11&lt;/version&gt;
   &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
   &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
   &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt;
   &lt;version&gt;1.3&lt;/version&gt;
   &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
  ...
 &lt;/dependencies&gt;
...
&lt;/project&gt;</programlisting>
</para></formalpara>
<simpara>Observe that the <literal>&lt;type&gt;test-jar&lt;/type&gt;</literal> is crucial.
Without it you would get the common <literal>neo4j-kernel</literal> jar, not the one containing the testing facilities.</simpara>
<simpara>With that in place, we&#8217;re ready to code our tests.</simpara>
<tip><simpara>For the full source code of this example see:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/test/java/org/neo4j/examples/Neo4jBasicDocTest.java">Neo4jBasicDocTest.java</ulink></simpara></tip>
<simpara>Before each test, create a fresh database:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[@Before
public void prepareTestDatabase()
{
    graphDb = new TestGraphDatabaseFactory().newImpermanentDatabase();
}
]]></programlisting>
<simpara>After the test has executed, the database should be shut down:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[@After
public void destroyTestDatabase()
{
    graphDb.shutdown();
}
]]></programlisting>
<simpara>During a test, create nodes and check to see that they are there, while enclosing write operations in a transaction.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Node n = null;
try ( Transaction tx = graphDb.beginTx() )
{
    n = graphDb.createNode();
    n.setProperty( "name", "Nancy" );
    tx.success();
}

// The node should have a valid id
assertThat( n.getId(), is( greaterThan( -1L ) ) );

// Retrieve a node by using the id of the created node. The id's and
// property should match.
try ( Transaction tx = graphDb.beginTx() )
{
    Node foundNode = graphDb.getNodeById( n.getId() );
    assertThat( foundNode.getId(), is( n.getId() ) );
    assertThat( (String) foundNode.getProperty( "name" ), is( "Nancy" ) );
}
]]></programlisting>
<simpara>If you want to set configuration parameters at database creation, it&#8217;s done like this:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[GraphDatabaseService db = new TestGraphDatabaseFactory()
    .newImpermanentDatabaseBuilder()
    .setConfig( GraphDatabaseSettings.nodestore_mapped_memory_size, "10M" )
    .setConfig( GraphDatabaseSettings.string_block_size, "60" )
    .setConfig( GraphDatabaseSettings.array_block_size, "300" )
    .newGraphDatabase();
]]></programlisting>
</section>
<section id="tutorials-java-embedded-traversal">
<title>Traversal</title>
<simpara>For reading about traversals, see <xref linkend="tutorial-traversal"/>.</simpara>
<simpara>For more examples of traversals, see <xref linkend="data-modeling-examples"/>.</simpara>
<section id="_the_matrix">
<title>The Matrix</title>
<simpara>This is the first graph we want to traverse into:</simpara>
<figure><title>Matrix node space view</title>
<ulink url="images/examples-matrix.png">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/examples-matrix.png" width="75%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>examples-matrix.png</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<tip><simpara>The source code of this example is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/main/java/org/neo4j/examples/NewMatrix.java">NewMatrix.java</ulink></simpara></tip>
<formalpara><title>Friends and friends of friends</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[private static Traverser getFriends(
        final Node person )
{
    TraversalDescription td = Traversal.description()
            .breadthFirst()
            .relationships( RelTypes.KNOWS, Direction.OUTGOING )
            .evaluator( Evaluators.excludeStartPosition() );
    return td.traverse( person );
}
]]></programlisting>
</para></formalpara>
<simpara>Let&#8217;s perform the actual traversal and print the results:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[int numberOfFriends = 0;
String output = neoNode.getProperty( "name" ) + "'s friends:\n";
Traverser friendsTraverser = getFriends( neoNode );
for ( Path friendPath : friendsTraverser )
{
    output += "At depth " + friendPath.length() + " => "
              + friendPath.endNode()
                      .getProperty( "name" ) + "\n";
    numberOfFriends++;
}
output += "Number of friends found: " + numberOfFriends + "\n";
]]></programlisting>
<simpara>Which will give us the following output:</simpara>
<programlisting language="plain" linenumbering="unnumbered">Thomas Anderson's friends:
At depth 1 =&gt; Trinity
At depth 1 =&gt; Morpheus
At depth 2 =&gt; Cypher
At depth 3 =&gt; Agent Smith
Number of friends found: 4</programlisting>
<formalpara><title>Who coded the Matrix?</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[private static Traverser findHackers( final Node startNode )
{
    TraversalDescription td = Traversal.description()
            .breadthFirst()
            .relationships( RelTypes.CODED_BY, Direction.OUTGOING )
            .relationships( RelTypes.KNOWS, Direction.OUTGOING )
            .evaluator(
                    Evaluators.includeWhereLastRelationshipTypeIs( RelTypes.CODED_BY ) );
    return td.traverse( startNode );
}
]]></programlisting>
</para></formalpara>
<simpara>Print out the result:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[String output = "Hackers:\n";
int numberOfHackers = 0;
Traverser traverser = findHackers( getNeoNode() );
for ( Path hackerPath : traverser )
{
    output += "At depth " + hackerPath.length() + " => "
              + hackerPath.endNode()
                      .getProperty( "name" ) + "\n";
    numberOfHackers++;
}
output += "Number of hackers found: " + numberOfHackers + "\n";
]]></programlisting>
<simpara>Now we know who coded the Matrix:</simpara>
<programlisting language="plain" linenumbering="unnumbered">Hackers:
At depth 4 =&gt; The Architect
Number of hackers found: 1</programlisting>
<section id="_walking_an_ordered_path">
<title>Walking an ordered path</title>
<simpara>This example shows how to use a path context holding a representation of a path.</simpara>
<tip><simpara>The source code of this example is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/main/java/org/neo4j/examples/orderedpath/OrderedPath.java">OrderedPath.java</ulink></simpara></tip>
<formalpara><title>Create a toy graph</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Node A = db.createNode();
Node B = db.createNode();
Node C = db.createNode();
Node D = db.createNode();

A.createRelationshipTo( C, REL2 );
C.createRelationshipTo( D, REL3 );
A.createRelationshipTo( B, REL1 );
B.createRelationshipTo( C, REL2 );
]]></programlisting>
</para></formalpara>
<informalfigure>
<ulink url="images/example-ordered-path.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/example-ordered-path.svg"/>
  </imageobject>
  <textobject><phrase>example-ordered-path.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>Now, the order of relationships (<literal>REL1</literal> &#8594; <literal>REL2</literal> &#8594; <literal>REL3</literal>) is stored in an <literal>ArrayList</literal>.
Upon traversal, the <literal>Evaluator</literal> can check against it to ensure that only paths are included and returned that have the predefined order of relationships:</simpara>
<formalpara><title>Define how to walk the path</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[final ArrayList<RelationshipType> orderedPathContext = new ArrayList<RelationshipType>();
orderedPathContext.add( REL1 );
orderedPathContext.add( withName( "REL2" ) );
orderedPathContext.add( withName( "REL3" ) );
TraversalDescription td = Traversal.description()
        .evaluator( new Evaluator()
        {
            @Override
            public Evaluation evaluate( final Path path )
            {
                if ( path.length() == 0 )
                {
                    return Evaluation.EXCLUDE_AND_CONTINUE;
                }
                RelationshipType expectedType = orderedPathContext.get( path.length() - 1 );
                boolean isExpectedType = path.lastRelationship()
                        .isType( expectedType );
                boolean included = path.length() == orderedPathContext.size() && isExpectedType;
                boolean continued = path.length() < orderedPathContext.size() && isExpectedType;
                return Evaluation.of( included, continued );
            }
        } )
        .uniqueness( Uniqueness.NODE_PATH );
]]></programlisting>
</para></formalpara>
<simpara>Note that we set the uniqueness to
<literal><ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/kernel/Uniqueness.html#NODE_PATH">Uniqueness.NODE_PATH</ulink></literal>
as we want to be able to revisit the same node dureing the traversal, but not the same path.</simpara>
<formalpara><title>Perform the traversal and print the result</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Traverser traverser = td.traverse( A );
PathPrinter pathPrinter = new PathPrinter( "name" );
for ( Path path : traverser )
{
    output += Traversal.pathToString( path, pathPrinter );
}
]]></programlisting>
</para></formalpara>
<simpara>Which will output:</simpara>
<programlisting language="plain" linenumbering="unnumbered">(A)--[REL1]--&gt;(B)--[REL2]--&gt;(C)--[REL3]--&gt;(D)</programlisting>
<simpara>In this case we use a custom class to format the path output.
This is how it&#8217;s done:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[static class PathPrinter implements Traversal.PathDescriptor<Path>
{
    private final String nodePropertyKey;

    public PathPrinter( String nodePropertyKey )
    {
        this.nodePropertyKey = nodePropertyKey;
    }

    @Override
    public String nodeRepresentation( Path path, Node node )
    {
        return "(" + node.getProperty( nodePropertyKey, "" ) + ")";
    }

    @Override
    public String relationshipRepresentation( Path path, Node from, Relationship relationship )
    {
        String prefix = "--", suffix = "--";
        if ( from.equals( relationship.getEndNode() ) )
        {
            prefix = "<--";
        }
        else
        {
            suffix = "-->";
        }
        return prefix + "[" + relationship.getType().name() + "]" + suffix;
    }
}
]]></programlisting>
<simpara>For options regarding output of a <literal>Path</literal>, see the
<ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/kernel/Traversal.html">Traversal</ulink> class.</simpara>
</section>
</section>
<section id="examples-uniqueness-of-paths-in-traversals">
<title>Uniqueness of Paths in traversals</title>
<simpara>This example is demonstrating the use of node uniqueness.
Below an imaginary domain graph with Principals
that own pets that are descendant to other pets.</simpara>
<figure><title>Descendants Example Graph</title>
<ulink url="images/Descendants-Example-Graph-Uniqueness-of-Paths-in-traversals.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Descendants-Example-Graph-Uniqueness-of-Paths-in-traversals.svg"/>
  </imageobject>
  <textobject><phrase>Descendants-Example-Graph-Uniqueness-of-Paths-in-traversals.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara>In order to return all descendants
of <literal>Pet0</literal> which have the relation <literal>owns</literal> to <literal>Principal1</literal> (<literal>Pet1</literal> and <literal>Pet3</literal>),
the Uniqueness of the traversal needs to be set to
<literal>NODE_PATH</literal> rather than the default <literal>NODE_GLOBAL</literal> so that nodes
can be traversed more that once, and paths that have
different nodes but can have some nodes in common (like the
start and end node) can be returned.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[final Node target = data.get().get( "Principal1" );
TraversalDescription td = db.traversalDescription()
        .uniqueness( Uniqueness.NODE_PATH )
        .evaluator( new Evaluator()
{
    @Override
    public Evaluation evaluate( Path path )
    {
        boolean endNodeIsTarget = path.endNode().equals( target );
        return Evaluation.of( endNodeIsTarget, !endNodeIsTarget );
    }
} );

Traverser results = td.traverse( start );
]]></programlisting>
<simpara>This will return the following paths:</simpara>
<programlisting language="plain" linenumbering="unnumbered">(2)--[descendant,0]--&gt;(0)&lt;--[owns,3]--(4)
(2)--[descendant,2]--&gt;(3)&lt;--[owns,5]--(4)</programlisting>
<simpara>In the default <literal>path.toString()</literal> implementation, <literal>(1)--[knows,2]--&gt;(4)</literal> denotes
a node with ID=1 having a relationship with ID 2 or type <literal>knows</literal> to a node with ID-4.</simpara>
<simpara>Let&#8217;s create a new <literal>TraversalDescription</literal> from the old one,
having <literal>NODE_GLOBAL</literal> uniqueness to see the difference.</simpara>
<tip><simpara>The <literal>TraversalDescription</literal> object is immutable,
     so we have to use the new instance returned
     with the new uniqueness setting.</simpara></tip>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[TraversalDescription nodeGlobalTd = td.uniqueness( Uniqueness.NODE_GLOBAL );
results = nodeGlobalTd.traverse( start );
]]></programlisting>
<simpara>Now only one path is returned:</simpara>
<programlisting language="plain" linenumbering="unnumbered">(2)--[descendant,0]--&gt;(0)&lt;--[owns,3]--(4)</programlisting>
</section>
<section id="tutorials-java-embedded-social">
<title>Social network</title>
<note><simpara>The following example uses the new enhanced traversal API.</simpara></note>
<simpara>Social networks (know as social graphs out on the web) are natural to model with a graph.
This example shows a very simple social model that connects friends and keeps track of status updates.</simpara>
<tip><simpara>The source code of the example is found here:
<ulink url="https://github.com/neo4j/neo4j/tree/master/community/embedded-examples/src/main/java/org/neo4j/examples/socnet">socnet</ulink></simpara></tip>
<section id="_simple_social_model">
<title>Simple social model</title>
<figure><title>Social network data model</title>
<ulink url="images/socnet-model.png">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/socnet-model.png" width="60%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>socnet-model.png</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara>The data model for a social network is pretty simple: <literal>Persons</literal> with names and <literal>StatusUpdates</literal> with timestamped text.
These entities are then connected by specific relationships.</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>Person</literal>
</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>friend</literal>: relates two distinct <literal>Person</literal> instances (no self-reference)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>status</literal>: connects to the most recent <literal>StatusUpdate</literal>
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
<literal>StatusUpdate</literal>
</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>next</literal>: points to the next <literal>StatusUpdate</literal> in the chain, which was posted before the current one
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section id="_status_graph_instance">
<title>Status graph instance</title>
<simpara>The <literal>StatusUpdate</literal> list for a <literal>Person</literal> is a linked list.
The head of the list (the most recent status) is found by following <literal>status</literal>.
Each subsequent <literal>StatusUpdate</literal> is connected by <literal>next</literal>.</simpara>
<simpara>Here&#8217;s an example where Andreas Kollegger micro-blogged his way to work in the morning:</simpara>
<informalfigure>
<ulink url="images/andreas-status-updates.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/andreas-status-updates.svg"/>
  </imageobject>
  <textobject><phrase>andreas-status-updates.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>To read the status updates, we can create a traversal, like so:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[TraversalDescription traversal = Traversal.description().
        depthFirst().
        relationships( NEXT );
]]></programlisting>
<simpara>This gives us a traverser that will start at one <literal>StatusUpdate</literal>, and will follow the chain of updates until they run out.
Traversers are lazy loading, so it&#8217;s performant even when dealing with thousands of statuses&#8201;&#8212;&#8201;they are not loaded until we actually consume them.</simpara>
</section>
<section id="_activity_stream">
<title>Activity stream</title>
<simpara>Once we have friends, and they have status messages, we might want to read our friends status' messages, in reverse time order&#8201;&#8212;&#8201;latest first.
To do this, we go through these steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Gather all friend&#8217;s status update iterators in a list&#8201;&#8212;&#8201;latest date first.
</simpara>
</listitem>
<listitem>
<simpara>
Sort the list.
</simpara>
</listitem>
<listitem>
<simpara>
Return the first item in the list.
</simpara>
</listitem>
<listitem>
<simpara>
If the first iterator is exhausted, remove it from the list.
  Otherwise, get the next item in that iterator.
</simpara>
</listitem>
<listitem>
<simpara>
Go to step 2 until there are no iterators left in the list.
</simpara>
</listitem>
</orderedlist>
<simpara>Animated, the sequence looks like <ulink url="http://www.slideshare.net/systay/pattern-activity-stream">this</ulink>.</simpara>
<simpara>The code looks like:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[PositionedIterator<StatusUpdate> first = statuses.get(0);
StatusUpdate returnVal = first.current();

if ( !first.hasNext() )
{
    statuses.remove( 0 );
}
else
{
    first.next();
    sort();
}

return returnVal;
]]></programlisting>
</section>
</section>
</section>
<section id="tutorials-java-embedded-entities">
<title>Domain entities</title>
<simpara>This page demonstrates one way to handle domain entities when using Neo4j.
The principle at use is to wrap the entities around a node (the same approach can be used with relationships
as well).</simpara>
<tip><simpara>The source code of the examples is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/main/java/org/neo4j/examples/socnet/Person.java">Person.java</ulink></simpara></tip>
<simpara>First off, store the node and make it accessible inside the package:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[private final Node underlyingNode;

Person( Node personNode )
{
    this.underlyingNode = personNode;
}

protected Node getUnderlyingNode()
{
    return underlyingNode;
}

]]></programlisting>
<simpara>Delegate attributes to the node:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[public String getName()
{
    return (String)underlyingNode.getProperty( NAME );
}

]]></programlisting>
<simpara>Make sure to override these methods:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[@Override
public int hashCode()
{
    return underlyingNode.hashCode();
}

@Override
public boolean equals( Object o )
{
    return o instanceof Person &&
            underlyingNode.equals( ( (Person)o ).getUnderlyingNode() );
}

@Override
public String toString()
{
    return "Person[" + getName() + "]";
}

]]></programlisting>
</section>
<section id="tutorials-java-embedded-graph-algo">
<title>Graph Algorithm examples</title>
<tip><simpara>The source code used in the example is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/test/java/org/neo4j/examples/PathFindingDocTest.java">PathFindingDocTest.java</ulink></simpara></tip>
<simpara>Calculating the shortest path (least number of relationships) between two nodes:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Node startNode = graphDb.createNode();
Node middleNode1 = graphDb.createNode();
Node middleNode2 = graphDb.createNode();
Node middleNode3 = graphDb.createNode();
Node endNode = graphDb.createNode();
createRelationshipsBetween( startNode, middleNode1, endNode );
createRelationshipsBetween( startNode, middleNode2, middleNode3, endNode );

// Will find the shortest path between startNode and endNode via
// "MY_TYPE" relationships (in OUTGOING direction), like f.ex:
//
// (startNode)-->(middleNode1)-->(endNode)
//
PathFinder<Path> finder = GraphAlgoFactory.shortestPath(
    PathExpanders.forTypeAndDirection( ExampleTypes.MY_TYPE, Direction.OUTGOING ), 15 );
Iterable<Path> paths = finder.findAllPaths( startNode, endNode );
]]></programlisting>
<simpara>Using <ulink url="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#8217;s algorithm</ulink> to calculate cheapest path between node A and B where each relationship can have a weight (i.e. cost) and the path(s) with least cost are found.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[PathFinder<WeightedPath> finder = GraphAlgoFactory.dijkstra(
    PathExpanders.forTypeAndDirection( ExampleTypes.MY_TYPE, Direction.BOTH ), "cost" );

WeightedPath path = finder.findSinglePath( nodeA, nodeB );

// Get the weight for the found path
path.weight();
]]></programlisting>
<simpara>Using <ulink url="http://en.wikipedia.org/wiki/A*_search_algorithm">A*</ulink> to calculate the cheapest path between node A and B, where cheapest is for example the path in a network of roads which has the shortest length between node A and B.
Here&#8217;s our example graph:</simpara>
<informalfigure>
<ulink url="images/graphalgo-astar.png">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphalgo-astar.png" width="50%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>A* algorithm example graph</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Node nodeA = createNode( "name", "A", "x", 0d, "y", 0d );
Node nodeB = createNode( "name", "B", "x", 7d, "y", 0d );
Node nodeC = createNode( "name", "C", "x", 2d, "y", 1d );
Relationship relAB = createRelationship( nodeA, nodeC, "length", 2d );
Relationship relBC = createRelationship( nodeC, nodeB, "length", 3d );
Relationship relAC = createRelationship( nodeA, nodeB, "length", 10d );

EstimateEvaluator<Double> estimateEvaluator = new EstimateEvaluator<Double>()
{
    @Override
    public Double getCost( final Node node, final Node goal )
    {
        double dx = (Double) node.getProperty( "x" ) - (Double) goal.getProperty( "x" );
        double dy = (Double) node.getProperty( "y" ) - (Double) goal.getProperty( "y" );
        double result = Math.sqrt( Math.pow( dx, 2 ) + Math.pow( dy, 2 ) );
        return result;
    }
};
PathFinder<WeightedPath> astar = GraphAlgoFactory.aStar(
        PathExpanders.allTypesAndDirections(),
        CommonEvaluators.doubleCostEvaluator( "length" ), estimateEvaluator );
WeightedPath path = astar.findSinglePath( nodeA, nodeB );
]]></programlisting>
</section>
<section id="tutorials-java-embedded-jmx">
<title>Reading a management attribute</title>
<simpara>The <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/jmx/JmxUtils.html">JmxUtils</ulink>
class includes methods to access Neo4j management beans.
The common JMX service can be used as well, but from your code you probably rather
want to use the approach outlined here.</simpara>
<tip><simpara>The source code of the example is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/test/java/org/neo4j/examples/JmxDocTest.java">JmxDocTest.java</ulink></simpara></tip>
<simpara>This example shows how to get the start time of a database:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[private static Date getStartTimeFromManagementBean(
        GraphDatabaseService graphDbService )
{
    ObjectName objectName = JmxUtils.getObjectName( graphDbService, "Kernel" );
    Date date = JmxUtils.getAttribute( objectName, "KernelStartTime" );
    return date;
}
]]></programlisting>
<simpara>Depending on which Neo4j edition you are using different sets of management beans are available.</simpara>
<itemizedlist>
<listitem>
<simpara>
For all editions, see the
<ulink url="http://components.neo4j.org/neo4j-jmx/2.0-SNAPSHOT/apidocs/org/neo4j/jmx/package-summary.html">org.neo4j.jmx</ulink>
  package.
</simpara>
</listitem>
<listitem>
<simpara>
For the Enterprise edition, see the
<ulink url="http://components.neo4j.org/neo4j-management/2.0-SNAPSHOT/apidocs/org/neo4j/management/package-summary.html">org.neo4j.management</ulink>
  package as well.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="tutorials-java-embedded-unique-nodes">
<title>How to create unique nodes</title>
<simpara>This section is about how to ensure uniqueness of a property when creating nodes.
For an overview of the topic, see <xref linkend="transactions-unique-nodes"/>.</simpara>
<section id="tutorials-java-embedded-unique-get-or-create">
<title>Get or create unique node using Cypher and unique constraints</title>
<formalpara><title>Create a Cypher execution engine and a unique constraint</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphdb.beginTx() )
{
    graphdb.schema()
            .constraintFor( DynamicLabel.label( "User" ) )
            .assertPropertyIsUnique( "name" )
            .create();
    tx.success();
}

return new ExecutionEngine( graphdb() );
]]></programlisting>
</para></formalpara>
<formalpara><title>Use MERGE to create a unique node</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Node result = null;
ResourceIterator<Node> resultIterator = null;
try ( Transaction tx = graphDb.beginTx() )
{
    String queryString = "MERGE (n:User {name: {name}}) RETURN n";
    Map<String, Object> parameters = new HashMap<>();
    parameters.put( "name", username );
    resultIterator = engine.execute( queryString, parameters ).columnAs( "n" );
    result = resultIterator.next();
    tx.success();
    return result;
}
]]></programlisting>
</para></formalpara>
</section>
<section id="tutorials-java-embedded-unique-get-or-create-with-factory">
<title>Get or create unique node using a legacy index</title>
<important><simpara>While this is a working solution, please consider using the preferred  <xref linkend="tutorials-java-embedded-unique-get-or-create"/> instead.</simpara></important>
<simpara>By using <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/Index.html#putIfAbsent%28T,%20java.lang.String,%20java.lang.Object%29"><literal>put-if-absent</literal></ulink> functionality,
entity uniqueness can be guaranteed using an index.</simpara>
<simpara>Here the index acts as the lock and will only lock the smallest part needed to guarantee uniqueness across threads and transactions.
To get the more high-level <literal>get-or-create</literal> functionality make use of <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/UniqueFactory.html"><literal>UniqueFactory</literal></ulink> as seen in the example below.</simpara>
<formalpara><title>Create a factory for unique nodes at application start</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphDb.beginTx() )
{
    UniqueFactory.UniqueNodeFactory result = new UniqueFactory.UniqueNodeFactory( graphDb, "users" )
    {
        @Override
        protected void initialize( Node created, Map<String, Object> properties )
        {
            created.addLabel( DynamicLabel.label( "User" ) );
            created.setProperty( "name", properties.get( "name" ) );
        }
    };
    tx.success();
    return result;
}
]]></programlisting>
</para></formalpara>
<formalpara><title>Use the unique node factory to get or create a node</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphDb.beginTx() )
{
    Node node = factory.getOrCreate( "name", username );
    tx.success();
    return node;
}
]]></programlisting>
</para></formalpara>
</section>
<section id="tutorials-java-embedded-unique-pessimistic">
<title>Pessimistic locking for node creation</title>
<important><simpara>While this is a working solution, please consider using the preferred  <xref linkend="tutorials-java-embedded-unique-get-or-create"/> instead.</simpara></important>
<simpara>One might be tempted to use Java synchronization for pessimistic locking, but this is dangerous.
By mixing locks in Neo4j and in the Java runtime, it is easy to produce deadlocks that are not detectable by Neo4j.
As long as all locking is done by Neo4j, all deadlocks will be detected and avoided.
Also, a solution using manual synchronization doesn&#8217;t ensure uniqueness in an HA environment.</simpara>
<simpara>This example uses a single &#8220;lock node&#8221; for locking.
We create it only as a place to put locks, nothing else.</simpara>
<formalpara><title>Create a lock node at application start</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphDb.beginTx() )
{
    final Node lockNode = graphDb.createNode();
    tx.success();
    return lockNode;
}
]]></programlisting>
</para></formalpara>
<formalpara><title>Use the lock node to ensure nodes are not created concurrently</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphDb.beginTx() )
{
    Index<Node> usersIndex = graphDb.index().forNodes( "users" );
    Node userNode = usersIndex.get( "name", username ).getSingle();
    if ( userNode != null )
    {
        return userNode;
    }

    tx.acquireWriteLock( lockNode );
    userNode = usersIndex.get( "name", username ).getSingle();
    if ( userNode == null )
    {
        userNode = graphDb.createNode( DynamicLabel.label( "User" ) );
        usersIndex.add( userNode, "name", username );
        userNode.setProperty( "name", username );
    }
    tx.success();
    return userNode;
}
]]></programlisting>
</para></formalpara>
<simpara>Note that finishing the transaction will release the lock on the lock node.</simpara>
</section>
</section>
<section id="tutorials-cypher-java">
<title>Execute Cypher Queries from Java</title>
<tip><simpara>The full source code of the example:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/cypher/cypher-docs/src/test/java/org/neo4j/cypher/javacompat/JavaQuery.java">JavaQuery.java</ulink></simpara></tip>
<simpara>In Java, you can use the <link linkend="cypher-query-lang">Cypher query language</link> as per the example below.
First, let&#8217;s add some data.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[GraphDatabaseService db = new GraphDatabaseFactory().newEmbeddedDatabase( DB_PATH );

try ( Transaction tx = db.beginTx(); )
{
    Node myNode = db.createNode();
    myNode.setProperty( "name", "my node" );
    tx.success();
}
]]></programlisting>
<simpara>Execute a query:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[ExecutionEngine engine = new ExecutionEngine( db );

ExecutionResult result;
try ( Transaction ignored = db.beginTx() )
{
    result = engine.execute( "start n=node(*) where n.name = 'my node' return n, n.name" );
]]></programlisting>
<note><simpara>Keep the <literal>ExecutionEngine</literal> around, don&#8217;t create a new one for each query!</simpara></note>
<simpara>The result will be:</simpara>
<programlisting language="plain" linenumbering="unnumbered">+-------------------------------------+
| n                       | n.name    |
+-------------------------------------+
| Node[0]{name:"my node"} | "my node" |
+-------------------------------------+
1 row</programlisting>
<caution><simpara>The classes used here are from the <literal>org.neo4j.cypher.javacompat</literal> package, <emphasis>not</emphasis> <literal>org.neo4j.cypher</literal>, see link to the Java API below.</simpara></caution>
<simpara>You can get a list of the columns in the result:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[List<String> columns = result.columns();
]]></programlisting>
<simpara>This contains:</simpara>
<programlisting language="plain" linenumbering="unnumbered">[n, n.name]</programlisting>
<simpara>To fetch the result items from a single column, do like this:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Iterator<Node> n_column = result.columnAs( "n" );
for ( Node node : IteratorUtil.asIterable( n_column ) )
{
    // note: we're grabbing the name property from the node,
    // not from the n.name in this case.
    nodeResult = node + ": " + node.getProperty( "name" );
}
]]></programlisting>
<simpara>In this case there&#8217;s only one node in the result:</simpara>
<programlisting language="plain" linenumbering="unnumbered">Node[0]: my node</programlisting>
<simpara>To get all columns, do like this instead:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[for ( Map<String, Object> row : result )
{
    for ( Entry<String, Object> column : row.entrySet() )
    {
        rows += column.getKey() + ": " + column.getValue() + "; ";
    }
    rows += "\n";
}
]]></programlisting>
<simpara>This outputs:</simpara>
<programlisting language="plain" linenumbering="unnumbered">n.name: my node; n: Node[0];</programlisting>
<caution><simpara><literal>dumpToString()</literal>, <literal>columnAs()</literal> and <literal>iterator()</literal> cannot be called more than once on the same ExecutionResult object. You should instead use only one and if you need the facilities of the other methods on the same query result instead create a new ExecutionResult.</simpara></caution>
<caution><simpara>When using an ExecutionResult, you&#8217;ll need to exhaust it by using any of the iterating methods (<literal>columnAs()</literal> and <literal>iterator()</literal>) on it. Failing to do so will not properly clean up resources used by the ExecutionResult, leading to unwanted behavior, such as leaking transactions.</simpara></caution>
<simpara>For more information on the Java interface to Cypher, see the
<ulink url="http://components.neo4j.org/neo4j-cypher/2.0-SNAPSHOT/apidocs/index.html">Java API</ulink>.</simpara>
<simpara>For more information and examples for Cypher, see <xref linkend="cypher-query-lang"/> and <xref linkend="data-modeling-examples"/>.</simpara>
</section>
<section id="tutorials-cypher-parameters-java">
<title>Query Parameters</title>
<simpara>For more information on parameters see <xref linkend="cypher-parameters"/>.</simpara>
<simpara>Below follows example of how to use parameters when executing Cypher queries from Java.</simpara>
<formalpara><title>Node id</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Map<String, Object> params = new HashMap<String, Object>();
params.put( "id", 0 );
String query = "START n=node({id}) RETURN n.name";
ExecutionResult result = engine.execute( query, params );
]]></programlisting>
</para></formalpara>
<formalpara><title>Node object</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Map<String, Object> params = new HashMap<String, Object>();
params.put( "node", andreasNode );
String query = "START n=node({node}) RETURN n.name";
ExecutionResult result = engine.execute( query, params );
]]></programlisting>
</para></formalpara>
<formalpara><title>Multiple node ids</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Map<String, Object> params = new HashMap<String, Object>();
params.put( "id", Arrays.asList( 0, 1, 2 ) );
String query = "START n=node({id}) RETURN n.name";
ExecutionResult result = engine.execute( query, params );
]]></programlisting>
</para></formalpara>
<formalpara><title>String literal</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Map<String, Object> params = new HashMap<String, Object>();
params.put( "name", "Johan" );
String query = "MATCH (n) WHERE n.name = {name} RETURN n";
ExecutionResult result = engine.execute( query, params );
]]></programlisting>
</para></formalpara>
<formalpara><title>Index value</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Map<String, Object> params = new HashMap<String, Object>();
params.put( "value", "Michaela" );
String query = "START n=node:people(name = {value}) RETURN n";
ExecutionResult result = engine.execute( query, params );
]]></programlisting>
</para></formalpara>
<formalpara><title>Index query</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Map<String, Object> params = new HashMap<String, Object>();
params.put( "query", "name:Andreas" );
String query = "START n=node:people({query}) RETURN n";
ExecutionResult result = engine.execute( query, params );
]]></programlisting>
</para></formalpara>
<formalpara><title>Numeric parameters for <literal>SKIP</literal> and <literal>LIMIT</literal></title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Map<String, Object> params = new HashMap<String, Object>();
params.put( "s", 1 );
params.put( "l", 1 );
String query = "MATCH (n) RETURN n.name SKIP {s} LIMIT {l}";
ExecutionResult result = engine.execute( query, params );
]]></programlisting>
</para></formalpara>
<formalpara><title>Regular expression</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Map<String, Object> params = new HashMap<String, Object>();
params.put( "regex", ".*h.*" );
String query = "MATCH (n) WHERE n.name =~ {regex} RETURN n.name";
ExecutionResult result = engine.execute( query, params );
]]></programlisting>
</para></formalpara>
<formalpara><title>Create node with properties</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Map<String, Object> props = new HashMap<String, Object>();
props.put( "name", "Andres" );
props.put( "position", "Developer" );

Map<String, Object> params = new HashMap<String, Object>();
params.put( "props", props );
String query = "CREATE ({props})";
engine.execute( query, params );
]]></programlisting>
</para></formalpara>
<formalpara><title>Create multiple nodes with properties</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Map<String, Object> n1 = new HashMap<String, Object>();
n1.put( "name", "Andres" );
n1.put( "position", "Developer" );
n1.put( "awesome", true );

Map<String, Object> n2 = new HashMap<String, Object>();
n2.put( "name", "Michael" );
n2.put( "position", "Developer" );
n2.put( "children", 3 );

Map<String, Object> params = new HashMap<String, Object>();
List<Map<String, Object>> maps = Arrays.asList( n1, n2 );
params.put( "props", maps );
String query = "CREATE (n:Person {props}) RETURN n";
engine.execute( query, params );
]]></programlisting>
</para></formalpara>
<formalpara><title>Setting all properties on node</title><para>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Map<String, Object> n1 = new HashMap<>();
n1.put( "name", "Andres" );
n1.put( "position", "Developer" );

Map<String, Object> params = new HashMap<>();
params.put( "props", n1 );

String query = "MATCH (n) WHERE n.name='Michaela' SET n = {props}";
engine.execute( query, params );
]]></programlisting>
</para></formalpara>
</section>
</chapter>
<chapter id="tutorial-traversal">
<title>The Traversal Framework</title>
<simpara>The <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/package-summary.html">Neo4j Traversal API</ulink> is a callback based, lazily executed way of specifying desired movements through a graph in Java.
Some traversal examples are collected under <xref linkend="tutorials-java-embedded-traversal"/>.</simpara>
<simpara>You can also use <link linkend="cypher-query-lang">The Cypher Query Language</link> as a powerful declarative way to query the graph.</simpara>
<section id="tutorial-traversal-concepts">
<title>Main concepts</title>
<simpara>Here follows a short explanation of all different methods that can modify or add to a traversal description.</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>Pathexpanders</emphasis>&#8201;&#8212;&#8201;define what to traverse, typically in terms of relationship direction and type.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>Order</emphasis>&#8201;&#8212;&#8201;for example depth-first or breadth-first.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>Uniqueness</emphasis>&#8201;&#8212;&#8201;visit nodes (relationships, paths) only once.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>Evaluator</emphasis>&#8201;&#8212;&#8201;decide what to return and whether to stop or continue traversal beyond the current position.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>Starting nodes</emphasis> where the traversal will begin.
</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<ulink url="images/graphdb-traversal-description.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/graphdb-traversal-description.svg" width="100%" scalefit="1"/>
  </imageobject>
  <textobject><phrase>graphdb-traversal-description.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</informalfigure>
<simpara>See <xref linkend="tutorial-traversal-java-api"/> for more details.</simpara>
</section>
<section id="tutorial-traversal-java-api">
<title>Traversal Framework Java API</title>
<simpara>The traversal framework consists of a few main interfaces in addition to <literal>Node</literal> and <literal>Relationship</literal>: <literal>TraversalDescription</literal>, <literal>Evaluator</literal>, <literal>Traverser</literal> and <literal>Uniqueness</literal> are the main ones.
The <literal>Path</literal> interface also has a special purpose in traversals, since it is used to represent a position in the graph when evaluating that position.
Furthermore the <literal>PathExpander</literal> (replacing <literal>RelationshipExpander</literal> and <literal>Expander</literal>) interface is central to traversals, but users of the API rarely need to implement it.
There are also a set of interfaces for advanced use, when explicit control over the traversal order is required: <literal>BranchSelector</literal>, <literal>BranchOrderingPolicy</literal> and <literal>TraversalBranch</literal>.</simpara>
<section id="_traversaldescription">
<title>TraversalDescription</title>
<simpara>The <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html"><literal>TraversalDescription</literal></ulink> is the main interface used for defining and initializing traversals.
It is not meant to be implemented by users of the traversal framework, but rather to be provided by the implementation of the traversal framework as a way for the user to describe traversals.
<literal>TraversalDescription</literal> instances are immutable and its methods returns a new <literal>TraversalDescription</literal> that is modified compared to the object the method was invoked on with the arguments of the method.</simpara>
<section id="_relationships">
<title>Relationships</title>
<simpara>Adds a relationship type to the list of relationship types to traverse.
By default that list is empty and it means that it will traverse <emphasis>all relationships</emphasis>, irregardless of type.
If one or more relationships are added to this list <emphasis>only the added</emphasis> types will be traversed.
There are two methods, one <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html#relationships">including direction</ulink> and another one <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html#relationships">excluding direction</ulink>, where the latter traverses relationships in <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/Direction.html#BOTH">both directions</ulink>.</simpara>
</section>
</section>
<section id="_evaluator">
<title>Evaluator</title>
<simpara><ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/Evaluator.html"><literal>Evaluator</literal></ulink>s are used for deciding, at each position (represented as a <literal>Path</literal>): should the traversal continue, and/or should the node be included in the result.
Given a <literal>Path</literal>, it asks for one of four actions for that branch of the traversal:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>Evaluation.INCLUDE_AND_CONTINUE</literal>: Include this node in the result and continue the traversal
</simpara>
</listitem>
<listitem>
<simpara>
<literal>Evaluation.INCLUDE_AND_PRUNE</literal>: Include this node in the result, but don&#8217;t continue the traversal
</simpara>
</listitem>
<listitem>
<simpara>
<literal>Evaluation.EXCLUDE_AND_CONTINUE</literal>: Exclude this node from the result, but continue the traversal
</simpara>
</listitem>
<listitem>
<simpara>
<literal>Evaluation.EXCLUDE_AND_PRUNE</literal>: Exclude this node from the result and don&#8217;t continue the traversal
</simpara>
</listitem>
</itemizedlist>
<simpara>More than one evaluator can be added. Note that evaluators will be called for all positions the traverser encounters, even for the start node.</simpara>
</section>
<section id="_traverser">
<title>Traverser</title>
<simpara>The <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/Traverser.html"><literal>Traverser</literal></ulink> object is the result of invoking <ulink url="http://components.neo4j.org/neo4j-kernel/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html#traverse(org.neo4j.graphdb.Node)"><literal>traverse()</literal></ulink> of a TraversalDescription object.
It represents a traversal positioned in the graph, and a specification of the format of the result.
The actual traversal is performed lazily each time the <literal>next()</literal>-method of the iterator of the <literal>Traverser</literal> is invoked.</simpara>
</section>
<section id="_uniqueness">
<title>Uniqueness</title>
<simpara>Sets the rules for how positions can be revisited during a traversal as stated in <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/Uniqueness.html"><literal>Uniqueness</literal></ulink>.
Default if not set is <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/Uniqueness.html#NODE_GLOBAL"><literal>NODE_GLOBAL</literal></ulink>.</simpara>
<simpara>A Uniqueness can be supplied to the TraversalDescription to dictate under what circumstances a traversal may revisit the same position in the graph. The various uniqueness levels that can be used in Neo4j are:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>NONE</literal>: Any position in the graph may be revisited.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>NODE_GLOBAL</literal> uniqueness: No node in the entire graph may be visited more than once. This could potentially consume a lot of memory since it requires keeping an in-memory data structure remembering all the visited nodes.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>RELATIONSHIP_GLOBAL</literal> uniqueness: no relationship in the entire graph may be visited more than once. For the same reasons as <literal>NODE_GLOBAL</literal> uniqueness, this could use up a lot of memory. But since graphs typically have a larger number of relationships than nodes, the memory overhead of this uniqueness level could grow even quicker.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>NODE_PATH</literal> uniqueness: A node may not occur previously in the path reaching up to it.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>RELATIONSHIP_PATH</literal> uniqueness: A relationship may not occur previously in the path reaching up to it.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>NODE_RECENT</literal> uniqueness: Similar to <literal>NODE_GLOBAL</literal> uniqueness in that there is a global collection of visited nodes each position is checked against. This uniqueness level does however have a cap on how much memory it may consume in the form of a collection that only contains the most recently visited nodes. The size of this collection can be specified by providing a number as the second argument to the TraversalDescription.uniqueness()-method along with the uniqueness level.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>RELATIONSHIP_RECENT</literal> uniqueness: Works like <literal>NODE_RECENT</literal> uniqueness, but with relationships instead of nodes.
</simpara>
</listitem>
</itemizedlist>
<section id="_depth_first_breadth_first">
<title>Depth First / Breadth First</title>
<simpara>These are convenience methods for setting preorder <ulink url="http://en.wikipedia.org/wiki/Depth-first_search">depth-first</ulink>/ <ulink url="http://en.wikipedia.org/wiki/Breadth-first_search">breadth-first</ulink> <literal>BranchSelector</literal>|<literal>ordering</literal> policies.
The same result can be achieved by calling the <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html#order"><literal>order</literal></ulink> method with ordering policies from <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/BranchOrderingPolicies.html"><literal>BranchOrderingPolicies</literal></ulink>, or to write your own <literal>BranchSelector</literal>/<literal>BranchOrderingPolicy</literal> and pass in.</simpara>
</section>
</section>
<section id="_order_8201_8212_8201_how_to_move_through_branches">
<title>Order&#8201;&#8212;&#8201;How to move through branches?</title>
<simpara>A more generic version of depthFirst/breadthFirst methods in that it allows an arbitrary <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/BranchOrderingPolicy.html"><literal>BranchOrderingPolicy</literal></ulink> to be injected into the description.</simpara>
</section>
<section id="_branchselector">
<title>BranchSelector</title>
<simpara>A <literal>BranchSelector</literal>/<literal>BranchOrderingPolicy</literal> is used for selecting which branch of the traversal to attempt next.
This is used for implementing traversal orderings.
The traversal framework provides a few basic ordering implementations:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>BranchOrderingPolicies.PREORDER_DEPTH_FIRST</literal>: Traversing depth first, visiting each node before visiting its child nodes.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>BranchOrderingPolicies.POSTORDER_DEPTH_FIRST</literal>: Traversing depth first, visiting each node after visiting its child nodes.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>BranchOrderingPolicies.PREORDER_BREADTH_FIRST</literal>: Traversing breadth first, visiting each node before visiting its child nodes.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>BranchOrderingPolicies.POSTORDER_BREADTH_FIRST</literal>: Traversing breadth first, visiting each node after visiting its child nodes.
</simpara>
</listitem>
</itemizedlist>
<note><simpara>Please note that breadth first traversals have a higher memory overhead than depth first traversals.</simpara></note>
<simpara><literal>BranchSelector</literal>s carries state and hence needs to be uniquely instantiated for each traversal.
Therefore it is supplied to the <literal>TraversalDescription</literal> through a <literal>BranchOrderingPolicy</literal> interface, which is a factory of <literal>BranchSelector</literal> instances.</simpara>
<simpara>A user of the Traversal framework rarely needs to implement his own <literal>BranchSelector</literal> or <literal>BranchOrderingPolicy</literal>, it is provided to let graph algorithm implementors provide their own traversal orders.
The Neo4j Graph Algorithms package contains for example a <literal>BestFirst</literal> order <literal>BranchSelector</literal>/<literal>BranchOrderingPolicy</literal> that is used in BestFirst search algorithms such as A* and Dijkstra.</simpara>
<section id="_branchorderingpolicy">
<title>BranchOrderingPolicy</title>
<simpara>A factory for creating <literal>BranchSelector</literal>s to decide in what order branches are returned (where a branch&#8217;s position is represented as a <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/Path.html"><literal>Path</literal></ulink> from the start node to the current node).
Common policies are <ulink url="http://components.neo4j.org/neo4j-kernel/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html#depthFirst()"><literal>depth-first</literal></ulink> and <ulink url="http://components.neo4j.org/neo4j-kernel/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html#breadthFirst()"><literal>breadth-first</literal></ulink> and that&#8217;s why there are convenience methods for those.
For example, calling <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html#depthFirst()"><literal>TraversalDescription#depthFirst()</literal></ulink> is equivalent to:</simpara>
<programlisting language="java" linenumbering="unnumbered">description.order( BranchOrderingPolicies.PREORDER_DEPTH_FIRST );</programlisting>
</section>
<section id="_traversalbranch">
<title>TraversalBranch</title>
<simpara>An object used by the BranchSelector to get more branches from a certain branch. In essence these are a composite of a Path and a RelationshipExpander that can be used to get new <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/TraversalBranch.html"><literal>TraversalBranch</literal></ulink>es from the current one.</simpara>
</section>
</section>
<section id="_path">
<title>Path</title>
<simpara>A <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/Path.html"><literal>Path</literal></ulink> is a general interface that is part of the Neo4j API.
In the traversal API of Neo4j the use of Paths are twofold.
Traversers can return their results in the form of the Paths of the visited positions in the graph that are marked for being returned.
Path objects are also used in the evaluation of positions in the graph, for determining if the traversal should continue from a certain point or not, and whether a certain position should be included in the result set or not.</simpara>
</section>
<section id="_pathexpander_relationshipexpander">
<title>PathExpander/RelationshipExpander</title>
<simpara>The traversal framework use <literal>PathExpander</literal>s (replacing <literal>RelationshipExpander</literal>) to discover the relationships that should be followed from a particular path to further branches in the traversal.</simpara>
</section>
<section id="_expander">
<title>Expander</title>
<simpara>A more generic version of relationships where a <literal>RelationshipExpander</literal> is injected, defining all relationships to be traversed for any given node.
By default (and when using relationships) a <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/kernel/Traversal.html#emptyExpander">default expander</ulink> is used, where any particular order of relationships isn&#8217;t guaranteed.
There&#8217;s another implementation which guarantees that relationships are traversed in <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/kernel/OrderedByTypeExpander.html">order of relationship type</ulink>, where types are iterated in the order they were added.</simpara>
<simpara>The <literal>Expander</literal> interface is an extension of the <literal>RelationshipExpander</literal> interface that makes it possible to build customized versions of an <literal>Expander</literal>.
The implementation of <literal>TraversalDescription</literal> uses this to provide methods for defining which relationship types to traverse, this is the usual way a user of the API would define a <literal>RelationshipExpander</literal>&#8201;&#8212;&#8201;by building it internally in the <literal>TraversalDescription</literal>.</simpara>
<simpara>All the RelationshipExpanders provided by the Neo4j traversal framework also implement the Expander interface.
For a user of the traversal API it is easier to implement the PathExpander/RelationshipExpander interface, since it only contains one method&#8201;&#8212;&#8201;the method for getting the relationships from a path/node, the methods that the Expander interface adds are just for building new Expanders.</simpara>
</section>
<section id="examples-how-to-use-the-traversal-framework">
<title>How to use the Traversal framework</title>
<simpara>A
<ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html">traversal description</ulink> is built using a
fluent interface and such a description can then spawn
<ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/Traverser.html">traversers</ulink>.</simpara>
<figure><title>Traversal Example Graph</title>
<ulink url="images/Traversal-Example-Graph-how-to-use-the-Traversal-framework.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Traversal-Example-Graph-how-to-use-the-Traversal-framework.svg"/>
  </imageobject>
  <textobject><phrase>Traversal-Example-Graph-how-to-use-the-Traversal-framework.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
<simpara>With the definition of the <literal>RelationshipTypes</literal> as</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[private enum Rels implements RelationshipType
{
    LIKES, KNOWS
}
]]></programlisting>
<simpara>The graph can be traversed with for example the following traverser, starting at the &#8220;Joe&#8221; node:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[for ( Path position : db.traversalDescription()
        .depthFirst()
        .relationships( Rels.KNOWS )
        .relationships( Rels.LIKES, Direction.INCOMING )
        .evaluator( Evaluators.toDepth( 5 ) )
        .traverse( node ) )
{
    output += position + "\n";
}
]]></programlisting>
<simpara>The traversal will output:</simpara>
<programlisting language="plain" linenumbering="unnumbered">(6)
(6)&lt;--[LIKES,1]--(3)
(6)&lt;--[LIKES,1]--(3)--[KNOWS,6]--&gt;(0)
(6)&lt;--[LIKES,1]--(3)--[KNOWS,6]--&gt;(0)--[KNOWS,4]--&gt;(5)
(6)&lt;--[LIKES,1]--(3)--[KNOWS,6]--&gt;(0)--[KNOWS,4]--&gt;(5)--[KNOWS,3]--&gt;(4)
(6)&lt;--[LIKES,1]--(3)--[KNOWS,6]--&gt;(0)--[KNOWS,4]--&gt;(5)--[KNOWS,3]--&gt;(4)--[KNOWS,2]--&gt;(1)
(6)&lt;--[LIKES,1]--(3)--[KNOWS,6]--&gt;(0)&lt;--[KNOWS,5]--(2)</programlisting>
<simpara>Since <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html"><literal>TraversalDescription</literal></ulink>s
are immutable it is also useful to create template descriptions which holds common
settings shared by different traversals. For example, let&#8217;s start with this traverser:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[friendsTraversal = db.traversalDescription()
        .depthFirst()
        .relationships( Rels.KNOWS )
        .uniqueness( Uniqueness.RELATIONSHIP_GLOBAL );
]]></programlisting>
<simpara>This traverser would yield the following output (we will keep starting from the &#8220;Joe&#8221; node):</simpara>
<programlisting language="plain" linenumbering="unnumbered">(6)
(6)--[KNOWS,0]--&gt;(1)
(6)--[KNOWS,0]--&gt;(1)&lt;--[KNOWS,2]--(4)
(6)--[KNOWS,0]--&gt;(1)&lt;--[KNOWS,2]--(4)&lt;--[KNOWS,3]--(5)
(6)--[KNOWS,0]--&gt;(1)&lt;--[KNOWS,2]--(4)&lt;--[KNOWS,3]--(5)&lt;--[KNOWS,4]--(0)
(6)--[KNOWS,0]--&gt;(1)&lt;--[KNOWS,2]--(4)&lt;--[KNOWS,3]--(5)&lt;--[KNOWS,4]--(0)&lt;--[KNOWS,5]--(2)
(6)--[KNOWS,0]--&gt;(1)&lt;--[KNOWS,2]--(4)&lt;--[KNOWS,3]--(5)&lt;--[KNOWS,4]--(0)&lt;--[KNOWS,6]--(3)</programlisting>
<simpara>Now let&#8217;s create a new traverser from it, restricting depth to three:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[for ( Path path : friendsTraversal
        .evaluator( Evaluators.toDepth( 3 ) )
        .traverse( node ) )
{
    output += path + "\n";
}
]]></programlisting>
<simpara>This will give us the following result:</simpara>
<programlisting language="plain" linenumbering="unnumbered">(6)
(6)--[KNOWS,0]--&gt;(1)
(6)--[KNOWS,0]--&gt;(1)&lt;--[KNOWS,2]--(4)
(6)--[KNOWS,0]--&gt;(1)&lt;--[KNOWS,2]--(4)&lt;--[KNOWS,3]--(5)</programlisting>
<simpara>Or how about from depth two to four?
That&#8217;s done like this:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[for ( Path path : friendsTraversal
        .evaluator( Evaluators.fromDepth( 2 ) )
        .evaluator( Evaluators.toDepth( 4 ) )
        .traverse( node ) )
{
    output += path + "\n";
}
]]></programlisting>
<simpara>This traversal gives us:</simpara>
<programlisting language="plain" linenumbering="unnumbered">(6)--[KNOWS,0]--&gt;(1)&lt;--[KNOWS,2]--(4)
(6)--[KNOWS,0]--&gt;(1)&lt;--[KNOWS,2]--(4)&lt;--[KNOWS,3]--(5)
(6)--[KNOWS,0]--&gt;(1)&lt;--[KNOWS,2]--(4)&lt;--[KNOWS,3]--(5)&lt;--[KNOWS,4]--(0)</programlisting>
<simpara>For various useful evaluators, see the
<ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/Evaluators.html">Evaluators</ulink> Java API
or simply implement the
<ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/Evaluator.html">Evaluator</ulink> interface yourself.</simpara>
<simpara>If you&#8217;re not interested in the <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/Path.html"><literal>Path</literal></ulink>s,
but the <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/Node.html"><literal>Node</literal></ulink>s
you can transform the traverser into an iterable of <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/Traverser.html#nodes()">nodes</ulink>
like this:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[for ( Node currentNode : friendsTraversal
        .traverse( node )
        .nodes() )
{
    output += currentNode.getProperty( "name" ) + "\n";
}
]]></programlisting>
<simpara>In this case we use it to retrieve the names:</simpara>
<programlisting language="plain" linenumbering="unnumbered">Joe
Sara
Peter
Dirk
Lars
Ed
Lisa</programlisting>
<simpara><ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/traversal/Traverser.html#relationships()">Relationships</ulink>
are fine as well, here&#8217;s how to get them:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[for ( Relationship relationship : friendsTraversal
        .traverse( node )
        .relationships() )
{
    output += relationship.getType().name() + "\n";
}
]]></programlisting>
<simpara>Here the relationship types are written, and we get:</simpara>
<programlisting language="plain" linenumbering="unnumbered">KNOWS
KNOWS
KNOWS
KNOWS
KNOWS
KNOWS</programlisting>
<tip><simpara>The source code for the traversers in this example is available at:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/embedded-examples/src/main/java/org/neo4j/examples/TraversalExample.java">TraversalExample.java</ulink></simpara></tip>
</section>
</section>
</chapter>
<chapter id="indexing">
<title>Legacy Indexing</title>
<note><simpara>This is not the same as <link linkend="graphdb-neo4j-schema">indexes defined in the schema</link>, the documentation below is for the legacy indexing in Neo4j.</simpara></note>
<simpara>This chapter focuses on how to use the Manual Indexes and Autoindexes.
As of Neo4j 2.0, this is not  the favored method of indexing data in Neo4j, instead we recommend defining indexes in the database schema.</simpara>
<simpara>However, support for legacy indexes remains, because certain features, such as uniqueness constraints, are not yet handled by the new indexes.</simpara>
<section id="indexing-introduction">
<title>Introduction</title>
<simpara>Legacy Indexing operations are part of the <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/package-summary.html">Neo4j index API</ulink>.</simpara>
<simpara>Each index is tied to a unique, user-specified name (for example "first_name" or "books") and can index either <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/Node.html">nodes</ulink> or <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/Relationship.html">relationships</ulink>.</simpara>
<simpara>The default index implementation is provided by the <literal>neo4j-lucene-index</literal> component, which is included in the standard Neo4j download.
It can also be downloaded separately from <ulink url="http://repo1.maven.org/maven2/org/neo4j/neo4j-lucene-index/">http://repo1.maven.org/maven2/org/neo4j/neo4j-lucene-index/</ulink> .
For Maven users, the <literal>neo4j-lucene-index</literal> component has the coordinates <literal>org.neo4j:neo4j-lucene-index</literal> and should be used with the same version of <literal>org.neo4j:neo4j-kernel</literal>.
Different versions of the index and kernel components are not compatible in the general case.
Both components are included transitively by the <literal>org.neo4j:neo4j:pom</literal> artifact which makes it simple to keep the versions in sync.</simpara>
<simpara>For initial import of data using indexes, see <xref linkend="indexing-batchinsert"/>.</simpara>
<note><simpara>All modifying index operations must be performed inside a transaction, as with any modifying operation in Neo4j.</simpara></note>
</section>
<section id="indexing-create">
<title>Create</title>
<simpara>An index is created if it doesn&#8217;t exist when you ask for it.
Unless you give it a custom configuration, it will be created with default configuration and backend.</simpara>
<simpara>To set the stage for our examples, let&#8217;s create some indexes to begin with:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[IndexManager index = graphDb.index();
Index<Node> actors = index.forNodes( "actors" );
Index<Node> movies = index.forNodes( "movies" );
RelationshipIndex roles = index.forRelationships( "roles" );
]]></programlisting>
<simpara>This will create two node indexes and one relationship index with default configuration.
See <xref linkend="indexing-relationships"/> for more information specific to relationship indexes.</simpara>
<simpara>See <xref linkend="indexing-create-advanced"/> for how to create <emphasis>fulltext</emphasis> indexes.</simpara>
<simpara>You can also check if an index exists like this:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[IndexManager index = graphDb.index();
boolean indexExists = index.existsForNodes( "actors" );
]]></programlisting>
</section>
<section id="indexing-delete">
<title>Delete</title>
<simpara>Indexes can be deleted.
When deleting, the entire contents of the index will be removed as well as its associated configuration.
An index can be created with the same name at a later point in time.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[IndexManager index = graphDb.index();
Index<Node> actors = index.forNodes( "actors" );
actors.delete();
]]></programlisting>
<simpara>Note that the actual deletion of the index is made during the commit of <emphasis>the surrounding transaction</emphasis>.
Calls made to such an index instance after <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/Index.html#delete%28%29">delete()</ulink> has been called are invalid inside that transaction as well as outside (if the transaction is successful), but will become valid again if the transaction is rolled back.</simpara>
</section>
<section id="indexing-add">
<title>Add</title>
<simpara>Each index supports associating any number of key-value pairs with any number of entities (nodes or relationships), where each association between entity and key-value pair is performed individually.
To begin with, let&#8217;s add a few nodes to the indexes:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[// Actors
Node reeves = graphDb.createNode();
reeves.setProperty( "name", "Keanu Reeves" );
actors.add( reeves, "name", reeves.getProperty( "name" ) );
Node bellucci = graphDb.createNode();
bellucci.setProperty( "name", "Monica Bellucci" );
actors.add( bellucci, "name", bellucci.getProperty( "name" ) );
// multiple values for a field, in this case for search only
// and not stored as a property.
actors.add( bellucci, "name", "La Bellucci" );
// Movies
Node theMatrix = graphDb.createNode();
theMatrix.setProperty( "title", "The Matrix" );
theMatrix.setProperty( "year", 1999 );
movies.add( theMatrix, "title", theMatrix.getProperty( "title" ) );
movies.add( theMatrix, "year", theMatrix.getProperty( "year" ) );
Node theMatrixReloaded = graphDb.createNode();
theMatrixReloaded.setProperty( "title", "The Matrix Reloaded" );
theMatrixReloaded.setProperty( "year", 2003 );
movies.add( theMatrixReloaded, "title", theMatrixReloaded.getProperty( "title" ) );
movies.add( theMatrixReloaded, "year", 2003 );
Node malena = graphDb.createNode();
malena.setProperty( "title", "Malèna" );
malena.setProperty( "year", 2000 );
movies.add( malena, "title", malena.getProperty( "title" ) );
movies.add( malena, "year", malena.getProperty( "year" ) );
]]></programlisting>
<simpara>Note that there can be multiple values associated with the same entity and key.</simpara>
<simpara>Next up, we&#8217;ll create relationships and index them as well:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[// we need a relationship type
DynamicRelationshipType ACTS_IN = DynamicRelationshipType.withName( "ACTS_IN" );
// create relationships
Relationship role1 = reeves.createRelationshipTo( theMatrix, ACTS_IN );
role1.setProperty( "name", "Neo" );
roles.add( role1, "name", role1.getProperty( "name" ) );
Relationship role2 = reeves.createRelationshipTo( theMatrixReloaded, ACTS_IN );
role2.setProperty( "name", "Neo" );
roles.add( role2, "name", role2.getProperty( "name" ) );
Relationship role3 = bellucci.createRelationshipTo( theMatrixReloaded, ACTS_IN );
role3.setProperty( "name", "Persephone" );
roles.add( role3, "name", role3.getProperty( "name" ) );
Relationship role4 = bellucci.createRelationshipTo( malena, ACTS_IN );
role4.setProperty( "name", "Malèna Scordia" );
roles.add( role4, "name", role4.getProperty( "name" ) );
]]></programlisting>
<simpara>After these operations, our example graph looks like this:</simpara>
<figure><title>Movie and Actor Graph</title>
<ulink url="images/Movie-and-Actor-Graph-initial.svg">
<inlinemediaobject>
  <imageobject>
  <imagedata fileref="images/Movie-and-Actor-Graph-initial.svg"/>
  </imageobject>
  <textobject><phrase>Movie-and-Actor-Graph-initial.svg</phrase></textobject>
</inlinemediaobject>
</ulink>
</figure>
</section>
<section id="indexing-remove">
<title>Remove</title>
<simpara><ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/Index.html#remove%28T,%20java.lang.String,%20java.lang.Object%29">Removing</ulink> from an index is similar to adding, but can be done by supplying one of the following combinations of arguments:</simpara>
<itemizedlist>
<listitem>
<simpara>
entity
</simpara>
</listitem>
<listitem>
<simpara>
entity, key
</simpara>
</listitem>
<listitem>
<simpara>
entity, key, value
</simpara>
</listitem>
</itemizedlist>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[// completely remove bellucci from the actors index
actors.remove( bellucci );
// remove any "name" entry of bellucci from the actors index
actors.remove( bellucci, "name" );
// remove the "name" -> "La Bellucci" entry of bellucci
actors.remove( bellucci, "name", "La Bellucci" );
]]></programlisting>
</section>
<section id="indexing-update">
<title>Update</title>
<important><simpara>To update an index entry, the old one must be removed and a new one added.
For details on removing index entries, see <xref linkend="indexing-remove"/>.</simpara></important>
<simpara>Remember that a node or relationship can be associated with any number of key-value pairs in an index.
This means that you can index a node or relationship with many key-value pairs that have the same key.
In the case where a property value changes and you&#8217;d like to update the index, it&#8217;s not enough to just index the new value&#8201;&#8212;&#8201;you&#8217;ll have to remove the old value as well.</simpara>
<simpara>Here&#8217;s a code example that demonstrates how it&#8217;s done:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[// create a node with a property
// so we have something to update later on
Node fishburn = graphDb.createNode();
fishburn.setProperty( "name", "Fishburn" );
// index it
actors.add( fishburn, "name", fishburn.getProperty( "name" ) );
// update the index entry
// when the property value changes
actors.remove( fishburn, "name", fishburn.getProperty( "name" ) );
fishburn.setProperty( "name", "Laurence Fishburn" );
actors.add( fishburn, "name", fishburn.getProperty( "name" ) );
]]></programlisting>
</section>
<section id="indexing-search">
<title>Search</title>
<simpara>An index can be searched in two ways, <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/Index.html#get%28java.lang.String,%20java.lang.Object%29">get</ulink> and <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/Index.html#query%28java.lang.String,%20java.lang.Object%29">query</ulink>.
The <literal>get</literal> method will return exact matches to the given key-value pair, whereas <literal>query</literal> exposes querying capabilities directly from the backend used by the index.
For example the <ulink url="http://lucene.apache.org/core/3_6_2/queryparsersyntax.html">Lucene query syntax</ulink> can be used directly with the default indexing backend.</simpara>
<section id="indexing-search-get">
<title>Get</title>
<simpara>This is how to search for a single exact match:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[IndexHits<Node> hits = actors.get( "name", "Keanu Reeves" );
Node reeves = hits.getSingle();
]]></programlisting>
<simpara><ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/IndexHits.html">IndexHits</ulink> is an <literal>Iterable</literal> with some additional useful methods. For example <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/IndexHits.html#getSingle%28%29">getSingle()</ulink> returns the first and only item from the result iterator, or <literal>null</literal> if there isn&#8217;t any hit.</simpara>
<simpara>Here&#8217;s how to get a single relationship by exact matching and retrieve its start and end nodes:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Relationship persephone = roles.get( "name", "Persephone" ).getSingle();
Node actor = persephone.getStartNode();
Node movie = persephone.getEndNode();
]]></programlisting>
<simpara>Finally, we can iterate over all exact matches from a relationship index:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[for ( Relationship role : roles.get( "name", "Neo" ) )
{
    // this will give us Reeves twice
    Node reeves = role.getStartNode();
}
]]></programlisting>
<important><simpara>In case you don&#8217;t iterate through all the hits, <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/IndexHits.html#close%28%29">IndexHits.close()</ulink> must be called explicitly.</simpara></important>
</section>
<section id="indexing-search-query">
<title>Query</title>
<simpara>There are two query methods, one which uses a key-value signature where the value represents a query for values with the given key only.
The other method is more generic and supports querying for more than one key-value pair in the same query.</simpara>
<simpara>Here&#8217;s an example using the key-query option:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[for ( Node actor : actors.query( "name", "*e*" ) )
{
    // This will return Reeves and Bellucci
}
]]></programlisting>
<simpara>In the following example the query uses multiple keys:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[for ( Node movie : movies.query( "title:*Matrix* AND year:1999" ) )
{
    // This will return "The Matrix" from 1999 only.
}
]]></programlisting>
<note><simpara>Beginning a wildcard search with "*" or "?" is discouraged by Lucene, but will nevertheless work.</simpara></note>
<caution><simpara>You can&#8217;t have <emphasis>any whitespace</emphasis> in the search term with this syntax.
  See <xref linkend="indexing-lucene-query-objects"/> for how to do that.</simpara></caution>
</section>
</section>
<section id="indexing-relationships">
<title>Relationship indexes</title>
<simpara>An index for relationships is just like an index for nodes, extended by providing support to constrain a search to relationships with a specific start and/or end nodes
These extra methods reside in the <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/RelationshipIndex.html">RelationshipIndex</ulink> interface which extends <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/Index.html">Index&lt;Relationship&gt;</ulink>.</simpara>
<simpara>Example of querying a relationship index:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[// find relationships filtering on start node
// using exact matches
IndexHits<Relationship> reevesAsNeoHits;
reevesAsNeoHits = roles.get( "name", "Neo", reeves, null );
Relationship reevesAsNeo = reevesAsNeoHits.iterator().next();
reevesAsNeoHits.close();
// find relationships filtering on end node
// using a query
IndexHits<Relationship> matrixNeoHits;
matrixNeoHits = roles.query( "name", "*eo", null, theMatrix );
Relationship matrixNeo = matrixNeoHits.iterator().next();
matrixNeoHits.close();
]]></programlisting>
<simpara>And here&#8217;s an example for the special case of searching for a specific relationship type:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[// find relationships filtering on end node
// using a relationship type.
// this is how to add it to the index:
roles.add( reevesAsNeo, "type", reevesAsNeo.getType().name() );
// Note that to use a compound query, we can't combine committed
// and uncommitted index entries, so we'll commit before querying:
tx.success();
tx.finish();

// and now we can search for it:
try ( Transaction tx = graphDb.beginTx() )
{
    IndexHits<Relationship> typeHits = roles.query( "type:ACTS_IN AND name:Neo", null, theMatrix );
    Relationship typeNeo = typeHits.iterator().next();
    typeHits.close();
]]></programlisting>
<simpara>Such an index can be useful if your domain has nodes with a very large number of relationships between them, since it reduces the search time for a relationship between two nodes.
A good example where this approach pays dividends is in time series data, where we have readings represented as a relationship per occurrence.</simpara>
</section>
<section id="indexing-scores">
<title>Scores</title>
<simpara>The <literal>IndexHits</literal> interface exposes <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/IndexHits.html#currentScore%28%29">scoring</ulink> so that the index can communicate scores for the hits.
Note that the result is not sorted by the score unless you explicitly specify that.
See <xref linkend="indexing-lucene-sort"/> for how to sort by score.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[IndexHits<Node> hits = movies.query( "title", "The*" );
for ( Node movie : hits )
{
    System.out.println( movie.getProperty( "title" ) + " " + hits.currentScore() );
}
]]></programlisting>
</section>
<section id="indexing-create-advanced">
<title>Configuration and fulltext indexes</title>
<simpara>At the time of creation extra configuration can be specified to control the behavior of the index and which backend to use.
For example to create a Lucene fulltext index:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[IndexManager index = graphDb.index();
Index<Node> fulltextMovies = index.forNodes( "movies-fulltext",
        MapUtil.stringMap( IndexManager.PROVIDER, "lucene", "type", "fulltext" ) );
fulltextMovies.add( theMatrix, "title", "The Matrix" );
fulltextMovies.add( theMatrixReloaded, "title", "The Matrix Reloaded" );
// search in the fulltext index
Node found = fulltextMovies.query( "title", "reloAdEd" ).getSingle();
]]></programlisting>
<simpara>Here&#8217;s an example of how to create an exact index which is case-insensitive:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Index<Node> index = graphDb.index().forNodes( "exact-case-insensitive",
        stringMap( "type", "exact", "to_lower_case", "true" ) );
Node node = graphDb.createNode();
index.add( node, "name", "Thomas Anderson" );
assertContains( index.query( "name", "\"Thomas Anderson\"" ), node );
assertContains( index.query( "name", "\"thoMas ANDerson\"" ), node );
]]></programlisting>
<tip><simpara>In order to search for tokenized words, the <literal>query</literal> method has to be used.
  The <literal>get</literal> method will only match the full string value, not the tokens.</simpara></tip>
<simpara>The configuration of the index is persisted once the index has been created.
The <literal>provider</literal> configuration key is interpreted by Neo4j, but any other configuration is passed onto the backend index (e.g. Lucene) to interpret.</simpara>
<table
frame="none"
rowsep="1" colsep="1"
>
<title>Lucene indexing configuration parameters</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="30*"/>
<colspec colname="col_3" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"> Parameter                 </entry>
<entry align="left" valign="top"> Possible values   </entry>
<entry align="left" valign="top"> Effect</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>type</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>exact</literal>, <literal>fulltext</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>exact</literal> is the default and uses a Lucene <ulink url="http://lucene.apache.org/core/3_6_2/api/core/org/apache/lucene/analysis/KeywordAnalyzer.html">keyword analyzer</ulink>.
  <literal>fulltext</literal> uses a white-space tokenizer in its analyzer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>to_lower_case</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>, <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This parameter goes together with <literal>type</literal>: <literal>fulltext</literal> and converts values to lower case during both additions and querying, making the index case insensitive. Defaults to <literal>true</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>analyzer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>the full class name of an <ulink url="http://lucene.apache.org/core/3_6_2/api/core/org/apache/lucene/analysis/Analyzer.html">Analyzer</ulink></simpara></entry>
<entry align="left" valign="top"><simpara>Overrides the <literal>type</literal> so that a custom analyzer can be used.
  Note: <literal>to_lower_case</literal> still affects lowercasing of string queries.
  If the custom analyzer uppercases the indexed tokens, string queries will not match as expected.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="indexing-lucene-extras">
<title>Extra features for Lucene indexes</title>
<section id="indexing-lucene-numeric-ranges">
<title>Numeric ranges</title>
<simpara>Lucene supports smart indexing of numbers, querying for ranges and sorting such results, and so does its backend for Neo4j.
To mark a value so that it is indexed as a numeric value, we can make use of the <ulink url="http://components.neo4j.org/neo4j-lucene-index/2.0-SNAPSHOT/apidocs/org/neo4j/index/lucene/ValueContext.html">ValueContext</ulink> class, like this:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[movies.add( theMatrix, "year-numeric", new ValueContext( 1999 ).indexNumeric() );
movies.add( theMatrixReloaded, "year-numeric", new ValueContext( 2003 ).indexNumeric() );
movies.add( malena, "year-numeric", new ValueContext( 2000 ).indexNumeric() );

int from = 1997;
int to = 1999;
hits = movies.query( QueryContext.numericRange( "year-numeric", from, to ) );
]]></programlisting>
<note><simpara>The same type must be used for indexing and querying.
That is, you can&#8217;t index a value as a Long and then query the index using an Integer.</simpara></note>
<simpara>By giving <literal>null</literal> as from/to argument, an open ended query is created.
In the following example we are doing that, and have added sorting to the query as well:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[hits = movies.query(
        QueryContext.numericRange( "year-numeric", from, null )
                .sortNumeric( "year-numeric", false ) );
]]></programlisting>
<simpara>From/to in the ranges defaults to be <emphasis>inclusive</emphasis>, but you can change this behavior by using two extra parameters:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[movies.add( theMatrix, "score", new ValueContext( 8.7 ).indexNumeric() );
movies.add( theMatrixReloaded, "score", new ValueContext( 7.1 ).indexNumeric() );
movies.add( malena, "score", new ValueContext( 7.4 ).indexNumeric() );

// include 8.0, exclude 9.0
hits = movies.query( QueryContext.numericRange( "score", 8.0, 9.0, true, false ) );
]]></programlisting>
</section>
<section id="indexing-lucene-sort">
<title>Sorting</title>
<simpara>Lucene performs sorting very well, and that is also exposed in the index backend, through the <ulink url="http://components.neo4j.org/neo4j-lucene-index/2.0-SNAPSHOT/apidocs/org/neo4j/index/lucene/QueryContext.html">QueryContext</ulink> class:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[hits = movies.query( "title", new QueryContext( "*" ).sort( "title" ) );
for ( Node hit : hits )
{
    // all movies with a title in the index, ordered by title
}
// or
hits = movies.query( new QueryContext( "title:*" ).sort( "year", "title" ) );
for ( Node hit : hits )
{
    // all movies with a title in the index, ordered by year, then title
}
]]></programlisting>
<simpara>We sort the results by relevance (score) like this:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[hits = movies.query( "title", new QueryContext( "The*" ).sortByScore() );
for ( Node movie : hits )
{
    // hits sorted by relevance (score)
}
]]></programlisting>
</section>
<section id="indexing-lucene-query-objects">
<title>Querying with Lucene Query objects</title>
<simpara>Instead of passing in Lucene query syntax queries, you can instantiate such queries programmatically and pass in as argument, for example:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[// a TermQuery will give exact matches
Node actor = actors.query( new TermQuery( new Term( "name", "Keanu Reeves" ) ) ).getSingle();
]]></programlisting>
<simpara>Note that the <ulink url="http://lucene.apache.org/core/3_6_2/api/core/org/apache/lucene/search/TermQuery.html">TermQuery</ulink> is basically the same thing as using the <literal>get</literal> method on the index.</simpara>
<simpara>This is how to perform <emphasis>wildcard</emphasis> searches using Lucene Query Objects:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[hits = movies.query( new WildcardQuery( new Term( "title", "The Matrix*" ) ) );
for ( Node movie : hits )
{
    System.out.println( movie.getProperty( "title" ) );
}
]]></programlisting>
<simpara>Note that this allows for whitespace in the search string.</simpara>
</section>
<section id="indexing-lucene-compound">
<title>Compound queries</title>
<simpara>Lucene supports querying for multiple terms in the same query, like so:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[hits = movies.query( "title:*Matrix* AND year:1999" );
]]></programlisting>
<caution><simpara>Compound queries can&#8217;t search across committed index entries and those who haven&#8217;t got committed yet at the same time.</simpara></caution>
</section>
<section id="indexing-lucene-default-operator">
<title>Default operator</title>
<simpara>The default operator (that is whether <literal>AND</literal> or <literal>OR</literal> is used in between different terms) in a query is <literal>OR</literal>. Changing that behavior is also done via the <ulink url="http://components.neo4j.org/neo4j-lucene-index/2.0-SNAPSHOT/apidocs/org/neo4j/index/lucene/QueryContext.html">QueryContext</ulink> class:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[QueryContext query = new QueryContext( "title:*Matrix* year:1999" )
        .defaultOperator( Operator.AND );
hits = movies.query( query );
]]></programlisting>
</section>
<section id="indexing-lucene-caching">
<title>Caching</title>
<simpara>If your index lookups becomes a performance bottle neck, caching can be enabled for certain keys in certain indexes (key locations) to speed up get requests.
The caching is implemented with an <ulink url="http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used">LRU</ulink> cache so that only the most recently accessed results are cached (with "results" meaning a query result of a get request, not a single entity).
You can control the size of the cache (the maximum number of results) per index key.</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Index<Node> index = graphDb.index().forNodes( "actors" );
((LuceneIndex<Node>) index).setCacheCapacity( "name", 300000 );
]]></programlisting>
<caution><simpara>This setting is not persisted after shutting down the database.
  This means: set this value after each startup of the database if you want to keep it.</simpara></caution>
</section>
</section>
<section id="auto-indexing">
<title>Automatic Indexing</title>
<simpara>Neo4j provides a single index for nodes and one for relationships in each database that automatically follow property values as they are added, deleted and changed on database primitives.
This functionality is called <emphasis>auto indexing</emphasis> and is controlled both from the database configuration Map and through its own API.</simpara>
<section id="auto-indexing-config">
<title>Configuration</title>
<simpara>By default Auto Indexing is off for both Nodes and Relationships.
To configure this in the <emphasis>neo4j.properties</emphasis> file, use the configuration keys <literal>node_auto_indexing</literal> and <literal>relationship_auto_indexing</literal>.
For embedded mode, use the configuration options <literal>GraphDatabaseSettings.node_auto_indexing</literal>
and <literal>GraphDatabaseSettings.relationship_auto_indexing</literal>.
In both cases, set the value to <literal>true</literal>.
This will enable automatic indexing on startup.
Just note that we&#8217;re not done yet, see below!</simpara>
<simpara>To actually auto index something, you have to set which properties should get indexed.
You do this by listing the property keys to index on.
In the configuration file, use the <literal>node_keys_indexable</literal> and <literal>relationship_keys_indexable</literal> configuration keys.
When using embedded mode, use the <literal>GraphDatabaseSettings.node_keys_indexable</literal> and <literal>GraphDatabaseSettings.relationship_keys_indexable</literal> configuration keys.
In all cases, the value should be a comma separated list of property keys to index on.</simpara>
<simpara>When coding in Java, it&#8217;s done like this:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[/*
 * Creating the configuration, adding nodeProp1 and nodeProp2 as
 * auto indexed properties for Nodes and relProp1 and relProp2 as
 * auto indexed properties for Relationships. Only those will be
 * indexed. We also have to enable auto indexing for both these
 * primitives explicitly.
 */
GraphDatabaseService graphDb = new GraphDatabaseFactory().
    newEmbeddedDatabaseBuilder( storeDirectory ).
    setConfig( GraphDatabaseSettings.node_keys_indexable, "nodeProp1,nodeProp2" ).
    setConfig( GraphDatabaseSettings.relationship_keys_indexable, "relProp1,relProp2" ).
    setConfig( GraphDatabaseSettings.node_auto_indexing, "true" ).
    setConfig( GraphDatabaseSettings.relationship_auto_indexing, "true" ).
    newGraphDatabase();

Node node1 = null, node2 = null;
Relationship rel = null;
try ( Transaction tx = graphDb.beginTx() )
{
    // Create the primitives
    node1 = graphDb.createNode();
    node2 = graphDb.createNode();
    rel = node1.createRelationshipTo( node2,
            DynamicRelationshipType.withName( "DYNAMIC" ) );

    // Add indexable and non-indexable properties
    node1.setProperty( "nodeProp1", "nodeProp1Value" );
    node2.setProperty( "nodeProp2", "nodeProp2Value" );
    node1.setProperty( "nonIndexed", "nodeProp2NonIndexedValue" );
    rel.setProperty( "relProp1", "relProp1Value" );
    rel.setProperty( "relPropNonIndexed", "relPropValueNonIndexed" );

    // Make things persistent
    tx.success();
}
]]></programlisting>
</section>
<section id="auto-indexing-api">
<title>Search</title>
<simpara>The usefulness of the auto indexing functionality comes of course from the ability to actually query the index and retrieve results.
To that end, you can acquire a <literal>ReadableIndex</literal> object from the <literal>AutoIndexer</literal> that exposes all the query and get methods of a full
<ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/graphdb/index/Index.html"><literal>Index</literal></ulink> with exactly the same functionality.
Continuing from the previous example, accessing the index is done like this:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( Transaction tx = graphDb.beginTx() )
{
    // Get the Node auto index
    ReadableIndex<Node> autoNodeIndex = graphDb.index()
            .getNodeAutoIndexer()
            .getAutoIndex();
    // node1 and node2 both had auto indexed properties, get them
    assertEquals( node1,
            autoNodeIndex.get( "nodeProp1", "nodeProp1Value" ).getSingle() );
    assertEquals( node2,
            autoNodeIndex.get( "nodeProp2", "nodeProp2Value" ).getSingle() );
    // node2 also had a property that should be ignored.
    assertFalse( autoNodeIndex.get( "nonIndexed",
            "nodeProp2NonIndexedValue" ).hasNext() );

    // Get the relationship auto index
    ReadableIndex<Relationship> autoRelIndex = graphDb.index()
            .getRelationshipAutoIndexer()
            .getAutoIndex();
    // One property was set for auto indexing
    assertEquals( rel,
            autoRelIndex.get( "relProp1", "relProp1Value" ).getSingle() );
    // The rest should be ignored
    assertFalse( autoRelIndex.get( "relPropNonIndexed",
            "relPropValueNonIndexed" ).hasNext() );
}
]]></programlisting>
</section>
<section id="auto-indexing-config-api">
<title>Runtime Configuration</title>
<simpara>The same options that are available during database creation via the configuration can also be set during runtime via the <literal>AutoIndexer</literal> API.</simpara>
<simpara>Gaining access to the <literal>AutoIndexer</literal> API and adding two <literal>Node</literal> and one <literal>Relationship</literal> properties to auto index is done like so:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[// Start without any configuration
GraphDatabaseService graphDb = new GraphDatabaseFactory().
        newEmbeddedDatabase( storeDirectory );

// Get the Node AutoIndexer, set nodeProp1 and nodeProp2 as auto
// indexed.
AutoIndexer<Node> nodeAutoIndexer = graphDb.index()
        .getNodeAutoIndexer();
nodeAutoIndexer.startAutoIndexingProperty( "nodeProp1" );
nodeAutoIndexer.startAutoIndexingProperty( "nodeProp2" );

// Get the Relationship AutoIndexer
AutoIndexer<Relationship> relAutoIndexer = graphDb.index()
        .getRelationshipAutoIndexer();
relAutoIndexer.startAutoIndexingProperty( "relProp1" );

// None of the AutoIndexers are enabled so far. Do that now
nodeAutoIndexer.setEnabled( true );
relAutoIndexer.setEnabled( true );

]]></programlisting>
<note><simpara>Parameters to the AutoIndexers passed through the Configuration and settings made through the API are cumulative.
So you can set some beforehand known settings, do runtime checks to augment the initial configuration and then enable the desired auto indexers -
the final configuration is the same regardless of the method used to reach it.</simpara></note>
</section>
<section id="auto-indexing-update-removal">
<title>Updating the Automatic Index</title>
<simpara>Updates to the auto indexed properties happen of course automatically as you update them. Removal of properties from the auto index happens for two reasons.
One is that you actually removed the property. The other is that you stopped autoindexing on a property. When the latter happens, any primitive you touch and
it has that property, it is removed from the auto index, regardless of any operations on the property.
When you start or stop auto indexing on a property, no auto update operation happens currently. If you need to change the set of auto indexed properties and
have them re-indexed, you currently have to do this by hand. An example will illustrate the above better:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[/*
 * Creating the configuration
 */
GraphDatabaseService graphDb = new GraphDatabaseFactory().
    newEmbeddedDatabaseBuilder( storeDirectory ).
    setConfig( GraphDatabaseSettings.node_keys_indexable, "nodeProp1,nodeProp2" ).
    setConfig( GraphDatabaseSettings.node_auto_indexing, "true" ).
    newGraphDatabase();

Node node1 = null, node2 = null, node3 = null, node4 = null;
try ( Transaction tx = graphDb.beginTx() )
{
    // Create the primitives
    node1 = graphDb.createNode();
    node2 = graphDb.createNode();
    node3 = graphDb.createNode();
    node4 = graphDb.createNode();

    // Add indexable and non-indexable properties
    node1.setProperty( "nodeProp1", "nodeProp1Value" );
    node2.setProperty( "nodeProp2", "nodeProp2Value" );
    node3.setProperty( "nodeProp1", "nodeProp3Value" );
    node4.setProperty( "nodeProp2", "nodeProp4Value" );

    // Make things persistent
    tx.success();
}

/*
 *  Here both nodes are indexed. To demonstrate removal, we stop
 *  autoindexing nodeProp1.
 */
AutoIndexer<Node> nodeAutoIndexer = graphDb.index().getNodeAutoIndexer();
nodeAutoIndexer.stopAutoIndexingProperty( "nodeProp1" );

try ( Transaction tx = graphDb.beginTx() )
{
    /*
     * nodeProp1 is no longer auto indexed. It will be
     * removed regardless. Note that node3 will remain.
     */
    node1.setProperty( "nodeProp1", "nodeProp1Value2" );
    /*
     * node2 will be auto updated
     */
    node2.setProperty( "nodeProp2", "nodeProp2Value2" );
    /*
     * remove node4 property nodeProp2 from index.
     */
    node4.removeProperty( "nodeProp2" );
    // Make things persistent
    tx.success();
}

try ( Transaction tx = graphDb.beginTx() )
{
    // Verify
    ReadableIndex<Node> nodeAutoIndex = nodeAutoIndexer.getAutoIndex();
    // node1 is completely gone
    assertFalse( nodeAutoIndex.get( "nodeProp1", "nodeProp1Value" ).hasNext() );
    assertFalse( nodeAutoIndex.get( "nodeProp1", "nodeProp1Value2" ).hasNext() );
    // node2 is updated
    assertFalse( nodeAutoIndex.get( "nodeProp2", "nodeProp2Value" ).hasNext() );
    assertEquals( node2,
            nodeAutoIndex.get( "nodeProp2", "nodeProp2Value2" ).getSingle() );
    /*
     * node3 is still there, despite its nodeProp1 property not being monitored
     * any more because it was not touched, in contrast with node1.
     */
    assertEquals( node3,
            nodeAutoIndex.get( "nodeProp1", "nodeProp3Value" ).getSingle() );
    // Finally, node4 is removed because the property was removed.
    assertFalse( nodeAutoIndex.get( "nodeProp2", "nodeProp4Value" ).hasNext() );
}
]]></programlisting>
<caution><simpara>If you start the database with auto indexing enabled but different auto indexed properties than the last run, then already auto-indexed properties will be deleted from the index when a value is written to them (assuming the property isn&#8217;t present in the new configuration).
Make sure that the monitored set is what you want before enabling the functionality.</simpara></caution>
</section>
</section>
</chapter>
<chapter id="batchinsert">
<title>Batch Insertion</title>
<simpara>Neo4j has a batch insertion facility intended for initial imports, which bypasses transactions and other checks in favor of performance.
This is useful when you have a big dataset that needs to be loaded once.</simpara>
<simpara>Batch insertion is included in the <ulink url="http://search.maven.org/#search|ga|1|neo4j-kernel">neo4j-kernel</ulink> component, which is part of all Neo4j distributions and editions.</simpara>
<simpara>Be aware of the following points when using batch insertion:</simpara>
<itemizedlist>
<listitem>
<simpara>
The intended use is for initial import of data.
</simpara>
</listitem>
<listitem>
<simpara>
Batch insertion is <emphasis>not thread safe.</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
Batch insertion is <emphasis>non-transactional.</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
Batch insertion will re-populate all existing indexes and indexes created during batch insertion
  on shutdown.
</simpara>
</listitem>
<listitem>
<simpara>
Unless <literal>shutdown</literal> is successfully invoked at the end of the import, the database files <emphasis>will</emphasis> be corrupt.
</simpara>
</listitem>
</itemizedlist>
<warning><simpara>Always perform batch insertion in a <emphasis>single thread</emphasis> (or use synchronization to make only one thread at a time access the batch inserter) and invoke <literal>shutdown</literal> when finished.</simpara></warning>
<section id="batchinsert-examples">
<title>Batch Inserter Examples</title>
<simpara>Creating a batch inserter is similar to how you normally create data in the database, but in this case the low-level <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/unsafe/batchinsert/BatchInserter.html"><literal>BatchInserter</literal></ulink> interface is used.
As we have already pointed out, you can&#8217;t have multiple threads using the batch inserter concurrently without external synchronization.</simpara>
<tip><simpara>The source code of the examples is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/kernel/src/test/java/examples/BatchInsertDocTest.java">BatchInsertDocTest.java</ulink></simpara></tip>
<simpara>To get hold of a <literal>BatchInseter</literal>, use <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/unsafe/batchinsert/BatchInserters.html"><literal>BatchInserters</literal></ulink> and then go from there:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[BatchInserter inserter = BatchInserters.inserter( "target/batchinserter-example", fileSystem );
Label personLabel = DynamicLabel.label( "Person" );
inserter.createDeferredSchemaIndex( personLabel ).on( "name" ).create();
Map<String, Object> properties = new HashMap<>();
properties.put( "name", "Mattias" );
long mattiasNode = inserter.createNode( properties, personLabel );
properties.put( "name", "Chris" );
long chrisNode = inserter.createNode( properties, personLabel );
RelationshipType knows = DynamicRelationshipType.withName( "KNOWS" );
// To set properties on the relationship, use a properties map
// instead of null as the last parameter.
inserter.createRelationship( mattiasNode, chrisNode, knows, null );
inserter.shutdown();
]]></programlisting>
<simpara>To gain good performance you probably want to set some configuration settings for the batch inserter.
Read <xref linkend="configuration-batchinsert"/> for information on configuring a batch inserter.
This is how to start a batch inserter with configuration options:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[Map<String, String> config = new HashMap<>();
config.put( "neostore.nodestore.db.mapped_memory", "90M" );
BatchInserter inserter = BatchInserters.inserter(
        "target/batchinserter-example-config", fileSystem, config );
// Insert data here ... and then shut down:
inserter.shutdown();
]]></programlisting>
<simpara>In case you have stored the configuration in a file, you can load it like this:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[try ( InputStream input = fileSystem.openAsInputStream( new File( "target/batchinsert-config" ) ) )
{
    Map<String, String> config = MapUtil.load( input );
    BatchInserter inserter = BatchInserters.inserter(
            "target/batchinserter-example-config", fileSystem, config );
    // Insert data here ... and then shut down:
    inserter.shutdown();
}
]]></programlisting>
</section>
<section id="batchinsert-db">
<title>Batch Graph Database</title>
<simpara>In case you already have code for data import written against the normal Neo4j API, you could consider using a batch inserter exposing that API.</simpara>
<note><simpara>This will not perform as good as using the <literal>BatchInserter</literal> API directly.</simpara></note>
<simpara>Also be aware of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>
Starting a transaction or invoking <literal>Transaction.finish()/close()</literal> or <literal>Transaction.success()</literal> will do nothing.
</simpara>
</listitem>
<listitem>
<simpara>
Invoking the <literal>Transaction.failure()</literal> method will generate a <literal>NotInTransaction</literal> exception.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>Node.delete()</literal> and <literal>Node.traverse()</literal> are not supported.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>Relationship.delete()</literal> is not supported.
</simpara>
</listitem>
<listitem>
<simpara>
Event handlers and indexes are not supported.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>GraphDatabaseService.getRelationshipTypes()</literal>, <literal>getAllNodes()</literal> and <literal>getAllRelationships()</literal> are not supported.
</simpara>
</listitem>
</itemizedlist>
<simpara>With these precautions in mind, this is how to do it:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[GraphDatabaseService batchDb =
        BatchInserters.batchDatabase( "target/batchdb-example", fileSystem );
Label personLabel = DynamicLabel.label( "Person" );
Node mattiasNode = batchDb.createNode( personLabel );
mattiasNode.setProperty( "name", "Mattias" );
Node chrisNode = batchDb.createNode();
chrisNode.setProperty( "name", "Chris" );
chrisNode.addLabel( personLabel );
RelationshipType knows = DynamicRelationshipType.withName( "KNOWS" );
mattiasNode.createRelationshipTo( chrisNode, knows );
batchDb.shutdown();
]]></programlisting>
<tip><simpara>The source code of the example is found here:
<ulink url="https://github.com/neo4j/neo4j/blob/master/community/kernel/src/test/java/examples/BatchInsertDocTest.java">BatchInsertDocTest.java</ulink></simpara></tip>
</section>
<section id="indexing-batchinsert">
<title>Index Batch Insertion</title>
<simpara>For general notes on batch insertion, see <xref linkend="batchinsert"/>.</simpara>
<simpara>Indexing during batch insertion is done using <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/unsafe/batchinsert/BatchInserterIndex.html">BatchInserterIndex</ulink> which are provided via <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/unsafe/batchinsert/BatchInserterIndexProvider.html">BatchInserterIndexProvider</ulink>.
An example:</simpara>
<programlisting language="java" linenumbering="unnumbered"><![CDATA[BatchInserter inserter = BatchInserters.inserter( "target/neo4jdb-batchinsert" );
BatchInserterIndexProvider indexProvider =
        new LuceneBatchInserterIndexProvider( inserter );
BatchInserterIndex actors =
        indexProvider.nodeIndex( "actors", MapUtil.stringMap( "type", "exact" ) );
actors.setCacheCapacity( "name", 100000 );

Map<String, Object> properties = MapUtil.map( "name", "Keanu Reeves" );
long node = inserter.createNode( properties );
actors.add( node, properties );

//make the changes visible for reading, use this sparsely, requires IO!
actors.flush();

// Make sure to shut down the index provider as well
indexProvider.shutdown();
inserter.shutdown();
]]></programlisting>
<simpara>The configuration parameters are the same as mentioned in <xref linkend="indexing-create-advanced"/>.</simpara>
<section id="indexing-batchinsert-best-practices">
<title>Best practices</title>
<simpara>Here are some pointers to get the most performance out of <literal>BatchInserterIndex</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>
Try to avoid <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/unsafe/batchinsert/BatchInserterIndex.html#flush%28%29">flushing</ulink> too often because each flush will result in all additions (since last flush) to be visible to the querying methods, and publishing those changes can be a performance penalty.
</simpara>
</listitem>
<listitem>
<simpara>
Have (as big as possible) phases where one phase is either only writes or only reads, and don&#8217;t forget to flush after a write phase so that those changes becomes visible to the querying methods.
</simpara>
</listitem>
<listitem>
<simpara>
Enable <ulink url="http://components.neo4j.org/neo4j/2.0-SNAPSHOT/apidocs/org/neo4j/unsafe/batchinsert/BatchInserterIndex.html#setCacheCapacity%28java.lang.String,%20int%29">caching</ulink> for keys you know you&#8217;re going to do lookups for later on to increase performance significantly (though insertion performance may degrade slightly).
</simpara>
</listitem>
</itemizedlist>
<note><simpara>Changes to the index are available for reading first after they are flushed to disk.
Thus, for optimal performance, read and lookup operations should be kept to a minimum during batchinsertion since they
involve IO and impact speed negatively.</simpara></note>
</section>
</section>
</chapter>
</part>
<appendix id="manpages">
<title>Manpages</title>
<simpara>The Neo4j Unix manual pages are included on the following pages.</simpara>
<itemizedlist>
<listitem>
<simpara>
<link linkend="neo4j-manpage">neo4j</link>
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="neo4j-installer-manpage">neo4j-installer</link>
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="shell-manpage">neo4j-shell</link>
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="neo4j-backup-manpage">neo4j-backup</link>
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="neo4j-arbiter-manpage">neo4j-arbiter</link>
</simpara>
</listitem>
</itemizedlist>
<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="neo4j.1.xml"></xi:include>
<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="neo4j-installer.1.xml"></xi:include>
<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="neo4j-shell.1.xml"></xi:include>
<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="neo4j-backup.1.xml"></xi:include>
<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="neo4j-arbiter.1.xml"></xi:include>
</appendix>
</book>
